<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BCM v2 ‚Äî Voids (Locks) + Energy (Harvest) + Keys (Compose/Transfer) + Inspector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    :root { --uiw: 460px; }
    html, body { margin:0; height:100%; background:#0e0f12; color:#e8eaf1; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    #ui{
      position:fixed; top:0; right:0; width:var(--uiw); height:100%;
      overflow:auto; box-sizing:border-box; padding:14px 14px 120px;
      background:#14161b; border-left:1px solid #1e2230;
    }
    #ui h2{ margin:6px 0 10px; font-size:16px; font-weight:700; }
    .group{ border:1px solid #1f2535; border-radius:10px; padding:10px; margin-bottom:12px; background:#10131a; }
    label{ display:block; font-size:12px; opacity:.9; margin:6px 0 4px; }
    input[type="range"]{ width:100%; }
    button, select{
      width:100%; border-radius:8px; border:1px solid #2a3248;
      padding:8px 10px; background:#18202d; color:#e8eaf1; cursor:pointer;
    }
    button:hover{ background:#1c2737; }
    .row{ display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    details summary{ cursor:pointer; user-select:none; }
    pre{
      white-space:pre; background:#0c0f16; border:1px solid #1f2535;
      border-radius:8px; padding:10px; color:#d6dbef; font-size:12px; line-height:1.35;
      overflow:auto;
    }
    #metrics{
      position:fixed; left:10px; top:10px;
      background:rgba(8,10,14,.78); border:1px solid #1e2230; border-radius:8px;
      padding:8px 10px; backdrop-filter:blur(6px);
      max-width:520px;
    }
    canvas{ display:block; }
    .tiny{ font-size:11px; opacity:.85; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .kv { display:grid; grid-template-columns: 110px 1fr; gap:4px 10px; font-size:12px; }
    .kv div:nth-child(odd){ opacity:.85; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a3248; background:#141b28; font-size:11px; opacity:.95; }
    .warn { color:#ffd28a; }
    .good { color:#8bffb0; }
    .bad { color:#ff9a9a; }
  </style>
</head>

<body>

<div id="ui">
  <h2>BCM v2 ‚Äî Harvest ‚Üí Spend ‚Üí Adapt</h2>

  <div class="group">
    <div class="row">
      <button id="btnPause">Pause</button>
      <button id="btnReset">Reset</button>
    </div>
    <div class="tiny" style="margin-top:6px">
      Shortcuts: <span class="mono">Space</span>=pause, <span class="mono">R</span>=reset, <span class="mono">V</span>=spawn void, <span class="mono">E</span>=spawn energy
    </div>
    <div class="tiny" style="margin-top:6px">
      Click to select: agent / void / energy (white ring highlight).
    </div>
  </div>

  <div class="group" id="inspector">
    <h3 style="margin:6px 0 6px; font-size:13px">Inspector</h3>
    <div class="tiny">Select an agent, void, or energy source to see its internal state.</div>
    <div id="inspectContent" style="margin-top:8px"></div>
  </div>

  <div class="group">
    <label>Sim speed: <span id="lblSpeed">1.00</span></label>
    <input id="sSpeed" type="range" min="0.2" max="5" step="0.01" value="1.00" />
    <label>Agents: <span id="lblAgents">40</span></label>
    <input id="sAgents" type="range" min="1" max="160" step="1" value="40" />
    <label>Key storage limit per agent: <span id="lblKCap">8</span></label>
    <input id="sKCap" type="range" min="2" max="18" step="1" value="8" />
    <label><input id="chkTrails" type="checkbox" checked /> Trails</label>
    <label><input id="chkSignals" type="checkbox" checked /> Signals (ripples)</label>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Movement Stabilizers</h3>
    <label>Energy Low (switch to Harvest): <span id="lblELow">0.30</span></label>
    <input id="sELow" type="range" min="0.05" max="0.80" step="0.01" value="0.30" />
    <label>Energy High (switch back to Solve): <span id="lblEHigh">0.55</span></label>
    <input id="sEHigh" type="range" min="0.10" max="1.20" step="0.01" value="0.55" />
    <label>Commit time (sec): <span id="lblCommit">2.5</span></label>
    <input id="sCommit" type="range" min="0" max="10" step="0.1" value="2.5" />
    <label>Switch margin (√ó): <span id="lblMargin">1.25</span></label>
    <input id="sMargin" type="range" min="1.00" max="2.50" step="0.01" value="1.25" />
    <div class="tiny">
      The ‚Äúbounce‚Äù happens when decisions re-flip every frame. These four controls stop that.
    </div>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Voids (Locks)</h3>
    <label>Spawn rate / min: <span id="lblVoidRate">18</span></label>
    <input id="sVoidRate" type="range" min="0" max="120" step="1" value="18" />
    <label>Max active voids: <span id="lblVoidMax">36</span></label>
    <input id="sVoidMax" type="range" min="0" max="140" step="1" value="36" />
    <label>Growth rate: <span id="lblVoidGrow">0.05</span></label>
    <input id="sVoidGrow" type="range" min="0" max="0.25" step="0.005" value="0.05" />
    <label>Solve threshold (area %): <span id="lblSolveThr">20</span></label>
    <input id="sSolveThr" type="range" min="1" max="60" step="1" value="20" />
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Energy (Harvest)</h3>
    <label>Spawn rate / min: <span id="lblERate">22</span></label>
    <input id="sERate" type="range" min="0" max="180" step="1" value="22" />
    <label>Max active sources: <span id="lblEMax">45</span></label>
    <input id="sEMax" type="range" min="0" max="200" step="1" value="45" />
    <label>Harvest rate: <span id="lblHarvest">0.35</span></label>
    <input id="sHarvest" type="range" min="0" max="1.2" step="0.01" value="0.35" />
    <label>Energy spend (solve): <span id="lblSpend">0.20</span></label>
    <input id="sSpend" type="range" min="0" max="1.0" step="0.01" value="0.20" />
    <div class="tiny">
      Energy sources are patterns. Keys match them to harvest. Solving also costs energy.
    </div>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Key Evolution</h3>
    <label>Try compose keys when stuck: <span id="lblCompose">On</span></label>
    <select id="selCompose">
      <option value="on" selected>On</option>
      <option value="off">Off</option>
    </select>
    <label>Compose cost: <span id="lblComposeCost">0.55</span></label>
    <input id="sComposeCost" type="range" min="0" max="2.0" step="0.01" value="0.55" />
    <div class="tiny">
      Composition is geometric OR (A ‚à™ B). It creates a new ‚Äútool shape‚Äù in the library.
    </div>
  </div>

  <div class="group tiny">
    <div><b>Legend</b></div>
    <div>üü• void (lock) ‚Äî stamp shows remaining unsolved cells</div>
    <div>üü© energy source ‚Äî stamp shows harvest pattern, ring shows remaining amount</div>
    <div>‚óè agent ‚Äî color shifts with energy; tiny label shows mode: S/H</div>
    <div>Ripples: greener = key helped, orange = did nothing / worsened</div>
  </div>
</div>

<div id="metrics"></div>

<script>
/* =========================================================
   BCM v2 + Inspector
========================================================= */

let W, H, trails;
let paused = false;
let simTime = 0;

const UI = {};
const SHAPE_N = 7;
const SHAPE_C = SHAPE_N * SHAPE_N;

let SHAPES = [];           // {name, cells:Int8Array, mass}
let COMMON = [];           // indices in SHAPES
let nextVoidId = 1;
let nextKeyId = 1;
let nextEnergyId = 1;

let agents = [];
let voids = [];
let energySources = [];
let signals = [];          // {x,y,t,ttl, payload:{voidId, areaB, keyId, areaA, shapeId, delta}}

let selection = { type: null, id: null }; // "agent"|"void"|"energy"|null
let dtSim = 0;

function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function wrap01(u){ u = u % 1; if (u < 0) u += 1; return u; }
function idxS(x,y){ return y*SHAPE_N + x; }

function torusVec(ax, ay, bx, by){
  const dx = wrapDelta(bx-ax), dy = wrapDelta(by-ay);
  return {dx, dy, d: Math.hypot(dx,dy)};
}
function wrapDelta(d){ if (d > 0.5) d -= 1; if (d < -0.5) d += 1; return d; }

function cloneCells(c){ const o = new Int8Array(c.length); o.set(c); return o; }
function shapeMass(c){ let m=0; for (let i=0;i<c.length;i++) m += c[i] ? 1 : 0; return m; }
function shapeOR(a,b){
  const o = new Int8Array(SHAPE_C);
  for (let i=0;i<SHAPE_C;i++) o[i] = (a[i] || b[i]) ? 1 : 0;
  return o;
}

function randomShape(density=0.22, smoothPasses=2){
  let c = new Int8Array(SHAPE_C);
  for (let y=0;y<SHAPE_N;y++){
    for (let x=0;x<SHAPE_N;x++){
      const cx = (x-(SHAPE_N-1)/2)/(SHAPE_N/2);
      const cy = (y-(SHAPE_N-1)/2)/(SHAPE_N/2);
      const centerBias = Math.exp(-(cx*cx+cy*cy)*1.2);
      const p = density*(0.65 + 0.7*centerBias);
      c[idxS(x,y)] = (Math.random() < p) ? 1 : 0;
    }
  }
  for (let pass=0; pass<smoothPasses; pass++){
    const n = new Int8Array(SHAPE_C);
    for (let y=0;y<SHAPE_N;y++){
      for (let x=0;x<SHAPE_N;x++){
        let sum=0;
        for (let oy=-1;oy<=1;oy++){
          for (let ox=-1;ox<=1;ox++){
            if (!ox && !oy) continue;
            const xx=x+ox, yy=y+oy;
            if (xx<0||xx>=SHAPE_N||yy<0||yy>=SHAPE_N) continue;
            sum += c[idxS(xx,yy)];
          }
        }
        const here = c[idxS(x,y)];
        n[idxS(x,y)] = (sum>=4) ? 1 : (sum<=1 ? 0 : here);
      }
    }
    c = n;
  }
  if (shapeMass(c) < 6){
    for (let i=0;i<SHAPE_C;i++) c[i]=0;
    const mid = Math.floor(SHAPE_N/2);
    for (let x=1;x<SHAPE_N-1;x++) c[idxS(x,mid)] = 1;
    for (let y=1;y<SHAPE_N-1;y++) c[idxS(mid,y)] = 1;
  }
  return c;
}

function matchKeyToPattern(keyCells, patternCells){
  let fill=0, spill=0, mass=0;
  for (let i=0;i<SHAPE_C;i++){
    const p = patternCells[i];
    const k = keyCells[i];
    if (p) mass++;
    if (k){
      if (p) fill++;
      else spill++;
    }
  }
  const score = (fill - 1.25*spill) / (mass + 1e-6);
  const good = clamp01((score + 1) / 2);
  const bad  = clamp01((-score));
  return {fill, spill, mass, score, good, bad};
}

function initShapes(){
  SHAPES = [];
  COMMON = [];

  const mid = Math.floor(SHAPE_N/2);
  const blank = () => new Array(SHAPE_C).fill(0);
  const set = (c,x,y) => { if (x>=0&&x<SHAPE_N&&y>=0&&y<SHAPE_N) c[idxS(x,y)] = 1; };

  // plus
  {
    const c = blank();
    for (let x=1;x<SHAPE_N-1;x++) set(c,x,mid);
    for (let y=1;y<SHAPE_N-1;y++) set(c,mid,y);
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"plus", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }
  // ring
  {
    const c = blank();
    for (let x=1;x<SHAPE_N-1;x++){ set(c,x,1); set(c,x,SHAPE_N-2); }
    for (let y=1;y<SHAPE_N-1;y++){ set(c,1,y); set(c,SHAPE_N-2,y); }
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"ring", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }
  // diag
  {
    const c = blank();
    for (let i=1;i<SHAPE_N-1;i++) set(c,i,i);
    set(c,mid,mid-1); set(c,mid-1,mid);
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"diag", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }
  // L
  {
    const c = blank();
    for (let y=1;y<SHAPE_N-1;y++) set(c,1,y);
    for (let x=1;x<SHAPE_N-1;x++) set(c,x,SHAPE_N-2);
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"L", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }
  // blob
  {
    const c = blank();
    for (let y=2;y<=4;y++) for (let x=2;x<=4;x++) set(c,x,y);
    set(c,1,3); set(c,5,3); set(c,3,1); set(c,3,5);
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"blob", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }

  for (let i=0;i<10;i++){
    const rc = randomShape(0.20 + 0.10*Math.random(), 2);
    SHAPES.push({name:"rand"+i, cells:rc, mass:shapeMass(rc)});
  }
}

function makeKey(shapeId){
  return {
    keyId: nextKeyId++,
    shapeId,
    cells: SHAPES[shapeId].cells,
    uses: 0,
    createdAt: simTime
  };
}
function agentHasShape(agent, shapeId){
  return agent.keys.some(k => k.shapeId === shapeId);
}
function ensureStorage(agent){
  const cap = parseInt(UI.sKCap.value);
  while (agent.keys.length > cap){
    agent.keys.sort((a,b) => (a.uses - b.uses) || (a.createdAt - b.createdAt));
    agent.keys.shift();
  }
}

function createAgent(x,y){
  const a = {
    id: Math.random().toString(36).slice(2, 8),
    x, y, vx:0, vy:0,
    energy: 0.65 + 0.25*Math.random(),
    maxEnergy: 1.50,
    keys: [],
    memory: new Map(),      // voidId -> {obs:[]}
    pulse: 0,

    mode: null,             // "solve" or "harvest"
    targetType: null,       // "void"|"energy"|null
    targetId: null,
    lockUntil: 0,
    lastScore: 0,
  };

  const kCommon = 3;
  for (let i=0;i<kCommon;i++){
    const sid = COMMON[Math.floor(Math.random()*COMMON.length)];
    if (!agentHasShape(a, sid)) a.keys.push(makeKey(sid));
  }
  const sidR = Math.floor(COMMON.length + Math.random()*(SHAPES.length-COMMON.length));
  a.keys.push(makeKey(sidR));
  ensureStorage(a);

  a.mode = (a.energy < parseFloat(UI.sELow.value)) ? "harvest" : "solve";
  return a;
}

function resetAll(){
  paused = false;
  simTime = 0;
  UI.btnPause.textContent = "Pause";

  nextVoidId = 1;
  nextKeyId = 1;
  nextEnergyId = 1;
  voids = [];
  energySources = [];
  signals = [];
  trails.clear();

  selection = { type: null, id: null };

  initShapes();

  agents = [];
  const n = parseInt(UI.sAgents.value);
  for (let i=0;i<n;i++) agents.push(createAgent(Math.random(), Math.random()));

  refreshInspector();
}

function spawnVoid(){
  const maxV = parseInt(UI.sVoidMax.value);
  if (voids.length >= maxV) return;

  const rarity = clamp01(Math.random()*Math.random());
  const complex = (rarity > 0.65 && Math.random() < 0.6) ? 2 : 1;

  const subCount = complex + (Math.random()<0.25 ? 1 : 0);
  let merged = new Int8Array(SHAPE_C);
  const subs = [];
  for (let i=0;i<subCount;i++){
    const shapeId = (rarity < 0.45)
      ? COMMON[Math.floor(Math.random()*COMMON.length)]
      : Math.floor(Math.random()*SHAPES.length);
    const cells = cloneCells(SHAPES[shapeId].cells);
    subs.push({shapeId, cells});
    merged = shapeOR(merged, cells);
  }

  const baseR = 0.030 + 0.018*complex;
  const r = baseR * (0.8 + 0.8*Math.random());

  const v = {
    id: nextVoidId++,
    x: Math.random(),
    y: Math.random(),
    r,
    rarity,
    complex,
    subs,
    cells: merged,
    mass0: Math.max(1, shapeMass(merged)),
    age: 0
  };
  voids.push(v);
}

function spawnEnergy(){
  const maxE = parseInt(UI.sEMax.value);
  if (energySources.length >= maxE) return;

  const rare = Math.random() < 0.25;
  const shapeId = rare
    ? Math.floor(Math.random()*SHAPES.length)
    : COMMON[Math.floor(Math.random()*COMMON.length)];

  const amount = 0.55 + 0.65*Math.random();
  const r = 0.028 + 0.020*(rare ? 1 : 0) + 0.010*Math.random();

  energySources.push({
    id: nextEnergyId++,
    x: Math.random(),
    y: Math.random(),
    r,
    shapeId,
    cells: SHAPES[shapeId].cells,
    amount0: amount,
    amount: amount,
    age: 0
  });
}

function growVoid(v, dt){
  const g = parseFloat(UI.sVoidGrow.value);
  v.age += dt;
  if (Math.random() < g*dt*(0.25 + 0.8*v.rarity)){
    const sid = (Math.random()<0.7) ? v.subs[Math.floor(Math.random()*v.subs.length)].shapeId : Math.floor(Math.random()*SHAPES.length);
    const src = SHAPES[sid].cells;
    const i = Math.floor(Math.random()*SHAPE_C);
    if (src[i]) v.cells[i] = 1;
  }
}

function bestKey(agent, patternCells){
  let best = null;
  for (const k of agent.keys){
    const m = matchKeyToPattern(k.cells, patternCells);
    if (!best || m.score > best.m.score) best = {k, m};
  }
  return best;
}

function applyKeyToVoid(v, key, dt, agentSpend){
  const m = matchKeyToPattern(key.cells, v.cells);
  const areaB = shapeMass(v.cells);
  if (areaB <= 0) return {areaB, areaA: 0, m, spend:0};

  const spend = agentSpend * dt * (0.35 + 1.2*(1-m.good) + 0.9*m.bad);
  key.uses++;

  const p = clamp01((0.10 + 0.85*m.good) * spend * 2.8);

  const newCells = cloneCells(v.cells);
  for (let i=0;i<SHAPE_C;i++){
    if (v.cells[i] && key.cells[i]){
      if (Math.random() < p) newCells[i] = 0;
    }
  }

  const worsenChance = clamp01(0.12*m.bad + 0.02*(m.spill/(m.mass+1e-6)));
  if (Math.random() < worsenChance * dt * 2.0){
    const sid = (Math.random()<0.5) ? COMMON[Math.floor(Math.random()*COMMON.length)] : Math.floor(Math.random()*SHAPES.length);
    const src = SHAPES[sid].cells;
    for (let k2=0;k2<2;k2++){
      const i = Math.floor(Math.random()*SHAPE_C);
      if (src[i]) newCells[i] = 1;
    }
  }

  v.cells = newCells;
  const areaA = shapeMass(v.cells);
  return {areaB, areaA, m, spend};
}

function harvestEnergy(e, key, dt){
  const m = matchKeyToPattern(key.cells, e.cells);
  const rate = parseFloat(UI.sHarvest.value);
  const take = Math.min(e.amount, rate * dt * (0.10 + 1.1*m.good));
  e.amount -= take;
  key.uses++;
  return {take, m};
}

function maybeCompose(agent, v){
  if (UI.selCompose.value !== "on") return false;
  if (agent.keys.length < 2) return false;

  const composeCost = parseFloat(UI.sComposeCost.value);
  if (agent.energy < composeCost) return false;

  const scored = agent.keys.map(k => ({k, m: matchKeyToPattern(k.cells, v.cells)}));
  scored.sort((a,b) => b.m.score - a.m.score);
  const a = scored[0], b = scored[1];
  if (!a || !b) return false;

  if (a.m.good > 0.70) return false;

  const combined = shapeOR(a.k.cells, b.k.cells);
  const sid = SHAPES.length;
  SHAPES.push({name:"combo("+a.k.shapeId+"|"+b.k.shapeId+")", cells: combined, mass: shapeMass(combined)});

  agent.keys.push(makeKey(sid));
  agent.energy = Math.max(0, agent.energy - composeCost);

  ensureStorage(agent);
  return true;
}

function emitSignal(agent, v, key, areaB, areaA){
  if (!UI.chkSignals.checked) return;
  const delta = areaB - areaA;
  signals.push({
    x: v.x, y: v.y,
    t: 0,
    ttl: 6.5,
    payload: {
      voidId: v.id,
      areaB,
      keyId: key.keyId,
      shapeId: key.shapeId,
      areaA,
      delta
    }
  });
  agent.pulse = 0.25;
}

function absorbSignals(agent){
  const hearR = 0.18;
  const copyCost = 0.22;

  for (const s of signals){
    const tv = torusVec(agent.x, agent.y, s.x, s.y);
    if (tv.d > hearR) continue;

    const p = s.payload;
    if (!agent.memory.has(p.voidId)) agent.memory.set(p.voidId, {obs:[]});
    const rec = agent.memory.get(p.voidId);
    rec.obs.push({keyId:p.keyId, shapeId:p.shapeId, areaB:p.areaB, areaA:p.areaA, delta:p.delta});

    const helpful = p.delta > 0;
    const desire = helpful ? 0.85 : 0.20;
    if (!agentHasShape(agent, p.shapeId) && Math.random() < desire){
      if (agent.energy >= copyCost){
        agent.keys.push(makeKey(p.shapeId));
        agent.energy -= copyCost;
        ensureStorage(agent);
      }
    }
  }

  for (const [vid, rec] of agent.memory.entries()){
    if (rec.obs.length > 24) rec.obs.splice(0, rec.obs.length - 24);
  }
}

// --- Targeting + movement stabilization ---

function getVoidById(id){ for (const v of voids) if (v.id === id) return v; return null; }
function getEnergyById(id){ for (const e of energySources) if (e.id === id) return e; return null; }
function getAgentById(id){ for (const a of agents) if (a.id === id) return a; return null; }

function scoreVoid(agent, v, sight){
  const tv = torusVec(agent.x, agent.y, v.x, v.y);
  if (tv.d > sight) return null;
  const kb = bestKey(agent, v.cells);
  const area = shapeMass(v.cells);
  const good = kb ? kb.m.good : 0;
  const score = (0.3 + area/v.mass0) * (0.25 + good) * (0.6 + 0.6*v.rarity) / (0.04 + tv.d);
  return {score, tv, kb, area};
}
function scoreEnergy(agent, e, sight){
  const tv = torusVec(agent.x, agent.y, e.x, e.y);
  if (tv.d > sight) return null;
  const kb = bestKey(agent, e.cells);
  const good = kb ? kb.m.good : 0;
  const score = (0.25 + e.amount) * (0.25 + good) / (0.04 + tv.d);
  return {score, tv, kb};
}

function chooseBestTarget(agent, type, sight){
  if (type === "void"){
    let best=null;
    for (const v of voids){
      const s = scoreVoid(agent, v, sight);
      if (!s) continue;
      if (!best || s.score > best.score) best = {type:"void", id:v.id, obj:v, score:s.score};
    }
    return best;
  }
  if (type === "energy"){
    let best=null;
    for (const e of energySources){
      const s = scoreEnergy(agent, e, sight);
      if (!s) continue;
      if (!best || s.score > best.score) best = {type:"energy", id:e.id, obj:e, score:s.score};
    }
    return best;
  }
  return null;
}

function updateAgentMode(agent){
  const low = parseFloat(UI.sELow.value);
  const high = parseFloat(UI.sEHigh.value);

  const lo = Math.min(low, high - 0.01);
  const hi = Math.max(high, low + 0.01);

  if (agent.mode === "solve" && agent.energy < lo) agent.mode = "harvest";
  else if (agent.mode === "harvest" && agent.energy > hi) agent.mode = "solve";
  else if (!agent.mode) agent.mode = (agent.energy < lo) ? "harvest" : "solve";
}

function validateTarget(agent){
  if (!agent.targetType || agent.targetId == null) return null;
  if (agent.targetType === "void") return getVoidById(agent.targetId);
  if (agent.targetType === "energy") return getEnergyById(agent.targetId);
  return null;
}

function retargetIfNeeded(agent, sight){
  updateAgentMode(agent);

  const commit = parseFloat(UI.sCommit.value);
  const margin = parseFloat(UI.sMargin.value);

  const curObj = validateTarget(agent);
  if (!curObj){
    agent.targetType = null;
    agent.targetId = null;
    agent.lastScore = 0;
    agent.lockUntil = 0;
  }

  if (!agent.targetType){
    const desiredType = (agent.mode === "harvest") ? "energy" : "void";
    const best = chooseBestTarget(agent, desiredType, sight);
    if (best){
      agent.targetType = best.type;
      agent.targetId = best.id;
      agent.lastScore = best.score;
      agent.lockUntil = simTime + commit;
    }
    return;
  }

  const critical = agent.energy < 0.12;
  if (!critical && simTime < agent.lockUntil) return;

  const desiredType = (agent.mode === "harvest") ? "energy" : "void";

  if (agent.targetType !== desiredType){
    const best = chooseBestTarget(agent, desiredType, sight);
    if (best){
      agent.targetType = best.type;
      agent.targetId = best.id;
      agent.lastScore = best.score;
      agent.lockUntil = simTime + commit;
    }
    return;
  }

  const best = chooseBestTarget(agent, desiredType, sight);
  if (!best) return;
  const curScore = agent.lastScore || 0;
  if (best.id !== agent.targetId && best.score > curScore * margin){
    agent.targetType = best.type;
    agent.targetId = best.id;
    agent.lastScore = best.score;
    agent.lockUntil = simTime + commit;
  } else {
    const cur = validateTarget(agent);
    if (cur){
      if (agent.targetType === "void"){
        const s = scoreVoid(agent, cur, sight);
        if (s) agent.lastScore = s.score;
      } else {
        const s = scoreEnergy(agent, cur, sight);
        if (s) agent.lastScore = s.score;
      }
    }
  }
}

function steerAgent(agent, target){
  const accel = 1.6;
  const maxV  = 0.35;
  const damp  = 0.88;

  let dirx=0, diry=0;
  if (target){
    const tv = torusVec(agent.x, agent.y, target.x, target.y);
    const d = tv.d || 1e-6;
    dirx = tv.dx/d; diry = tv.dy/d;

    const r = target.r || 0.03;
    const close = clamp01((d - 0.15*r) / (0.85*r + 1e-6));
    dirx *= close; diry *= close;
  } else {
    const ang = Math.random()*Math.PI*2;
    dirx = Math.cos(ang); diry = Math.sin(ang);
  }

  dirx += 0.12*randn();
  diry += 0.12*randn();
  const g = Math.hypot(dirx,diry) || 1e-6;
  dirx/=g; diry/=g;

  agent.vx += dirx * accel * dtSim;
  agent.vy += diry * accel * dtSim;

  const dd = Math.pow(damp, dtSim);
  agent.vx *= dd;
  agent.vy *= dd;

  const sp = Math.hypot(agent.vx, agent.vy);
  if (sp > maxV){
    const s = maxV / sp;
    agent.vx *= s; agent.vy *= s;
  }

  agent.x = wrap01(agent.x + agent.vx * dtSim);
  agent.y = wrap01(agent.y + agent.vy * dtSim);
}

// --- selection / inspection helpers ---

function setSelection(type, id){
  selection.type = type;
  selection.id = id;
  refreshInspector();
}

function cellsToAscii(cells){
  let out = "";
  for (let y=0;y<SHAPE_N;y++){
    for (let x=0;x<SHAPE_N;x++){
      out += cells[idxS(x,y)] ? "‚ñà" : "¬∑";
    }
    out += "\n";
  }
  return out;
}

function recentSignalsForVoid(voidId, maxN=6){
  const xs = signals.filter(s => s.payload && s.payload.voidId === voidId);
  xs.sort((a,b)=> (b.t - a.t)); // newest ~ lowest t? Actually t increases; invert to show most recent first:
  // Better: sort by remaining ttl (smaller t means newer). So:
  xs.sort((a,b)=> (a.t - b.t));
  return xs.slice(0, maxN).map(s => s.payload);
}

function topAgentsForPattern(patternCells, topN=5){
  const scored = agents.map(a => {
    const kb = bestKey(a, patternCells);
    return { a, kb };
  }).filter(x => x.kb != null);
  scored.sort((x,y)=> y.kb.m.score - x.kb.m.score);
  return scored.slice(0, topN);
}

function refreshInspector(){
  const el = document.getElementById("inspectContent");
  if (!el) return;

  if (!selection.type){
    el.innerHTML = `<div class="tiny">Nothing selected.</div>`;
    return;
  }

  if (selection.type === "agent"){
    const a = getAgentById(selection.id);
    if (!a){
      el.innerHTML = `<div class="tiny warn">Selected agent no longer exists.</div>`;
      selection.type = null; selection.id = null;
      return;
    }

    const target = validateTarget(a);
    const lockLeft = Math.max(0, a.lockUntil - simTime);

    // if another object selected, we compute match scores; but here selection is agent, so optionally compute
    // match scores to *current target*, if any:
    let matchInfo = "";
    if (target){
      const pattern = (a.targetType === "void") ? target.cells : target.cells;
      const kb = bestKey(a, pattern);
      if (kb){
        matchInfo = `
          <div style="margin-top:8px">
            <div class="pill">Best key vs current target</div>
            <div class="kv" style="margin-top:6px">
              <div>shapeId</div><div>${kb.k.shapeId} <span class="tiny">(${SHAPES[kb.k.shapeId]?.name ?? "?"})</span></div>
              <div>score</div><div>${kb.m.score.toFixed(3)} | good=${kb.m.good.toFixed(2)} | spill=${kb.m.spill}</div>
            </div>
          </div>
        `;
      }
    }

    // keys list
    const keysHtml = a.keys
      .slice()
      .sort((x,y)=> y.uses - x.uses)
      .map(k => {
        const nm = SHAPES[k.shapeId]?.name ?? "?";
        return `<div class="tiny mono">keyId=${k.keyId} shapeId=${k.shapeId} (${nm}) uses=${k.uses}</div>`;
      }).join("");

    el.innerHTML = `
      <div class="pill">Agent</div> <span class="mono">#${a.id}</span>
      <div class="kv" style="margin-top:8px">
        <div>mode</div><div><span class="pill">${a.mode ?? "?"}</span></div>
        <div>energy</div><div>${a.energy.toFixed(2)} / ${a.maxEnergy.toFixed(2)}</div>
        <div>target</div><div>${a.targetType ? `${a.targetType} #${a.targetId}` : "none"}</div>
        <div>commit left</div><div>${lockLeft.toFixed(2)}s</div>
        <div>lastScore</div><div>${(a.lastScore ?? 0).toFixed(3)}</div>
        <div>keys</div><div>${a.keys.length} (cap ${parseInt(UI.sKCap.value)})</div>
      </div>
      ${matchInfo}
      <details style="margin-top:10px" open>
        <summary class="tiny">Keys (sorted by uses)</summary>
        <div style="margin-top:8px">${keysHtml || `<div class="tiny warn">No keys.</div>`}</div>
      </details>
      <details style="margin-top:10px">
        <summary class="tiny">Memory (void observations)</summary>
        <div style="margin-top:8px" class="tiny">
          ${a.memory.size ? `Known voids: ${a.memory.size}` : `No stored observations yet.`}
        </div>
      </details>
    `;
    return;
  }

  if (selection.type === "void"){
    const v = getVoidById(selection.id);
    if (!v){
      el.innerHTML = `<div class="tiny warn">Selected void no longer exists (solved or removed).</div>`;
      selection.type = null; selection.id = null;
      return;
    }

    const area = shapeMass(v.cells);
    const pct = 100 * area / (v.mass0 + 1e-6);

    const subs = v.subs.map(s => {
      const nm = SHAPES[s.shapeId]?.name ?? "?";
      return `<div class="tiny mono">shapeId=${s.shapeId} (${nm})</div>`;
    }).join("");

    const top = topAgentsForPattern(v.cells, 6);
    const topHtml = top.map(t => {
      const nm = SHAPES[t.kb.k.shapeId]?.name ?? "?";
      const score = t.kb.m.score;
      const cls = score > 0.25 ? "good" : (score < -0.25 ? "bad" : "");
      return `<div class="tiny mono ${cls}">agent #${t.a.id}: best shapeId=${t.kb.k.shapeId} (${nm}) score=${score.toFixed(3)} good=${t.kb.m.good.toFixed(2)}</div>`;
    }).join("");

    const sigs = recentSignalsForVoid(v.id, 6);
    const sigHtml = sigs.map(p => {
      const nm = SHAPES[p.shapeId]?.name ?? "?";
      const cls = (p.delta > 0) ? "good" : (p.delta < 0 ? "bad" : "");
      return `<div class="tiny mono ${cls}">shapeId=${p.shapeId} (${nm}) area: ${p.areaB} ‚Üí ${p.areaA} (Œî=${p.delta})</div>`;
    }).join("");

    el.innerHTML = `
      <div class="pill">Void (Lock)</div> <span class="mono">#${v.id}</span>
      <div class="kv" style="margin-top:8px">
        <div>rarity</div><div>${v.rarity.toFixed(2)} <span class="tiny">(higher = rarer lock type)</span></div>
        <div>complex</div><div>${v.complex}</div>
        <div>radius</div><div>${v.r.toFixed(3)}</div>
        <div>age</div><div>${v.age.toFixed(1)}s</div>
        <div>area</div><div>${area} / ${v.mass0} <span class="${pct<=20 ? "good" : ""}">(${pct.toFixed(1)}%)</span></div>
      </div>

      <details style="margin-top:10px" open>
        <summary class="tiny">Pattern (7√ó7 remaining void cells)</summary>
        <pre style="margin-top:8px">${cellsToAscii(v.cells)}</pre>
      </details>

      <details style="margin-top:10px">
        <summary class="tiny">Sub-void components</summary>
        <div style="margin-top:8px">${subs || `<div class="tiny warn">No subs.</div>`}</div>
      </details>

      <details style="margin-top:10px" open>
        <summary class="tiny">Top matching agents (best key score)</summary>
        <div style="margin-top:8px">${topHtml || `<div class="tiny warn">No agents.</div>`}</div>
      </details>

      <details style="margin-top:10px">
        <summary class="tiny">Recent signals (attempts on this void)</summary>
        <div style="margin-top:8px">${sigHtml || `<div class="tiny">No signals seen yet.</div>`}</div>
      </details>
    `;
    return;
  }

  if (selection.type === "energy"){
    const e = getEnergyById(selection.id);
    if (!e){
      el.innerHTML = `<div class="tiny warn">Selected energy source no longer exists (depleted).</div>`;
      selection.type = null; selection.id = null;
      return;
    }
    const nm = SHAPES[e.shapeId]?.name ?? "?";
    const pct = 100 * e.amount / (e.amount0 + 1e-6);

    const top = topAgentsForPattern(e.cells, 6);
    const topHtml = top.map(t => {
      const nm2 = SHAPES[t.kb.k.shapeId]?.name ?? "?";
      const score = t.kb.m.score;
      const cls = score > 0.25 ? "good" : (score < -0.25 ? "bad" : "");
      return `<div class="tiny mono ${cls}">agent #${t.a.id}: best shapeId=${t.kb.k.shapeId} (${nm2}) score=${score.toFixed(3)} good=${t.kb.m.good.toFixed(2)}</div>`;
    }).join("");

    el.innerHTML = `
      <div class="pill">Energy Source</div> <span class="mono">#${e.id}</span>
      <div class="kv" style="margin-top:8px">
        <div>shape</div><div>${e.shapeId} <span class="tiny">(${nm})</span></div>
        <div>radius</div><div>${e.r.toFixed(3)}</div>
        <div>amount</div><div>${e.amount.toFixed(2)} / ${e.amount0.toFixed(2)} <span class="${pct<25 ? "warn" : ""}">(${pct.toFixed(1)}%)</span></div>
        <div>age</div><div>${e.age.toFixed(1)}s</div>
      </div>

      <details style="margin-top:10px" open>
        <summary class="tiny">Pattern (7√ó7)</summary>
        <pre style="margin-top:8px">${cellsToAscii(e.cells)}</pre>
      </details>

      <details style="margin-top:10px" open>
        <summary class="tiny">Top matching agents (best key score)</summary>
        <div style="margin-top:8px">${topHtml || `<div class="tiny warn">No agents.</div>`}</div>
      </details>
    `;
    return;
  }

  el.innerHTML = `<div class="tiny">Unknown selection.</div>`;
}

// --- main sim ---

function updateSim(dt){
  dtSim = dt;
  simTime += dt;

  // spawns
  const vRate = parseFloat(UI.sVoidRate.value)/60;
  const eRate = parseFloat(UI.sERate.value)/60;
  if (Math.random() < vRate*dt) spawnVoid();
  if (Math.random() < eRate*dt) spawnEnergy();

  // update growth/aging
  for (const v of voids) growVoid(v, dt);
  for (const e of energySources) e.age += dt;
  energySources = energySources.filter(e => e.amount > 0.01);

  // update signals
  for (const s of signals) s.t += dt;
  signals = signals.filter(s => s.t < s.ttl);

  // agents
  const spend = parseFloat(UI.sSpend.value);
  const sight = 0.26;
  for (const a of agents){
    absorbSignals(a);

    retargetIfNeeded(a, sight);

    const target = validateTarget(a);
    steerAgent(a, target);

    if (target && a.targetType === "energy"){
      const tv = torusVec(a.x, a.y, target.x, target.y);
      if (tv.d < target.r){
        const kb = bestKey(a, target.cells);
        if (kb){
          const {take} = harvestEnergy(target, kb.k, dt);
          a.energy = Math.min(a.maxEnergy, a.energy + take);
        }
      }
    }

    if (target && a.targetType === "void"){
      const v = target;
      const tv = torusVec(a.x, a.y, v.x, v.y);
      if (tv.d < v.r && a.energy > 0.02){
        const kb = bestKey(a, v.cells);
        if (kb){
          const agentSpend = Math.min(a.energy, spend);
          const res = applyKeyToVoid(v, kb.k, dt, agentSpend);
          a.energy = Math.max(0, a.energy - (res.spend ?? 0));
          emitSignal(a, v, kb.k, res.areaB, res.areaA);

          const improved = (res.areaB - res.areaA) >= 1;
          if (!improved && a.energy > 0.2) maybeCompose(a, v);
        }
      }
    }

    // trails + pulse decay
    if (UI.chkTrails.checked){
      trails.noStroke();
      trails.fill(235,235,255,28);
      trails.circle(a.x*W, a.y*H, 2.2);
    }
    a.pulse = Math.max(0, a.pulse - dt);
  }

  // solve threshold (done once per frame)
  const thrPct = parseFloat(UI.sSolveThr.value)/100;
  voids = voids.filter(v => (shapeMass(v.cells) / (v.mass0+1e-6)) > thrPct);

  // selection validity check
  if (selection.type === "void" && selection.id != null && !getVoidById(selection.id)){
    selection.type = null; selection.id = null; refreshInspector();
  }
  if (selection.type === "energy" && selection.id != null && !getEnergyById(selection.id)){
    selection.type = null; selection.id = null; refreshInspector();
  }
  if (selection.type === "agent" && selection.id != null && !getAgentById(selection.id)){
    selection.type = null; selection.id = null; refreshInspector();
  }

  // gentle trail fade
  if (UI.chkTrails.checked){
    trails.push();
    trails.erase(12,12);
    trails.rect(0,0,W,H);
    trails.noErase();
    trails.pop();
  }

  // cap counts
  const maxV = parseInt(UI.sVoidMax.value);
  if (voids.length > maxV) voids.length = maxV;
  const maxE = parseInt(UI.sEMax.value);
  if (energySources.length > maxE) energySources.length = maxE;
}

// --- Rendering ---

function drawPatternStamp(x, y, rPx, cells, rgb, alpha=140){
  const stamp = rPx*2;
  const cell = stamp / SHAPE_N;
  const ox = x - stamp/2;
  const oy = y - stamp/2;

  noStroke();
  for (let yy=0; yy<SHAPE_N; yy++){
    for (let xx=0; xx<SHAPE_N; xx++){
      const i = idxS(xx,yy);
      if (!cells[i]) continue;
      fill(rgb[0], rgb[1], rgb[2], alpha);
      rect(ox + xx*cell, oy + yy*cell, cell*0.92, cell*0.92, 2);
    }
  }
}

function drawSelectionRing(px, py, rPx){
  noFill();
  stroke(255, 255, 255, 230);
  strokeWeight(2);
  circle(px, py, Math.max(18, rPx*2.4));
}

function draw(){
  background(12,14,18);

  const speed = parseFloat(UI.sSpeed.value);
  const dt = (deltaTime/1000) * speed;

  if (!paused) updateSim(dt);

  if (UI.chkTrails.checked) image(trails, 0,0);

  // energy sources
  for (const e of energySources){
    const px = e.x*W, py = e.y*H;
    const rPx = e.r*Math.min(W,H);
    const a = 60 + 180*(e.amount/(e.amount0+1e-6));
    drawPatternStamp(px, py, rPx, e.cells, [120,255,140], 95);
    noFill();
    stroke(120,255,140,a);
    strokeWeight(2);
    circle(px,py, rPx*2.1);

    if (selection.type === "energy" && selection.id === e.id){
      drawSelectionRing(px, py, rPx);
    }
  }

  // voids
  for (const v of voids){
    const px = v.x*W, py = v.y*H;
    const rPx = v.r*Math.min(W,H);
    const area = shapeMass(v.cells);
    const sev = clamp01(area/(v.mass0+1e-6));
    const a = 70 + 180*sev;

    drawPatternStamp(px, py, rPx, v.cells, [255,110,110], 110);
    noFill();
    stroke(255,110,110,a);
    strokeWeight(2);
    circle(px,py, rPx*(2.0 + 0.9*sev));

    noStroke();
    fill(255,255,255,200);
    textSize(11);
    textAlign(CENTER, CENTER);
    text("#"+v.id, px, py + rPx*1.35);

    if (selection.type === "void" && selection.id === v.id){
      drawSelectionRing(px, py, rPx);
    }
  }

  // signals
  if (UI.chkSignals.checked){
    for (const s of signals){
      const px = s.x*W, py = s.y*H;
      const wave = (s.t*0.9)%1.0;
      const r = (0.02 + 0.14*wave)*Math.min(W,H);
      const a = Math.max(0, 170*(1-wave));

      const delta = s.payload.delta || 0;
      const t = clamp01(delta / 5);
      const R = Math.round(255*(1 - 0.55*t) + 80*(t));
      const G = Math.round(200*(t) + 150*(1-t));
      const B = Math.round(120*(1 - t) + 110*(t));

      noFill();
      stroke(R,G,B,a);
      strokeWeight(1.5);
      circle(px,py,r*2);
    }
  }

  // agents
  for (const a of agents){
    const px = a.x*W, py = a.y*H;

    const t = clamp01(a.energy/(a.maxEnergy+1e-6));
    const rr = 80 + 175*t;
    const gg = 120 + 120*t;
    const bb = 230 - 140*t;

    noStroke();
    fill(rr,gg,bb,245);
    circle(px,py, 7.5);

    if (a.pulse > 0){
      noFill();
      stroke(255,230,120,220*a.pulse/0.25);
      strokeWeight(2);
      circle(px,py, 16 + 24*(1 - a.pulse/0.25));
    }

    noStroke();
    fill(255,255,255,190);
    textSize(10);
    textAlign(CENTER, CENTER);
    const label = (a.mode === "harvest") ? "H" : "S";
    text(label, px, py - 11);

    if (selection.type === "agent" && selection.id === a.id){
      drawSelectionRing(px, py, 10);
    }
  }

  renderMetrics();

  // keep inspector live-updated when something selected
  if (selection.type) {
    // light update cadence to reduce DOM churn
    if (frameCount % 8 === 0) refreshInspector();
  }
}

function renderMetrics(){
  let avgE=0, avgK=0;
  for (const a of agents){ avgE += a.energy; avgK += a.keys.length; }
  avgE = agents.length ? avgE/agents.length : 0;
  avgK = agents.length ? avgK/agents.length : 0;

  const el = document.getElementById("metrics");
  el.innerHTML = `
    <div><b>Agents</b>: ${agents.length} | <b>Voids</b>: ${voids.length} | <b>Energy</b>: ${energySources.length} | <b>Signals</b>: ${signals.length}</div>
    <div><b>Avg energy</b>: ${avgE.toFixed(2)} / 1.50 | <b>Avg keys</b>: ${avgK.toFixed(1)} (cap ${parseInt(UI.sKCap.value)})</div>
    <div class="tiny">Library size: ${SHAPES.length} | time: ${simTime.toFixed(1)} | fps: ${Math.round(frameRate())}</div>
  `;
}

// --- mouse selection: choose nearest visible object (agent / void / energy) ---

function mousePressed(){
  if (mouseX < 0 || mouseX > W || mouseY < 0 || mouseY > H) return;

  let best = null; // {type,id,scorePx}
  const consider = (type, id, scorePx) => {
    if (scorePx == null || !isFinite(scorePx)) return;
    if (!best || scorePx < best.scorePx) best = {type, id, scorePx};
  };

  // Agents: within ~14 px
  for (const a of agents){
    const px = a.x*W, py = a.y*H;
    const d = dist(mouseX, mouseY, px, py);
    if (d <= 14) consider("agent", a.id, d);
  }

  // Voids: within radius ring
  for (const v of voids){
    const px = v.x*W, py = v.y*H;
    const rPx = v.r*Math.min(W,H) * 1.25;
    const d = dist(mouseX, mouseY, px, py);
    if (d <= Math.max(18, rPx)) consider("void", v.id, d);
  }

  // Energy: within radius ring
  for (const e of energySources){
    const px = e.x*W, py = e.y*H;
    const rPx = e.r*Math.min(W,H) * 1.25;
    const d = dist(mouseX, mouseY, px, py);
    if (d <= Math.max(18, rPx)) consider("energy", e.id, d);
  }

  if (best) setSelection(best.type, best.id);
  else setSelection(null, null);
}

// --- setup / UI ---

function setup(){
  W = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
  H = windowHeight;
  createCanvas(W,H);

  trails = createGraphics(W,H);
  trails.clear();

  hookUI();
  resetAll();
  frameRate(60);
}

function windowResized(){
  W = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
  H = windowHeight;
  resizeCanvas(W,H);
  trails = createGraphics(W,H);
  trails.clear();
}

function hookUI(){
  UI.btnPause = document.getElementById("btnPause");
  UI.btnReset = document.getElementById("btnReset");

  UI.sSpeed  = document.getElementById("sSpeed");
  UI.sAgents = document.getElementById("sAgents");
  UI.sKCap   = document.getElementById("sKCap");
  UI.chkTrails = document.getElementById("chkTrails");
  UI.chkSignals = document.getElementById("chkSignals");

  UI.sELow  = document.getElementById("sELow");
  UI.sEHigh = document.getElementById("sEHigh");
  UI.sCommit = document.getElementById("sCommit");
  UI.sMargin = document.getElementById("sMargin");

  UI.sVoidRate = document.getElementById("sVoidRate");
  UI.sVoidMax  = document.getElementById("sVoidMax");
  UI.sVoidGrow = document.getElementById("sVoidGrow");
  UI.sSolveThr = document.getElementById("sSolveThr");

  UI.sERate    = document.getElementById("sERate");
  UI.sEMax     = document.getElementById("sEMax");
  UI.sHarvest  = document.getElementById("sHarvest");
  UI.sSpend    = document.getElementById("sSpend");

  UI.selCompose = document.getElementById("selCompose");
  UI.sComposeCost = document.getElementById("sComposeCost");

  const refresh = ()=>{
    document.getElementById("lblSpeed").textContent = parseFloat(UI.sSpeed.value).toFixed(2);
    document.getElementById("lblAgents").textContent = parseInt(UI.sAgents.value);
    document.getElementById("lblKCap").textContent = parseInt(UI.sKCap.value);

    document.getElementById("lblELow").textContent = parseFloat(UI.sELow.value).toFixed(2);
    document.getElementById("lblEHigh").textContent = parseFloat(UI.sEHigh.value).toFixed(2);
    document.getElementById("lblCommit").textContent = parseFloat(UI.sCommit.value).toFixed(1);
    document.getElementById("lblMargin").textContent = parseFloat(UI.sMargin.value).toFixed(2);

    document.getElementById("lblVoidRate").textContent = parseInt(UI.sVoidRate.value);
    document.getElementById("lblVoidMax").textContent = parseInt(UI.sVoidMax.value);
    document.getElementById("lblVoidGrow").textContent = parseFloat(UI.sVoidGrow.value).toFixed(2);
    document.getElementById("lblSolveThr").textContent = parseInt(UI.sSolveThr.value);

    document.getElementById("lblERate").textContent = parseInt(UI.sERate.value);
    document.getElementById("lblEMax").textContent = parseInt(UI.sEMax.value);
    document.getElementById("lblHarvest").textContent = parseFloat(UI.sHarvest.value).toFixed(2);
    document.getElementById("lblSpend").textContent = parseFloat(UI.sSpend.value).toFixed(2);

    document.getElementById("lblCompose").textContent = UI.selCompose.value === "on" ? "On" : "Off";
    document.getElementById("lblComposeCost").textContent = parseFloat(UI.sComposeCost.value).toFixed(2);

    refreshInspector();
  };
  refresh();

  ["input","change"].forEach(evt=>{
    [
      UI.sSpeed, UI.sAgents, UI.sKCap,
      UI.sELow, UI.sEHigh, UI.sCommit, UI.sMargin,
      UI.sVoidRate, UI.sVoidMax, UI.sVoidGrow, UI.sSolveThr,
      UI.sERate, UI.sEMax, UI.sHarvest, UI.sSpend,
      UI.selCompose, UI.sComposeCost
    ].forEach(el => el.addEventListener(evt, refresh));
  });

  UI.btnPause.addEventListener("click", ()=>{
    paused = !paused;
    UI.btnPause.textContent = paused ? "Resume" : "Pause";
  });
  UI.btnReset.addEventListener("click", ()=>{
    resetAll();
  });

  UI.sAgents.addEventListener("input", ()=>{
    const n = parseInt(UI.sAgents.value);
    agents = [];
    nextKeyId = 1;
    for (let i=0;i<n;i++) agents.push(createAgent(Math.random(), Math.random()));
    refreshInspector();
  });

  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space"){ paused = !paused; UI.btnPause.textContent = paused ? "Resume" : "Pause"; e.preventDefault(); }
    if (e.key.toLowerCase() === "r"){ resetAll(); }
    if (e.key.toLowerCase() === "v"){ spawnVoid(); refreshInspector(); }
    if (e.key.toLowerCase() === "e"){ spawnEnergy(); refreshInspector(); }
  });
}

// randn
let spare = null;
function randn(){
  if (spare !== null){ const v = spare; spare = null; return v; }
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  const mag=Math.sqrt(-2*Math.log(u));
  const z0=mag*Math.cos(TWO_PI*v);
  const z1=mag*Math.sin(TWO_PI*v);
  spare=z1; return z0;
}
</script>

</body>
</html>
