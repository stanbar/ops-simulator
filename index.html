<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>BCM Simulator: Balanced Population</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
        <style>
            :root { --uiw: 320px; }
            html, body { margin: 0; height: 100%; background: #0e0f12; color: #b0b3c0; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
            #ui { position: fixed; top: 0; right: 0; width: var(--uiw); height: 100%; overflow-y: auto; background: #14161b; border-left: 1px solid #1e2230; padding: 15px; box-sizing: border-box; z-index: 10; }
            h2 { margin: 0 0 10px; font-size: 16px; color: #e8eaf1; }
            h3 { margin: 15px 0 5px; font-size: 13px; color: #6fb3ff; text-transform: uppercase; letter-spacing: 1px; }
            .group { background: #1a1d26; padding: 10px; border-radius: 6px; border: 1px solid #252a35; margin-bottom: 10px; }
            label { display: block; font-size: 11px; margin-bottom: 4px; color: #8b9bb4; }
            input[type=range] { width: 100%; margin-bottom: 8px; }
            button { width: 100%; padding: 8px; background: #2a3248; border: 1px solid #3e4a63; color: white; border-radius: 4px; cursor: pointer; margin-top: 5px; }
            button:hover { background: #35415b; }
            .legend-item { display: flex; align-items: center; font-size: 11px; margin-bottom: 4px; }
            .dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; }
            #metrics { position: fixed; left: 15px; top: 15px; background: rgba(20,22,27,0.85); padding: 12px; border-radius: 8px; border: 1px solid #2a3248; font-size: 12px; pointer-events: none; backdrop-filter: blur(4px); color: #fff; }
        </style>
    </head>
    <body>
        <div id="ui">
            <h2>BCM: Dynamic Population</h2>
            
            <div class="group">
                <h3>Population Control</h3>
                <label>Total Agents: <span id="lblAgentCount">30</span></label>
                <input id="sAgentCount" type="range" min="0" max="100" step="1" value="30">
                
                <button id="btnReset">Reset Simulation</button>
                <button id="btnPause">Pause / Resume</button>
            </div>

            <div class="group">
                <h3>Global Entropy</h3>
                <label>External Chaos Rate (Voids)</label>
                <input id="sVoidRate" type="range" min="0" max="0.1" step="0.001" value="0.02">
                <label>Internal Entropy (Boredom Rate)</label>
                <input id="sBoredom" type="range" min="0" max="0.05" step="0.001" value="0.01">
            </div>

            <div class="group">
                <h3>Evolution</h3>
                <label>Adaptation Rate (Learning)</label>
                <input id="sAdapt" type="range" min="0" max="0.5" step="0.01" value="0.1">
                <label>Battery Drain Multiplier</label>
                <input id="sDrain" type="range" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="group">
                <h3>Legend</h3>
                <div class="legend-item"><div class="dot" style="background:#40b0ff"></div>Oi: Certainty/Structure</div>
                <div class="legend-item"><div class="dot" style="background:#ffb040"></div>Oe: Variety/Chaos</div>
                <div class="legend-item"><div class="dot" style="background:#ff4040"></div>Di: Significance/Self</div>
                <div class="legend-item"><div class="dot" style="background:#40ff40"></div>De: Connection/Tribe</div>
                <div style="margin-top:8px; font-size:10px; color:#666;">
                    * Rings = Internal Voids (Needs)<br>
                    * Shapes = Current Solution Mode
                </div>
            </div>
        </div>

        <div id="metrics">Initializing...</div>

        <script>
            // --- CONSTANTS ---
            const NEEDS = ['Oi', 'Oe', 'Di', 'De'];
            const COLORS = {
                Oi: [64, 176, 255], // Blue (Structure)
                Oe: [255, 176, 64], // Orange (Variety)
                Di: [255, 64, 64],  // Red (Significance)
                De: [64, 255, 64]   // Green (Connection)
            };

            // Global Archetype Definitions for Population Balancing
            const ARCHETYPES = [
                { name: 'Oi-Dom', stats: { Oi: 90, Oe: 20, Di: 50, De: 50 } },
                { name: 'Oe-Dom', stats: { Oi: 20, Oe: 90, Di: 50, De: 50 } },
                { name: 'Di-Dom', stats: { Oi: 50, Oe: 50, Di: 90, De: 20 } },
                { name: 'De-Dom', stats: { Oi: 50, Oe: 50, Di: 20, De: 90 } },
            ];
            
            // --- STATE ---
            let agents = [];
            let voids = [];
            let canvasW, canvasH;
            let fieldGraphics;
            let noiseZ = 0;
            
            const SETTINGS = {
                voidRate: 0.02,
                boredomRate: 0.01,
                adaptRate: 0.1,
                drainMult: 1.0,
                // agentCount is now managed by the slider directly
            };

            // --- CLASSES ---
            class Agent {
                constructor(x, y, preset) {
                    this.pos = createVector(x, y);
                    this.vel = createVector(0, 0);
                    this.battery = 100;
                    
                    // 1. The 4 Cognitive Capabilities (0-100)
                    this.stats = { ...preset.stats };
                    this.baseBias = preset.name; // For tracking original type
                    
                    // 2. Internal Voids (Deficits) - 0 to 100
                    this.deficits = { Oi: 0, Oe: 0, Di: 0, De: 0 };
                    
                    // 3. Current State
                    this.mode = 'Neutral'; 
                    this.target = null;
                }

                update() {
                    // Internal Entropy (Boredom/Decay)
                    for (let n of NEEDS) {
                        let decay = (this.stats[n] / 200) * SETTINGS.boredomRate * 10;
                        this.deficits[n] = min(100, this.deficits[n] + decay);
                    }

                    // Battery recharge (slow)
                    if (!this.target) this.battery = min(100, this.battery + 0.2);

                    this.navigate();
                    
                    // Resolve Boundaries
                    this.pos.x = (this.pos.x + canvasW) % canvasW;
                    this.pos.y = (this.pos.y + canvasH) % canvasH;
                }

                navigate() {
                    // Field Drift
                    let n = noise(this.pos.x * 0.003, this.pos.y * 0.003, noiseZ);
                    let angle = n * TWO_PI * 4;
                    let drift = p5.Vector.fromAngle(angle).mult(0.3);
                    this.vel.add(drift);
                    
                    this.findTarget();
                    
                    if (this.target) {
                        let desire = p5.Vector.sub(this.target.pos, this.pos);
                        let d = desire.mag();
                        desire.normalize();
                        
                        if (d < 100) desire.mult(2.0); 
                        else desire.mult(0.8);
                        
                        this.vel.add(desire);
                        
                        if (d < this.target.r + 10) {
                            this.interact(this.target);
                        }
                    }

                    this.vel.limit(2);
                    this.pos.add(this.vel);
                }

                findTarget() {
                    // Priority 1: High Internal Deficit > 80%
                    let biggestDeficit = 0;
                    let urgentNeed = null;
                    for(let n of NEEDS) {
                        if(this.deficits[n] > biggestDeficit) {
                            biggestDeficit = this.deficits[n];
                            urgentNeed = n;
                        }
                    }

                    if (biggestDeficit > 70) {
                        this.target = this.findVoidByType(urgentNeed);
                        return;
                    }

                    // Priority 2: External Voids (Duty)
                    if (this.battery > 40 && !this.target) {
                        let bestVoid = null;
                        let bestScore = -Infinity;
                        
                        for (let v of voids) {
                            let d = dist(this.pos.x, this.pos.y, v.pos.x, v.pos.y);
                            if (d > 300) continue; 
                            
                            let skill = this.stats[v.type];
                            let score = skill / d;
                            if (score > bestScore) {
                                bestScore = score;
                                bestVoid = v;
                            }
                        }
                        this.target = bestVoid;
                    }
                }

                findVoidByType(type) {
                    let closest = null;
                    let minD = Infinity;
                    for (let v of voids) {
                        if (v.type === type) {
                            let d = dist(this.pos.x, this.pos.y, v.pos.x, v.pos.y);
                            if (d < minD) { minD = d; closest = v; }
                        }
                    }
                    return closest;
                }

                interact(v) {
                    if (v.hp <= 0) { this.target = null; return; }

                    this.mode = v.type;
                    let skill = this.stats[v.type]; 
                    let efficiency = map(skill, 0, 100, 0.1, 1.0);
                    let drain = (1.1 - efficiency) * 0.5 * SETTINGS.drainMult;
                    
                    if (this.battery > drain) {
                        v.hp -= efficiency * 2;
                        this.battery -= drain;
                        
                        // Adaptation
                        let xp = (1.1 - efficiency) * SETTINGS.adaptRate;
                        this.stats[v.type] = min(100, this.stats[v.type] + xp);

                        // Satisfaction
                        this.deficits[v.type] = max(0, this.deficits[v.type] - 2);

                        strokeWeight(efficiency * 3);
                        let c = COLORS[v.type];
                        stroke(c[0], c[1], c[2], 150);
                        line(this.pos.x, this.pos.y, v.pos.x, v.pos.y);
                        strokeWeight(1);
                    } else {
                        this.target = null;
                        let flee = p5.Vector.sub(this.pos, v.pos).normalize().mult(5);
                        this.vel.add(flee);
                    }
                }

                draw() {
                    push();
                    translate(this.pos.x, this.pos.y);
                    
                    let hungerColor = [100, 100, 100];
                    let maxDef = 0;
                    for(let n of NEEDS) {
                        if(this.deficits[n] > maxDef) {
                            maxDef = this.deficits[n];
                            hungerColor = COLORS[n];
                        }
                    }
                    
                    fill(lerpColor(color(60), color(hungerColor), maxDef/100));
                    
                    let batCol = lerpColor(color(255, 0, 0), color(0, 255, 0), this.battery/100);
                    stroke(batCol);
                    strokeWeight(2);
                    
                    if (this.baseBias === 'Di-Dom') circle(0,0, 16);
                    else if (this.baseBias === 'De-Dom') rect(-7,-7, 14, 14);
                    else if (this.baseBias === 'Oe-Dom') triangle(0,-9, -8,7, 8,7);
                    else if (this.baseBias === 'Oi-Dom') { rect(-6,-6, 12,12); }

                    noStroke();
                    let yOff = -15;
                    for(let i=0; i<4; i++) {
                        let n = NEEDS[i];
                        let val = this.stats[n];
                        fill(COLORS[n]);
                        rect(-8 + (i*4), yOff, 3, val/20);
                    }

                    pop();
                }
            }

            class Void {
                constructor() {
                    this.pos = createVector(random(canvasW), random(canvasH));
                    this.type = random(NEEDS);
                    this.hp = 100;
                    this.maxHp = 100;
                    this.r = random(20, 40);
                }
                
                update() {
                    if (frameCount % 60 === 0 && this.hp < 200) {
                        this.hp += 1;
                        this.r += 0.1;
                    }
                }

                draw() {
                    push();
                    translate(this.pos.x, this.pos.y);
                    
                    let c = COLORS[this.type];
                    fill(c[0], c[1], c[2], map(this.hp, 0, 200, 50, 200));
                    noStroke();
                    
                    let p = sin(frameCount * 0.05) * 2;
                    
                    if (this.type === 'Oi') rect(-(this.r+p)/2, -(this.r+p)/2, this.r+p, this.r+p);
                    else if (this.type === 'Oe') { 
                        beginShape();
                        for(let i=0; i<5; i++) {
                            let a = TWO_PI * i / 5;
                            vertex(cos(a)*(this.r+p), sin(a)*(this.r+p));
                        }
                        endShape(CLOSE);
                    } 
                    else if (this.type === 'Di') circle(0,0, this.r*2 + p);
                    else if (this.type === 'De') {
                        rect(-(this.r)/4, -this.r, this.r/2, this.r*2);
                        rect(-this.r, -(this.r)/4, this.r*2, this.r/2);
                    }

                    fill(0); rect(-15, -5, 30, 4);
                    fill(255); rect(-15, -5, 30 * (this.hp/this.maxHp), 4);
                    
                    pop();
                }
            }

            // --- SETUP & LOOP ---
            function setup() {
                canvasW = windowWidth - 320;
                canvasH = windowHeight;
                createCanvas(canvasW, canvasH);
                fieldGraphics = createGraphics(canvasW, canvasH);
                
                initUI();
                adjustPopulation(30); // Initial spawn
            }

            function draw() {
                background(18, 20, 26);
                
                drawField();
                image(fieldGraphics, 0, 0);

                if (random() < SETTINGS.voidRate) voids.push(new Void());
                for (let i = voids.length - 1; i >= 0; i--) {
                    voids[i].update();
                    voids[i].draw();
                    if (voids[i].hp <= 0) voids.splice(i, 1);
                }

                resolveCollisions();
                for (let a of agents) {
                    a.update();
                    a.draw();
                }

                noiseZ += 0.005;
                updateMetrics();
            }

            function resolveCollisions() {
                for (let i = 0; i < agents.length; i++) {
                    for (let j = i + 1; j < agents.length; j++) {
                        let a = agents[i], b = agents[j];
                        let d = p5.Vector.dist(a.pos, b.pos);
                        let minDist = 25;
                        if (d < minDist && d > 0) {
                            let push = p5.Vector.sub(a.pos, b.pos).normalize().mult((minDist - d) * 0.5);
                            a.pos.add(push);
                            b.pos.sub(push);
                        }
                    }
                }
            }
            
            function drawField() {
                if(frameCount % 5 !== 0) return;
                fieldGraphics.clear();
                fieldGraphics.noStroke();
                let sz = 40;
                for(let x=0; x<width; x+=sz) {
                    for(let y=0; y<height; y+=sz) {
                        let n = noise(x*0.005, y*0.005, noiseZ);
                        if(n > 0.6) {
                            fieldGraphics.fill(255, 255, 255, (n-0.6)*20);
                            fieldGraphics.rect(x,y,sz,sz);
                        }
                    }
                }
            }

            // --- POPULATION LOGIC ---
            
            function adjustPopulation(targetCount) {
                // ADDING AGENTS
                while (agents.length < targetCount) {
                    // Count current biases
                    let counts = { 'Oi-Dom':0, 'Oe-Dom':0, 'Di-Dom':0, 'De-Dom':0 };
                    agents.forEach(a => counts[a.baseBias]++);
                    
                    // Find least represented archetype
                    let minType = 'Oi-Dom';
                    let minVal = Infinity;
                    for (let k in counts) {
                        if (counts[k] < minVal) { minVal = counts[k]; minType = k; }
                    }
                    
                    // Create new agent of that type
                    let preset = ARCHETYPES.find(p => p.name === minType);
                    agents.push(new Agent(random(width), random(height), preset));
                }

                // REMOVING AGENTS
                while (agents.length > targetCount) {
                    // Count current biases
                    let counts = { 'Oi-Dom':0, 'Oe-Dom':0, 'Di-Dom':0, 'De-Dom':0 };
                    agents.forEach(a => counts[a.baseBias]++);
                    
                    // Find most represented archetype
                    let maxType = 'Oi-Dom';
                    let maxVal = -Infinity;
                    for (let k in counts) {
                        if (counts[k] > maxVal) { maxVal = counts[k]; maxType = k; }
                    }
                    
                    // Find all agents of this type
                    let candidates = agents.map((a, i) => a.baseBias === maxType ? i : -1).filter(i => i !== -1);
                    
                    // Remove a random one of them
                    if (candidates.length > 0) {
                        let rIndex = candidates[floor(random(candidates.length))];
                        agents.splice(rIndex, 1);
                    } else {
                        agents.pop(); // Fallback
                    }
                }
                
                document.getElementById('lblAgentCount').innerText = agents.length;
            }

            function resetSim() {
                agents = [];
                voids = [];
                let t = parseInt(document.getElementById('sAgentCount').value);
                adjustPopulation(t);
            }
            
            function updateMetrics() {
                // Count archetypes
                let counts = { 'Oi-Dom':0, 'Oe-Dom':0, 'Di-Dom':0, 'De-Dom':0 };
                agents.forEach(a => counts[a.baseBias]++);
                
                let html = `
                    <div style="font-weight:bold; margin-bottom:5px;">Population Balance</div>
                    <div style="color:rgb(${COLORS.Oi})">Oi Agents: ${counts['Oi-Dom']}</div>
                    <div style="color:rgb(${COLORS.Oe})">Oe Agents: ${counts['Oe-Dom']}</div>
                    <div style="color:rgb(${COLORS.Di})">Di Agents: ${counts['Di-Dom']}</div>
                    <div style="color:rgb(${COLORS.De})">De Agents: ${counts['De-Dom']}</div>
                    <hr style="border-color:#333">
                    <div>Active Voids: ${voids.length}</div>
                `;
                document.getElementById('metrics').innerHTML = html;
            }

            function initUI() {
                const bind = (id, obj, key) => {
                    document.getElementById(id).addEventListener('input', (e) => obj[key] = parseFloat(e.target.value));
                };
                bind('sVoidRate', SETTINGS, 'voidRate');
                bind('sBoredom', SETTINGS, 'boredomRate');
                bind('sAdapt', SETTINGS, 'adaptRate');
                bind('sDrain', SETTINGS, 'drainMult');
                
                // Agent Slider Logic
                document.getElementById('sAgentCount').addEventListener('input', (e) => {
                    adjustPopulation(parseInt(e.target.value));
                });
                
                document.getElementById('btnReset').onclick = resetSim;
                document.getElementById('btnPause').onclick = () => isLooping() ? noLoop() : loop();
            }

            function windowResized() {
                canvasW = windowWidth - 320;
                canvasH = windowHeight;
                resizeCanvas(canvasW, canvasH);
                fieldGraphics.resizeCanvas(canvasW, canvasH);
            }
        </script>
    </body>
</html>