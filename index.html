<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BCM Spectrum Simulator (p5.js) + Inspector + Vault/Router Modes</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/addons/p5.dom.min.js"></script>
  <style>
    body { margin: 0; background:#0b0f14; color:#e8eef6; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .panel { position: fixed; left: 10px; top: 10px; width: 400px; background: rgba(10,14,20,0.88);
             border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; padding: 12px 12px 10px; backdrop-filter: blur(6px); }
    .row { display:flex; justify-content:space-between; gap:10px; align-items:center; margin: 6px 0; }
    .row label { font-size: 12px; opacity: 0.9; }
    .row .val { font-size: 12px; opacity: 0.85; min-width: 60px; text-align:right; }
    .btns { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
    button { background:#1b2432; color:#e8eef6; border:1px solid rgba(255,255,255,0.12); border-radius:8px; padding:7px 10px; cursor:pointer; }
    button:hover { background:#243247; }
    .hint { font-size: 12px; opacity: 0.8; line-height: 1.3; margin-top: 8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .inspector { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08); }
    .inspector h3 { margin: 0 0 6px 0; font-size: 12px; opacity: 0.9; }
    .inspector pre { margin: 0; font-size: 11px; line-height: 1.25; white-space: pre-wrap; background: rgba(0,0,0,0.25); padding: 8px; border-radius: 8px; border:1px solid rgba(255,255,255,0.06); }
    canvas { display:block; }
  </style>
</head>
<body>
  <div class="panel" id="ui"></div>

<script>
/**
 * BCM Spectrum Simulator v1.5 (p5.js)
 * Patch set:
 * - Adds click INSPECTOR for agents/voids (debug).
 * - Adds agent MODE: "vault" vs "router" (two-tier memory ecology).
 *   Vault: preserves rare keys (bigger key memory, longer TTL, slower decay, less sharing/scanning).
 *   Router: spreads common keys (more scanning/sharing, faster decay, smaller key memory, higher share replication).
 */

/////////////////////////
// 1) Config + helpers //
/////////////////////////

const CFG = {
  arenaSize: 1000,
  initialAgents: 50,
  targetVoids: 25,
  maxPop: 200,

  visionRadius: 120,
  interactRadius: 40,
  blastRadius: 120,

  matchEps: 2,
  orthoBonus: true,

  voidHp: 40,
  voidLifespanMin: 5,
  voidLifespanMax: 15,
  voidRespawnProb: 0.50,

  dailyEnergy: 80,
  energyMax: 160,
  carryoverEnergy: true,
  startEnergy: 100,
  rewardPerHit: 0.5,
  rewardOnSolve: 10,

  maxAgeDays: 100,
  minParentAgeDays: 25,

  keyTTLMax: 12,
  pReplicateInternal: 0.05,
  pReplicateShare: 0.20,

  boredomLimit: 300,

  baseDeath: 0.01,
  kDeath: 0.20,

  ticksPerFrame: 6,
  maxTicksPerDay: 5000,

  maxMem: 60,

  drawTrails: false,
  backgroundFade: 28,

  // telemetry controls
  telemetryBins: 36,
  telemetryMaxEvents: 2500,

  // --- MODE SYSTEM (two-tier memory ecology) ---
  // Initial distribution
  pInitVault: 0.40, // 40% vaults, 60% routers

  // Memory split biases (fraction of memory dedicated to keys)
  vaultMemSplitRange: [0.65, 0.85],
  routerMemSplitRange: [0.25, 0.45],

  // Key persistence
  vaultTTLFactor: 1.8,       // vault key TTL max multiplier
  routerTTLFactor: 0.85,     // router key TTL max multiplier
  vaultDecayRate: 0.60,      // keys lose ttl per day
  routerDecayRate: 1.00,

  // Behavior scaling
  vaultShareScale: 0.55,
  routerShareScale: 1.20,
  vaultScanScale: 0.70,
  routerScanScale: 1.25,

  // Replication scaling
  vaultInternalRepFactor: 2.0, // vaults replicate internally more
  routerShareRepFactor: 2.0,   // routers replicate via share more

  // Solve preference (optional mild tilt)
  vaultSolveScale: 1.05,
  routerSolveScale: 0.95,

  // Mutation rate for mode trait
  pFlipModeChild: 0.06
};

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function wrap(v, max){ v = v % max; if (v < 0) v += max; return v; }
function dist2(ax, ay, bx, by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

function circDist(a, b, mod=360){
  let d = Math.abs(a - b) % mod;
  return Math.min(d, mod - d);
}
function matches(a, b, eps){ return circDist(a, b) <= eps; }

// signed shortest circular difference in [-180, 180]
function circSignedDiff(a, b, mod=360){
  let d = ((a - b) % mod + mod) % mod;
  if (d > mod/2) d -= mod;
  return d;
}

function rollDice(n, d){
  let s = 0;
  for (let i=0;i<n;i++) s += 1 + Math.floor(Math.random()*d);
  return s;
}
function symmetricNoise(n=6, d=5){
  return rollDice(n,d) - rollDice(n,d);
}
function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function randRange(a,b){ return a + Math.random()*(b-a); }

function sampleVoidVal(){
  const diceDivide = (maxVal, divisions) => {
    if (divisions <= 0) return 0;
    const step = maxVal / divisions;
    const k = Math.floor(Math.random()*divisions);
    return Math.floor(k * step);
  };
  const noise = (rollDice(4,5) - rollDice(1,5));
  const val = (
    diceDivide(360, 2) +
    diceDivide(180, 2) +
    diceDivide(90, 2) +
    diceDivide(45, 3) +
    diceDivide(15, 3) +
    noise
  );
  return wrap(val, 360);
}
function sampleAgentValue(){
  const step = 360/8;
  const k = Math.floor(Math.random()*8);
  return Math.floor(k * step);
}

function mean(arr){
  if (!arr.length) return 0;
  return arr.reduce((a,b)=>a+b,0) / arr.length;
}

/////////////////////////////
// 2) Telemetry (high signal)
/////////////////////////////

let telemetry = null;
let dayStats = null;
let dayShareSampleTaken = false;

function snapshotConfig(){
  return {
    arenaSize: CFG.arenaSize,
    initialAgents: CFG.initialAgents,
    targetVoids: CFG.targetVoids,
    maxPop: CFG.maxPop,
    visionRadius: CFG.visionRadius,
    interactRadius: CFG.interactRadius,
    blastRadius: CFG.blastRadius,
    matchEps: CFG.matchEps,
    orthoBonus: CFG.orthoBonus,
    voidHp: CFG.voidHp,
    voidLifespanMin: CFG.voidLifespanMin,
    voidLifespanMax: CFG.voidLifespanMax,
    voidRespawnProb: CFG.voidRespawnProb,
    dailyEnergy: CFG.dailyEnergy,
    energyMax: CFG.energyMax,
    carryoverEnergy: CFG.carryoverEnergy,
    startEnergy: CFG.startEnergy,
    rewardPerHit: CFG.rewardPerHit,
    rewardOnSolve: CFG.rewardOnSolve,
    maxAgeDays: CFG.maxAgeDays,
    minParentAgeDays: CFG.minParentAgeDays,
    keyTTLMax: CFG.keyTTLMax,
    pReplicateInternal: CFG.pReplicateInternal,
    pReplicateShare: CFG.pReplicateShare,
    boredomLimit: CFG.boredomLimit,
    baseDeath: CFG.baseDeath,
    kDeath: CFG.kDeath,
    maxMem: CFG.maxMem,
    telemetryBins: CFG.telemetryBins,

    // mode config snapshot
    pInitVault: CFG.pInitVault,
    vaultMemSplitRange: CFG.vaultMemSplitRange,
    routerMemSplitRange: CFG.routerMemSplitRange,
    vaultTTLFactor: CFG.vaultTTLFactor,
    routerTTLFactor: CFG.routerTTLFactor,
    vaultDecayRate: CFG.vaultDecayRate,
    routerDecayRate: CFG.routerDecayRate,
    vaultShareScale: CFG.vaultShareScale,
    routerShareScale: CFG.routerShareScale,
    vaultScanScale: CFG.vaultScanScale,
    routerScanScale: CFG.routerScanScale,
    vaultInternalRepFactor: CFG.vaultInternalRepFactor,
    routerShareRepFactor: CFG.routerShareRepFactor,
    vaultSolveScale: CFG.vaultSolveScale,
    routerSolveScale: CFG.routerSolveScale,
    pFlipModeChild: CFG.pFlipModeChild
  };
}

function initTelemetry(){
  telemetry = {
    meta: {
      version: "bcm-sim-p5-telemetry-v1.5-mode+inspector",
      startedAtISO: new Date().toISOString()
    },
    configInitial: snapshotConfig(),
    days: [],
    events: []
  };
}

function pushEvent(type, payload){
  if (!telemetry) return;
  telemetry.events.push({
    day: world.day,
    tick: world.tick,
    type,
    payload
  });
  if (telemetry.events.length > CFG.telemetryMaxEvents){
    telemetry.events.splice(0, Math.floor(CFG.telemetryMaxEvents * 0.2));
  }
}

function startDayStats(day){
  dayShareSampleTaken = false;
  dayStats = {
    day,
    ticks: 0,

    popStart: world.agents.length,
    popEnd: world.agents.length,
    voidsStart: world.voids.filter(v=>v.state==="active").length,
    voidsEnd: world.voids.filter(v=>v.state==="active").length,

    actions: { scan:0, share:0, solve:0, gen_solve:0, stockpile:0, sleep:0 },

    births: 0,
    deaths: { explosion:0, age:0 },
    voids: { spawned:0, solved:0, exploded:0, hits:0 },

    keys: { added:0, evicted:0, pruned:0, used:0, replicatedInternal:0, replicatedShare:0 },

    genSolve: { attempts:0, successes:0 },

    share: { total:0, withKey:0, neighborsSum:0 },

    anomalies: {
      voidMapMismatch: 0,
      shareHighSaturation: 0,
      solveLowSaturation: 0,
      genSolveWasteSuspected: false,
      genNoiseBiasSuspected: false
    },

    cleanup: {
      voidMemRemovedMissing: 0,
      voidMemRemovedRecent: 0
    },

    // NEW: mode distribution
    modes: { vault: 0, router: 0 },

    coverage: null,
    entropyProxy: null,
    meanEnergy: null,
    meanKeysPerAgent: null,

    hist: {
      voids: new Array(CFG.telemetryBins).fill(0),
      keys: new Array(CFG.telemetryBins).fill(0),
      tuning: new Array(CFG.telemetryBins).fill(0)
    },

    genNoise: { count:0, sumSigned:0, sumAbs:0 }
  };
}

function computeCoverage(){
  const activeVoids = world.voids.filter(v => v.state === "active");
  if (activeVoids.length === 0) return 1.0;

  let covered = 0;
  for (const v of activeVoids){
    let ok = false;
    for (const a of world.agents){
      for (const k of a.keys){
        if (matches(k.val, v.val, CFG.matchEps)){ ok = true; break; }
      }
      if (ok) break;
    }
    if (ok) covered++;
  }
  return covered / activeVoids.length;
}

function computeEntropyProxy(){
  let ent = 0;
  for (const v of world.voids){
    if (v.state !== "active") continue;
    ent += v.hp * v.urgency();
  }
  return ent;
}

function fillHistograms(){
  const bins = CFG.telemetryBins;
  dayStats.hist.voids.fill(0);
  dayStats.hist.keys.fill(0);
  dayStats.hist.tuning.fill(0);

  for (const v of world.voids){
    if (v.state !== "active") continue;
    const idx = clamp(Math.floor((v.val/360)*bins), 0, bins-1);
    dayStats.hist.voids[idx] += 1;
  }

  for (const a of world.agents){
    const tidx = clamp(Math.floor((a.agentValue/360)*bins), 0, bins-1);
    dayStats.hist.tuning[tidx] += 1;
    for (const k of a.keys){
      const kidx = clamp(Math.floor((k.val/360)*bins), 0, bins-1);
      dayStats.hist.keys[kidx] += 1;
    }
  }
}

function computeVoidMapMismatch(){
  let missingFromMap = 0;
  for (const v of world.voids){
    if (v.state !== "active") continue;
    const vm = world.voidMap.get(v.id);
    if (!vm || vm !== v) missingFromMap++;
  }

  const activeIds = new Set();
  for (const v of world.voids) if (v.state === "active") activeIds.add(v.id);

  let extraInMap = 0;
  for (const [id, v] of world.voidMap.entries()){
    if (!activeIds.has(id)) extraInMap++;
    else if (!v || v.state !== "active") extraInMap++;
  }

  return missingFromMap + extraInMap;
}

function finalizeDayStats(){
  if (!dayStats) return;

  dayStats.popEnd = world.agents.length;
  dayStats.voidsEnd = world.voids.filter(v=>v.state==="active").length;

  // mode counts
  for (const a of world.agents){
    if (a.mode === "vault") dayStats.modes.vault++;
    else dayStats.modes.router++;
  }

  dayStats.coverage = computeCoverage();
  dayStats.entropyProxy = computeEntropyProxy();
  dayStats.meanEnergy = mean(world.agents.map(a => a.energy));
  dayStats.meanKeysPerAgent = mean(world.agents.map(a => a.keys.length));

  fillHistograms();

  dayStats.anomalies.voidMapMismatch = computeVoidMapMismatch();

  if (dayStats.genSolve.attempts >= 200 && dayStats.genSolve.successes === 0){
    dayStats.anomalies.genSolveWasteSuspected = true;
  }

  if (dayStats.genNoise.count >= 50){
    const meanSigned = dayStats.genNoise.sumSigned / dayStats.genNoise.count;
    const meanAbs = dayStats.genNoise.sumAbs / dayStats.genNoise.count;
    if (Math.abs(meanSigned) > Math.max(5, meanAbs * 0.25)){
      dayStats.anomalies.genNoiseBiasSuspected = true;
    }
  }

  telemetry.days.push(dayStats);
  dayStats = null;
}

function downloadTelemetry(){
  if (!telemetry) return;
  telemetry.configCurrent = snapshotConfig();
  telemetry.meta.downloadedAtISO = new Date().toISOString();

  telemetry.meta.live = {
    day: world.day,
    tick: world.tick,
    pop: world.agents.length,
    voids: world.voids.filter(v=>v.state==="active").length,
    coverage: computeCoverage(),
    entropyProxy: computeEntropyProxy()
  };

  const json = JSON.stringify(telemetry, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = `bcm_telemetry_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/////////////////////
// 3) World objects //
/////////////////////

let nextAgentId = 0;
let nextVoidId = 0;

class VoidObj {
  constructor(hp){
    this.id = nextVoidId++;
    this.x = Math.random()*CFG.arenaSize;
    this.y = Math.random()*CFG.arenaSize;
    this.val = sampleVoidVal();
    this.hpMax = hp;
    this.hp = hp;
    this.lifespanMax = randInt(CFG.voidLifespanMin, CFG.voidLifespanMax);
    this.lifespan = this.lifespanMax;
    this.ageDays = 0;
    this.state = "active";
    this.rewardHit = CFG.rewardPerHit;
    this.rewardSolve = CFG.rewardOnSolve;
  }
  urgency(){
    return 300.0 / (this.lifespan + 0.1);
  }
}

class KeyObj {
  constructor(val, creatorId, ttlMaxOverride=null){
    this.val = wrap(Math.round(val), 360);
    this.creatorId = creatorId;
    this.ttlMax = ttlMaxOverride ?? CFG.keyTTLMax;
    this.ttl = this.ttlMax; // float OK
    this.uses = 0;
  }
}

function pickModeInitial(){
  return (Math.random() < CFG.pInitVault) ? "vault" : "router";
}
function flipMode(m){
  return (m === "vault") ? "router" : "vault";
}

class Agent {
  constructor(totalMem, x=null, y=null, parent=null){
    this.id = nextAgentId++;

    this.x = (x === null) ? Math.random()*CFG.arenaSize : x;
    this.y = (y === null) ? Math.random()*CFG.arenaSize : y;
    this.vx = (Math.random()*2 - 1);
    this.vy = (Math.random()*2 - 1);

    this.alive = true;
    this.sleeping = false;
    this.ageDays = 0;

    this.energyMax = CFG.energyMax;
    this.energy = CFG.startEnergy;

    this.boredom = 0;

    this.totalMem = totalMem;
    this.keys = [];
    this.voidMem = []; // {voidId,x,y,val,urgency,lastSeenDay}
    this.consecutiveFailedScouts = 0;

    // --- MODE: vault vs router ---
    if (parent){
      this.mode = parent.mode;
      if (Math.random() < CFG.pFlipModeChild) this.mode = flipMode(this.mode);
    } else {
      this.mode = pickModeInitial();
    }

    if (parent){
      this.agentValue = wrap(parent.agentValue + randInt(-5,5), 360);
      this.costs = parent.costs.map(c => Math.max(0.1, c + (Math.random()*0.2 - 0.1)));

      // Bias memSplit by mode (then mutate slightly)
      let ms = parent.memSplit + (Math.random()*0.10 - 0.05);
      this.memSplit = this.applyModeMemSplit(ms);

      this.weights = {};
      for (const k of Object.keys(parent.weights)){
        this.weights[k] = parent.weights[k] + (Math.random()*0.4 - 0.2);
      }
    } else {
      this.agentValue = sampleAgentValue();
      this.costs = [Math.random(), Math.random(), Math.random(), Math.random()];

      // mode-biased memSplit
      const base = 0.5;
      this.memSplit = this.applyModeMemSplit(base);

      this.weights = {
        wUrgency: 1.0,
        wCost: -2.0,
        wSatShare: -50.0,
        wSatSolve: 20.0,
        wHaveKey: 150.0,
        wScanFail: -5.0
      };
    }

    let s = this.costs.reduce((a,b)=>a+b,0);
    this.costs = this.costs.map(x => x * (8.0 / s));
    this.costScan = this.costs[0];
    this.costGen  = this.costs[1];
    this.costShare= this.costs[2];
    this.costSolve= this.costs[3];

    this.recomputeCaps();

    for (let i=0;i<5;i++) this.stockpileGenerate(true);
  }

  modeTTLMax(){
    const f = (this.mode === "vault") ? CFG.vaultTTLFactor : CFG.routerTTLFactor;
    return Math.max(2, Math.round(CFG.keyTTLMax * f));
  }
  modeDecayRate(){
    return (this.mode === "vault") ? CFG.vaultDecayRate : CFG.routerDecayRate;
  }
  modeShareScale(){
    return (this.mode === "vault") ? CFG.vaultShareScale : CFG.routerShareScale;
  }
  modeScanScale(){
    return (this.mode === "vault") ? CFG.vaultScanScale : CFG.routerScanScale;
  }
  modeSolveScale(){
    return (this.mode === "vault") ? CFG.vaultSolveScale : CFG.routerSolveScale;
  }
  modeInternalRepFactor(){
    return (this.mode === "vault") ? CFG.vaultInternalRepFactor : 1.0;
  }
  modeShareRepFactor(){
    return (this.mode === "router") ? CFG.routerShareRepFactor : 1.0;
  }

  applyModeMemSplit(raw){
    if (this.mode === "vault"){
      return clamp(raw, CFG.vaultMemSplitRange[0], CFG.vaultMemSplitRange[1]);
    } else {
      return clamp(raw, CFG.routerMemSplitRange[0], CFG.routerMemSplitRange[1]);
    }
  }

  recomputeCaps(){
    // enforce mode-biased memSplit whenever caps are recomputed
    this.memSplit = this.applyModeMemSplit(this.memSplit);

    this.maxKeys = Math.floor(this.totalMem * this.memSplit);
    this.maxVoidMem = this.totalMem - this.maxKeys;
    if (this.maxKeys < 1) this.maxKeys = 1;
    if (this.maxVoidMem < 1) this.maxVoidMem = 1;
  }

  memorizeVoid(v, day){
    const urg = v.urgency();

    for (const m of this.voidMem){
      if (m.voidId === v.id){
        m.x = v.x; m.y = v.y;
        m.val = v.val;
        m.urgency = urg;
        m.lastSeenDay = day;
        return true;
      }
    }

    const entry = { voidId: v.id, x:v.x, y:v.y, val:v.val, urgency:urg, lastSeenDay:day };

    if (this.voidMem.length < this.maxVoidMem){
      this.voidMem.push(entry);
      return true;
    }

    this.voidMem.sort((a,b)=>a.urgency - b.urgency);
    if (urg > this.voidMem[0].urgency){
      this.voidMem.shift();
      this.voidMem.push(entry);
      return true;
    }
    return false;
  }

  addKey(key){
    if (this.keys.length < this.maxKeys){
      this.keys.push(key);
      if (dayStats) dayStats.keys.added++;
      return;
    }

    let bestIdx = -1;
    let lowestRetention = Infinity;

    for (let i=0;i<this.keys.length;i++){
      const k = this.keys[i];
      let retention = 0;
      let matchesKnown = false;

      for (const vm of this.voidMem){
        const v = world.voidMap.get(vm.voidId);
        if (!v || v.state !== "active") continue;

        const urg = v.urgency();

        if (matches(k.val, v.val, CFG.matchEps)){
          retention += urg + 1000;
          matchesKnown = true;
        } else if (CFG.orthoBonus && k.creatorId === this.id){
          const v1 = wrap(k.val + 90, 360);
          const v2 = wrap(k.val - 90, 360);
          if (matches(v1, v.val, CFG.matchEps) || matches(v2, v.val, CFG.matchEps)){
            retention += (urg/2) + 500;
            matchesKnown = true;
          }
        }
      }

      if (!matchesKnown) retention = Math.random()*10;
      if (retention < lowestRetention){
        lowestRetention = retention;
        bestIdx = i;
      }
    }

    this.keys.splice(bestIdx, 1);
    this.keys.push(key);

    if (dayStats){
      dayStats.keys.added++;
      dayStats.keys.evicted++;
    }
  }

  refreshKey(index){
    if (index < 0 || index >= this.keys.length) return;
    const k = this.keys.splice(index, 1)[0];
    this.keys.push(k);
  }

  decayKeys(){
    const rate = this.modeDecayRate();
    for (const k of this.keys) k.ttl -= rate;

    const before = this.keys.length;
    this.keys = this.keys.filter(k => k.ttl > 0);
    const pruned = before - this.keys.length;
    if (dayStats) dayStats.keys.pruned += pruned;
  }

  stockpileGenerate(free=false){
    const val = wrap(this.agentValue + symmetricNoise(6,5), 360);
    const ttlMax = this.modeTTLMax();
    this.addKey(new KeyObj(val, this.id, ttlMax));

    if (!free){
      if (dayStats){
        const d = circSignedDiff(val, this.agentValue);
        dayStats.genNoise.count++;
        dayStats.genNoise.sumSigned += d;
        dayStats.genNoise.sumAbs += Math.abs(d);
      }
      this.energy -= this.costGen;
      this.boredom = 0;
    }
  }

  attemptTargetedGenerate(targetVal, urgency){
    const attempt = this.annealAttempt(targetVal, urgency);
    const ok = matches(attempt, targetVal, CFG.matchEps);
    return { ok, val: ok ? targetVal : attempt };
  }

  annealAttempt(targetVal, urgency){
    const fail = this.consecutiveFailedScouts;

    const p = clamp(
      0.35 * (urgency / 60) + 0.08 * (fail / 10),
      0, 1
    );

    let base = this.agentValue;
    if (this.keys.length > 0 && p > 0.45 && Math.random() < p){
      base = this.keys[Math.floor(Math.random()*this.keys.length)].val;
    }

    const k = Math.floor(clamp(p * 3.5, 0, 3));
    const noise = symmetricNoise(6 + 4*k, 5);

    let attempt = wrap(base + noise, 360);
    if (CFG.orthoBonus && p > 0.65 && Math.random() < (p - 0.55)){
      attempt = wrap(attempt + (Math.random() < 0.5 ? 90 : -90), 360);
    }
    return attempt;
  }

  move(){
    if (this.sleeping || !this.alive) return;

    this.boredom += 1;
    if (this.boredom > CFG.boredomLimit){
      this.sleeping = true;
      if (dayStats) dayStats.actions.sleep++;
      return;
    }

    // Clean missing voidIds
    this.voidMem = this.voidMem.filter(m => {
      const v = world.voidMap.get(m.voidId);
      if (!v || v.state !== "active") {
        if (dayStats){
          if ((world.day - m.lastSeenDay) > 1) dayStats.cleanup.voidMemRemovedMissing++;
          else dayStats.cleanup.voidMemRemovedRecent++;
        }
        return false;
      }
      return true;
    });

    let target = null;
    let bestPriority = -Infinity;

    for (const m of this.voidMem){
      const v = world.voidMap.get(m.voidId);
      if (!v || v.state !== "active") continue;

      m.urgency = v.urgency();

      let hasKeyBonus = 1.0;
      for (const k of this.keys){
        if (matches(k.val, v.val, CFG.matchEps)){ hasKeyBonus = 2.0; break; }
      }

      const d = Math.sqrt(dist2(this.x,this.y,v.x,v.y));
      const priority = (m.urgency * hasKeyBonus) + (500 / (d + 5));
      if (priority > bestPriority){
        bestPriority = priority;
        target = v;
      }
    }

    let ax = 0, ay = 0;
    if (target){
      const ang = Math.atan2(target.y - this.y, target.x - this.x);
      ax = Math.cos(ang) * 0.9;
      ay = Math.sin(ang) * 0.9;
    } else {
      ax = (Math.random()*0.6 - 0.3);
      ay = (Math.random()*0.6 - 0.3);
    }

    this.vx = (this.vx + ax) * 0.90;
    this.vy = (this.vy + ay) * 0.90;

    this.x = wrap(this.x + this.vx, CFG.arenaSize);
    this.y = wrap(this.y + this.vy, CFG.arenaSize);
  }

  interact(){
    if (this.sleeping || !this.alive) return;

    const neighbors = [];
    for (const other of world.agents){
      if (other.id === this.id || !other.alive || other.sleeping) continue;
      if (dist2(this.x,this.y,other.x,other.y) <= CFG.interactRadius*CFG.interactRadius) neighbors.push(other);
    }

    for (const m of this.voidMem){
      const v = world.voidMap.get(m.voidId);
      if (v && v.state === "active") m.urgency = v.urgency();
    }

    const candidates = [];

    for (const m of this.voidMem){
      const v = world.voidMap.get(m.voidId);
      if (!v || v.state !== "active") continue;

      let knownCount = 0;
      for (const n of neighbors){
        if (n.voidMem.some(vm => vm.voidId === v.id)) knownCount++;
      }
      const saturation = neighbors.length ? (knownCount / neighbors.length) : 0;

      let keyIdx = -1;
      let isOrtho = false;
      for (let i=0;i<this.keys.length;i++){
        const k = this.keys[i];
        if (matches(k.val, v.val, CFG.matchEps)){ keyIdx = i; break; }
        if (CFG.orthoBonus && k.creatorId === this.id){
          const v1 = wrap(k.val + 90, 360);
          const v2 = wrap(k.val - 90, 360);
          if (matches(v1, v.val, CFG.matchEps) || matches(v2, v.val, CFG.matchEps)){
            keyIdx = i; isOrtho = true; break;
          }
        }
      }
      const hasKey = keyIdx !== -1;

      if (neighbors.length){
        let shareUtil =
          (m.urgency * this.weights.wUrgency) +
          (saturation * this.weights.wSatShare) +
          (hasKey ? (this.weights.wHaveKey/2) : 0) +
          (this.costShare * this.weights.wCost);

        shareUtil *= this.modeShareScale(); // MODE EFFECT

        candidates.push({
          type:"share",
          utility:shareUtil,
          cost:this.costShare,
          target:neighbors,
          payload:{ voidObj:v, keyObj: hasKey ? this.keys[keyIdx] : null, saturation }
        });
      }

      const d = Math.sqrt(dist2(this.x,this.y,v.x,v.y));
      if (d < CFG.interactRadius){
        if (hasKey){
          const extra = isOrtho ? 50 : 0;
          const cost = this.costSolve + extra;
          let workUtil =
            (m.urgency * this.weights.wUrgency) +
            (saturation * this.weights.wSatSolve) +
            this.weights.wHaveKey +
            (cost * this.weights.wCost);

          workUtil *= this.modeSolveScale(); // MODE EFFECT

          candidates.push({
            type:"solve",
            utility:workUtil,
            cost:cost,
            target:v,
            payload:{ keyIdx, saturation }
          });
        } else {
          const cost = this.costGen + this.costSolve;
          let util =
            (m.urgency * this.weights.wUrgency) +
            (saturation * this.weights.wSatSolve) +
            (cost * this.weights.wCost);

          util *= this.modeSolveScale(); // MODE EFFECT

          candidates.push({
            type:"gen_solve",
            utility:util,
            cost:cost,
            target:v,
            payload:{ saturation }
          });
        }
      }
    }

    const visible = world.voids.filter(v => v.state==="active" && dist2(this.x,this.y,v.x,v.y) <= CFG.visionRadius*CFG.visionRadius);
    const unknown = visible.find(v => !this.voidMem.some(m => m.voidId === v.id));
    if (unknown){
      const scanBase = 20 + (this.consecutiveFailedScouts * this.weights.wScanFail);
      let scanUtil = scanBase + (this.costScan * this.weights.wCost);
      scanUtil *= this.modeScanScale(); // MODE EFFECT
      candidates.push({ type:"scan", utility:scanUtil, cost:this.costScan, target:unknown, payload:{} });
    }

    if (this.keys.length < this.maxKeys){
      const stockUtil = 5 + (this.costGen * this.weights.wCost);
      candidates.push({ type:"stockpile", utility:stockUtil, cost:this.costGen, target:null, payload:{} });
    }

    candidates.sort((a,b)=>b.utility - a.utility);
    const best = candidates[0];

    if (!best || best.utility <= 0){
      if (this.energy < 10 && !this.sleeping){
        this.sleeping = true;
        if (dayStats) dayStats.actions.sleep++;
      }
      return;
    }
    if (this.energy < best.cost){
      if (this.energy < 10 && !this.sleeping){
        this.sleeping = true;
        if (dayStats) dayStats.actions.sleep++;
      }
      return;
    }

    if (dayStats && dayStats.actions[best.type] !== undefined) dayStats.actions[best.type]++;

    if (dayStats && (best.type === "share" || best.type === "solve")){
      const sat = best.payload.saturation ?? null;
      const nei = (best.type === "share") ? (best.target?.length ?? 0) : neighbors.length;
      const MIN_NEI = 3;
      if (sat !== null && nei >= MIN_NEI){
        if (best.type === "share" && sat >= 0.75) dayStats.anomalies.shareHighSaturation++;
        if (best.type === "solve" && sat <= 0.15) dayStats.anomalies.solveLowSaturation++;
      }
    }

    this.energy -= best.cost;
    this.boredom = 0;

    switch(best.type){
      case "share":
        this.doShare(best.target, best.payload.voidObj, best.payload.keyObj, best.payload.saturation);
        break;
      case "solve":
        this.doSolve(best.target, best.payload.keyIdx);
        break;
      case "gen_solve":
        this.doGenSolve(best.target);
        break;
      case "scan":
        this.doScan(best.target);
        break;
      case "stockpile":
        this.stockpileGenerate(false);
        break;
    }
  }

  doScan(v){
    this.memorizeVoid(v, world.day);
    this.consecutiveFailedScouts = 0;
  }

  doShare(neighbors, v, keyObj, saturation){
    if (dayStats){
      dayStats.share.total++;
      dayStats.share.neighborsSum += neighbors.length;
      if (keyObj) dayStats.share.withKey++;
    }

    if (!dayShareSampleTaken && dayStats){
      dayShareSampleTaken = true;
      pushEvent("share_sample", { senderId:this.id, senderMode:this.mode, voidId:v.id, voidVal:v.val, neighbors:neighbors.length, withKey:!!keyObj, saturation });
    }

    // MODE: routers replicate shares harder
    const repFactor = this.modeShareRepFactor();
    const pShareRep = clamp(CFG.pReplicateShare * repFactor, 0, 0.95);

    for (const n of neighbors){
      n.memorizeVoid(v, world.day);
      if (keyObj && Math.random() < pShareRep){
        const k2 = new KeyObj(keyObj.val, keyObj.creatorId, n.modeTTLMax());
        n.addKey(k2);
        if (dayStats) dayStats.keys.replicatedShare++;
      }
    }
  }

  doSolve(v, keyIdx){
    if (v.state !== "active") return;

    v.hp -= 1;
    if (dayStats) dayStats.voids.hits++;

    this.energy = clamp(this.energy + v.rewardHit, 0, this.energyMax);

    const key = this.keys[keyIdx];
    if (key){
      key.ttlMax = this.modeTTLMax(); // keep in sync with current mode + slider
      key.ttl = Math.max(key.ttl, key.ttlMax);
      key.uses += 1;
      this.refreshKey(keyIdx);
      if (dayStats) dayStats.keys.used++;

      // MODE: vaults replicate internally harder
      const repFactor = this.modeInternalRepFactor();
      const pInternalRep = clamp(CFG.pReplicateInternal * repFactor, 0, 0.95);

      if (Math.random() < pInternalRep){
        this.addKey(new KeyObj(key.val, key.creatorId, this.modeTTLMax()));
        if (dayStats) dayStats.keys.replicatedInternal++;
      }
    }

    if (v.hp <= 0){
      v.state = "solved";
      this.energy = clamp(this.energy + v.rewardSolve, 0, this.energyMax);
      if (dayStats) dayStats.voids.solved++;
      pushEvent("void_solved", { voidId:v.id, voidVal:v.val, solverId:this.id, solverMode:this.mode });
    }
  }

  doGenSolve(v){
    if (v.state !== "active") return;

    if (dayStats) dayStats.genSolve.attempts++;

    const urg = v.urgency();
    const attempt = this.attemptTargetedGenerate(v.val, urg);
    if (attempt.ok){
      if (dayStats) dayStats.genSolve.successes++;

      v.hp -= 1;
      if (dayStats) dayStats.voids.hits++;

      this.addKey(new KeyObj(attempt.val, this.id, this.modeTTLMax()));
      this.energy = clamp(this.energy + v.rewardHit, 0, this.energyMax);

      if (v.hp <= 0){
        v.state = "solved";
        this.energy = clamp(this.energy + v.rewardSolve, 0, this.energyMax);
        if (dayStats) dayStats.voids.solved++;
        pushEvent("void_solved", { voidId:v.id, voidVal:v.val, solverId:this.id, solverMode:this.mode, via:"gen_solve" });
      }
    } else {
      this.consecutiveFailedScouts = Math.min(30, this.consecutiveFailedScouts + 2);
    }
  }

  startNewDay(){
    this.sleeping = false;
    this.boredom = 0;
    this.ageDays += 1;
    this.consecutiveFailedScouts = Math.max(0, this.consecutiveFailedScouts - 1);

    if (CFG.carryoverEnergy){
      this.energy = clamp(this.energy + CFG.dailyEnergy, 0, this.energyMax);
    } else {
      this.energy = CFG.dailyEnergy;
    }

    if (this.ageDays >= CFG.maxAgeDays){
      this.alive = false;
      if (dayStats) dayStats.deaths.age++;
      pushEvent("agent_died", { agentId:this.id, cause:"age", ageDays:this.ageDays, mode:this.mode });
    }
  }
}

//////////////////////////////
// 4) World state + stepping //
//////////////////////////////

const world = {
  day: 0,
  tick: 0,
  agents: [],
  voids: [],
  voidMap: new Map(),
  explosions: [],
  paused: false
};

function initWorld(){
  world.day = 0;
  world.tick = 0;
  world.agents = [];
  world.voids = [];
  world.voidMap = new Map();
  world.explosions = [];
  nextAgentId = 0;
  nextVoidId = 0;

  initTelemetry();

  for (let i=0;i<CFG.initialAgents;i++){
    world.agents.push(new Agent(CFG.maxMem));
  }
  for (let i=0;i<CFG.targetVoids;i++){
    const v = new VoidObj(CFG.voidHp);
    world.voids.push(v);
    world.voidMap.set(v.id, v);
  }

  pushEvent("init_world", { agents: world.agents.length, voids: world.voids.length });

  startDayStats(0);

  // reset inspector selection
  inspector.selected = null;
  updateInspectorUI();
}

function stepTick(){
  world.tick++;
  if (dayStats) { dayStats.ticks++; }

  let activeCount = 0;
  for (const a of world.agents){
    if (!a.alive || a.sleeping) continue;
    a.move();
    a.interact();
    activeCount++;
  }

  if (activeCount === 0 || world.tick >= CFG.maxTicksPerDay){
    endDay();
  }
}

function endDay(){
  const exploded = [];
  for (const v of world.voids){
    if (v.state !== "active") continue;
    v.lifespan -= 1;
    v.ageDays += 1;
    if (v.lifespan <= 0){
      v.state = "exploded";
      exploded.push(v);
      world.explosions.push({ x:v.x, y:v.y, age: 0 });

      if (dayStats) dayStats.voids.exploded++;
      pushEvent("void_exploded", { voidId:v.id, voidVal:v.val, x:v.x, y:v.y });
    }
  }

  if (exploded.length){
    for (const v of exploded){
      for (const a of world.agents){
        if (!a.alive) continue;
        const d = Math.sqrt(dist2(a.x,a.y,v.x,v.y));
        if (d > CFG.blastRadius) continue;
        const t = 1.0 - (d / CFG.blastRadius);
        const pDeath = clamp(CFG.baseDeath + CFG.kDeath * t, 0, 1);
        if (Math.random() < pDeath){
          a.alive = false;
          if (dayStats) dayStats.deaths.explosion++;
          pushEvent("agent_died", { agentId:a.id, cause:"explosion", voidId:v.id, dist:d, pDeath, mode:a.mode });
        }
      }
    }
  }

  // remove non-active voids (and keep map in sync)
  for (const v of world.voids){
    if (v.state !== "active") world.voidMap.delete(v.id);
  }
  world.voids = world.voids.filter(v => v.state === "active");

  for (const a of world.agents){
    if (!a.alive) continue;
    a.decayKeys();
  }

  world.agents = world.agents.filter(a => a.alive);

  for (const a of world.agents){
    a.startNewDay();
  }
  world.agents = world.agents.filter(a => a.alive);

  // Reproduction
  if (world.agents.length < CFG.maxPop){
    const parents = world.agents.filter(a => a.ageDays >= CFG.minParentAgeDays);
    if (parents.length && Math.random() < 0.60){
      const p = parents[Math.floor(Math.random()*parents.length)];
      const child = new Agent(CFG.maxMem, p.x, p.y, p);
      world.agents.push(child);
      if (dayStats) dayStats.births++;
      pushEvent("agent_born", { childId: child.id, parentId: p.id, childMode: child.mode, parentMode: p.mode, childValue: child.agentValue, parentValue: p.agentValue });
    } else if (world.agents.length < 5){
      const child = new Agent(CFG.maxMem);
      world.agents.push(child);
      if (dayStats) dayStats.births++;
      pushEvent("agent_born", { childId: child.id, parentId: null, childMode: child.mode, childValue: child.agentValue });
    }
  }

  // Respawn: keep trying until target, bounded attempts
  const needed = Math.max(0, CFG.targetVoids - world.voids.length);
  const maxAttempts = Math.max(needed * 6, 30);
  let attempts = 0;

  while (world.voids.length < CFG.targetVoids && attempts < maxAttempts){
    attempts++;
    if (Math.random() < CFG.voidRespawnProb){
      const v = new VoidObj(CFG.voidHp);
      world.voids.push(v);
      world.voidMap.set(v.id, v);
      if (dayStats) dayStats.voids.spawned++;
    }
  }

  finalizeDayStats();

  world.day += 1;
  world.tick = 0;
  startDayStats(world.day);

  // keep inspector selection valid
  if (inspector.selected){
    const stillThere = resolveSelection(inspector.selected);
    if (!stillThere) inspector.selected = null;
    updateInspectorUI();
  }
}

/////////////////////////
// 5) Inspector (click) //
/////////////////////////

const inspector = {
  selected: null, // {type:"agent"/"void", id:number}
  text: "",
  uiPre: null
};

function screenToWorld(mx, my){
  const wx = map(mx, 0, width, 0, CFG.arenaSize);
  const wy = map(my, 0, height, 0, CFG.arenaSize);
  return { wx, wy };
}

function resolveSelection(sel){
  if (!sel) return null;
  if (sel.type === "agent"){
    return world.agents.find(a => a.id === sel.id) || null;
  }
  if (sel.type === "void"){
    return world.voidMap.get(sel.id) || null;
  }
  return null;
}

function pickNearestAtMouse(mx, my){
  const { wx, wy } = screenToWorld(mx, my);

  let best = null;
  let bestD2 = Infinity;

  // agents
  for (const a of world.agents){
    const d2 = dist2(wx, wy, a.x, a.y);
    if (d2 < bestD2){
      bestD2 = d2;
      best = { type:"agent", id:a.id, d2 };
    }
  }
  // voids
  for (const v of world.voids){
    const d2 = dist2(wx, wy, v.x, v.y);
    if (d2 < bestD2){
      bestD2 = d2;
      best = { type:"void", id:v.id, d2 };
    }
  }

  // threshold in WORLD units (based on pixels)
  const thresholdPx = 14;
  const thresholdWorld = map(thresholdPx, 0, Math.min(width,height), 0, CFG.arenaSize);
  if (!best) return null;
  if (Math.sqrt(best.d2) > thresholdWorld) return null;

  return { type: best.type, id: best.id };
}

function updateInspectorUI(){
  if (!inspector.uiPre) return;
  const sel = inspector.selected;
  if (!sel){
    inspector.uiPre.html("Click an agent or void to inspect.\n\nTip: click near objects; selection highlights on canvas.");
    return;
  }
  const obj = resolveSelection(sel);
  if (!obj){
    inspector.uiPre.html("Selection no longer exists (despawned).");
    return;
  }

  if (sel.type === "void"){
    const v = obj;
    const s =
`[VOID #${v.id}]  state=${v.state}
pos=(${v.x.toFixed(1)}, ${v.y.toFixed(1)})
val=${v.val}°
hp=${v.hp}/${v.hpMax}
lifespan=${v.lifespan}/${v.lifespanMax}  ageDays=${v.ageDays}
urgency=${v.urgency().toFixed(2)}
rewardHit=${v.rewardHit}  rewardSolve=${v.rewardSolve}
`;
    inspector.uiPre.html(s);
  } else {
    const a = obj;
    // summarize key bins + top few keys
    const topKeys = [...a.keys].slice(-8).reverse().map(k => `${k.val}° ttl=${k.ttl.toFixed(1)}/${k.ttlMax} uses=${k.uses} cr=${k.creatorId}`).join("\n");
    const topVoids = [...a.voidMem]
      .sort((x,y)=>(y.urgency||0)-(x.urgency||0))
      .slice(0,6)
      .map(m => `#${m.voidId} val=${m.val} urg=${(m.urgency||0).toFixed(2)} seenDay=${m.lastSeenDay}`)
      .join("\n");
    const s =
`[AGENT #${a.id}]  mode=${a.mode}  alive=${a.alive}  sleeping=${a.sleeping}
pos=(${a.x.toFixed(1)}, ${a.y.toFixed(1)})  v=(${a.vx.toFixed(2)}, ${a.vy.toFixed(2)})
agentValue=${a.agentValue}°
ageDays=${a.ageDays}
energy=${a.energy.toFixed(1)}/${a.energyMax}
boredom=${a.boredom}  failedScouts=${a.consecutiveFailedScouts}

memory: total=${a.totalMem}  memSplit(keys)=${a.memSplit.toFixed(2)}
caps: maxKeys=${a.maxKeys}  maxVoidMem=${a.maxVoidMem}
keys: count=${a.keys.length}  ttlMax(mode)=${a.modeTTLMax()}  decayRate(mode)=${a.modeDecayRate()}

Top keys (newest first):
${topKeys || "(none)"}

Top void memory (highest urgency):
${topVoids || "(none)"}
`;
    inspector.uiPre.html(s);
  }
}

/////////////////////////
// 6) p5.js rendering   //
/////////////////////////

let ui;
let sliders = {};
let btnPause, btnReset, btnHud, btnDownload;
let showHud = true;

function setup(){
  createCanvas(window.innerWidth, window.innerHeight);
  colorMode(HSB, 360, 100, 100, 1);
  noStroke();
  initUI();
  initWorld();
  background(220, 35, 8);
}

function windowResized(){
  resizeCanvas(window.innerWidth, window.innerHeight);
}

function draw(){
  if (!CFG.drawTrails){
    fill(220, 35, 8, CFG.backgroundFade/255);
    rect(0,0,width,height);
  }

  if (!world.paused){
    for (let i=0;i<CFG.ticksPerFrame;i++){
      stepTick();
    }
  }

  for (const e of world.explosions) e.age += 1;
  world.explosions = world.explosions.filter(e => e.age < 25);

  // voids
  for (const v of world.voids){
    const px = map(v.x, 0, CFG.arenaSize, 0, width);
    const py = map(v.y, 0, CFG.arenaSize, 0, height);
    const hue = v.val;
    const urg = v.urgency();
    const bright = clamp(30 + urg/2, 30, 100);
    stroke(hue, 80, bright, 0.9);
    strokeWeight(2);
    line(px-6, py-6, px+6, py+6);
    line(px-6, py+6, px+6, py-6);
    noStroke();
  }

  // explosions
  noStroke();
  for (const e of world.explosions){
    const px = map(e.x, 0, CFG.arenaSize, 0, width);
    const py = map(e.y, 0, CFG.arenaSize, 0, height);
    const a = 0.35 * (1 - e.age/25);
    fill(0, 90, 90, a);
    const r = map(e.age, 0, 25, 10, map(CFG.blastRadius,0,CFG.arenaSize,0,Math.min(width,height)));
    circle(px, py, r*2);
  }

  // agents
  for (const a of world.agents){
    const px = map(a.x, 0, CFG.arenaSize, 0, width);
    const py = map(a.y, 0, CFG.arenaSize, 0, height);

    let maxUrg = 0;
    for (const m of a.voidMem) maxUrg = Math.max(maxUrg, m.urgency || 0);
    const t = clamp(maxUrg / 100.0, 0, 1);
    const hue = lerpHue(220, 0, t);

    // mode visualization: vault slightly higher saturation, router slightly lower
    const alpha = a.sleeping ? 0.25 : 0.78;
    const sat = a.sleeping ? 10 : (a.mode === "vault" ? 80 : 60);
    const bri = a.sleeping ? 70 : 92;

    fill(hue, sat, bri, alpha);
    circle(px, py, a.sleeping ? 7 : 9);

    // selected highlight
    if (inspector.selected && inspector.selected.type === "agent" && inspector.selected.id === a.id){
      noFill();
      stroke(60, 10, 98, 0.9);
      strokeWeight(2);
      circle(px, py, 16);
      noStroke();
    }
  }

  // selected void highlight
  if (inspector.selected && inspector.selected.type === "void"){
    const v = world.voidMap.get(inspector.selected.id);
    if (v && v.state === "active"){
      const px = map(v.x, 0, CFG.arenaSize, 0, width);
      const py = map(v.y, 0, CFG.arenaSize, 0, height);
      noFill();
      stroke(60, 10, 98, 0.9);
      strokeWeight(2);
      circle(px, py, 18);
      noStroke();
    }
  }

  if (showHud){
    drawHUD();
  }

  applyUI();

  // keep inspector text reasonably fresh
  if (frameCount % 10 === 0) updateInspectorUI();
}

function lerpHue(h1, h2, t){
  return h1 + (h2 - h1)*t;
}

function drawHUD(){
  const pop = world.agents.length;
  const voids = world.voids.length;
  const active = world.agents.filter(a => a.alive && !a.sleeping).length;

  let ent = computeEntropyProxy();
  let cov = computeCoverage();

  // mode counts (live)
  let vCount = 0, rCount = 0;
  for (const a of world.agents){
    if (a.mode === "vault") vCount++;
    else rCount++;
  }

  fill(0, 0, 100, 0.85);
  rect(width-380, 10, 370, 165, 10);

  fill(220, 20, 10, 1);
  textSize(12);
  textAlign(LEFT, TOP);

  const an = dayStats ? dayStats.anomalies : null;
  const cl = dayStats ? dayStats.cleanup : null;

  const anLine = an
    ? `Anom: mapMis=${an.voidMapMismatch} shareHiSat=${an.shareHighSaturation} solveLoSat=${an.solveLowSaturation} genWaste=${an.genSolveWasteSuspected?1:0}`
    : "Anom: (n/a)";

  const clLine = cl
    ? `Cleanup: memMissing=${cl.voidMemRemovedMissing} memRecent=${cl.voidMemRemovedRecent}`
    : "Cleanup: (n/a)";

  text(
    `Day: ${world.day}   Tick: ${world.tick}\n` +
    `Pop: ${pop}   Active: ${active}\n` +
    `Modes: vault=${vCount} router=${rCount}\n` +
    `Voids: ${voids}   Entropy~: ${ent.toFixed(0)}\n` +
    `Coverage: ${(cov*100).toFixed(1)}%\n` +
    `${anLine}\n` +
    `${clLine}\n` +
    `Telemetry days: ${telemetry ? telemetry.days.length : 0}  events: ${telemetry ? telemetry.events.length : 0}`,
    width-370, 18
  );

  // spectra bars (voids) + line (keys)
  const bins = CFG.telemetryBins;
  const vb = new Array(bins).fill(0);
  const kb = new Array(bins).fill(0);

  for (const v of world.voids){
    const idx = Math.floor((v.val/360)*bins);
    vb[clamp(idx,0,bins-1)]++;
  }
  for (const a of world.agents){
    for (const k of a.keys){
      const idx = Math.floor((k.val/360)*bins);
      kb[clamp(idx,0,bins-1)]++;
    }
  }

  const x0 = width-370, y0 = 155, w = 350, h = 18;
  const maxV = Math.max(1, ...vb);
  const maxK = Math.max(1, ...kb);

  for (let i=0;i<bins;i++){
    const x = x0 + (i/bins)*w;
    const bw = w/bins;
    const hh = (vb[i]/maxV)*h;
    fill(i*(360/bins), 70, 90, 0.55);
    rect(x, y0 + (h-hh), bw, hh);
  }
  stroke(120, 10, 95, 0.8);
  strokeWeight(1);
  noFill();
  beginShape();
  for (let i=0;i<bins;i++){
    const x = x0 + (i+0.5)/bins*w;
    const yy = y0 + h - (kb[i]/maxK)*h;
    vertex(x, yy);
  }
  endShape();
  noStroke();
}

/////////////////////////
// 7) UI controls       //
/////////////////////////

function initUI(){
  ui = select("#ui");
  ui.html("");

  const mkSlider = (name, label, min, max, value, step=1) => {
    const row = createDiv("").addClass("row").parent(ui);
    createElement("label", label).parent(row);
    const s = createSlider(min, max, value, step).parent(row);
    s.style("width", "210px");
    const v = createSpan(String(value)).addClass("val mono").parent(row);
    sliders[name] = { s, v, label };
  };

  mkSlider("ticksPerFrame", "Speed (ticks/frame)", 1, 40, CFG.ticksPerFrame, 1);
  mkSlider("targetVoids", "Target voids", 5, 100, CFG.targetVoids, 1);
  mkSlider("voidHp", "Void HP", 1, 120, CFG.voidHp, 1);
  mkSlider("maxPop", "Max population", 10, 500, CFG.maxPop, 10);
  mkSlider("maxMem", "Memory (keys+voids)", 10, 200, CFG.maxMem, 5);
  mkSlider("keyTTLMax", "Key TTL base (days)", 2, 40, CFG.keyTTLMax, 1);
  mkSlider("matchEps", "Match ε (deg)", 0, 10, CFG.matchEps, 1);
  mkSlider("blastRadius", "Blast radius", 40, 260, CFG.blastRadius, 5);
  mkSlider("kDeath", "Blast lethality", 0.00, 0.60, CFG.kDeath, 0.01);

  const btnRow = createDiv("").addClass("btns").parent(ui);
  btnPause = createButton("Pause").parent(btnRow).mousePressed(() => {
    world.paused = !world.paused;
    btnPause.html(world.paused ? "Resume" : "Pause");
  });
  btnReset = createButton("Reset").parent(btnRow).mousePressed(() => {
    initWorld();
  });
  btnHud = createButton("Toggle HUD").parent(btnRow).mousePressed(() => {
    showHud = !showHud;
  });
  btnDownload = createButton("Download Telemetry").parent(btnRow).mousePressed(() => {
    downloadTelemetry();
  });

  createDiv(`<div class="hint">
    <b>Modes: Vault vs Router</b><br/>
    • <b>Vault</b>: bigger key memory, longer TTL, slower decay, more internal replication, less share/scan.<br/>
    • <b>Router</b>: smaller key memory, faster decay, more share/scan, more share replication.<br/>
    This should prevent “key monoculture” from deleting rare keys: routers can trend, vaults preserve.
  </div>`).parent(ui);

  // Inspector UI
  const insp = createDiv("").addClass("inspector").parent(ui);
  createElement("h3", "Inspector").parent(insp);
  inspector.uiPre = createElement("pre", "Click an agent or void to inspect.\n\nTip: click near objects; selection highlights on canvas.").parent(insp);
}

function applyUI(){
  const get = (k) => sliders[k].s.value();

  CFG.ticksPerFrame = Number(get("ticksPerFrame"));
  CFG.targetVoids = Number(get("targetVoids"));
  CFG.voidHp = Number(get("voidHp"));
  CFG.maxPop = Number(get("maxPop"));
  CFG.maxMem = Number(get("maxMem"));
  CFG.keyTTLMax = Number(get("keyTTLMax"));
  CFG.matchEps = Number(get("matchEps"));
  CFG.blastRadius = Number(get("blastRadius"));
  CFG.kDeath = Number(get("kDeath"));

  for (const k of Object.keys(sliders)){
    sliders[k].v.html(String(sliders[k].s.value()));
  }

  for (const a of world.agents){
    if (a.totalMem !== CFG.maxMem){
      a.totalMem = CFG.maxMem;
      a.recomputeCaps();
    }
    // keep each key aligned to the agent's mode TTL max
    const desired = a.modeTTLMax();
    for (const key of a.keys){
      key.ttlMax = desired;
      key.ttl = Math.min(key.ttl, key.ttlMax);
    }
  }
}

function keyPressed(){
  if (key === ' ') {
    world.paused = !world.paused;
    btnPause.html(world.paused ? "Resume" : "Pause");
  }
  if (key === 'r' || key === 'R'){
    initWorld();
  }
  if (key === 'Escape'){
    inspector.selected = null;
    updateInspectorUI();
  }
}

function mousePressed(){
  // ignore clicks on UI panel
  const panel = document.getElementById("ui");
  if (panel){
    const rect = panel.getBoundingClientRect();
    if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) return;
  }

  const pick = pickNearestAtMouse(mouseX, mouseY);
  if (pick){
    inspector.selected = pick;
  } else {
    inspector.selected = null;
  }
  updateInspectorUI();
}
</script>
</body>
</html>
