<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BCM v3 ‚Äî Dice Entropy + Internal Key Generation + Copying Keys + Inspector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    :root { --uiw: 520px; }
    html, body { margin:0; height:100%; background:#0e0f12; color:#e8eaf1; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    #ui{
      position:fixed; top:0; right:0; width:var(--uiw); height:100%;
      overflow:auto; box-sizing:border-box; padding:14px 14px 120px;
      background:#14161b; border-left:1px solid #1e2230;
    }
    #ui h2{ margin:6px 0 10px; font-size:16px; font-weight:700; }
    .group{ border:1px solid #1f2535; border-radius:10px; padding:10px; margin-bottom:12px; background:#10131a; }
    label{ display:block; font-size:12px; opacity:.9; margin:6px 0 4px; }
    input[type="range"]{ width:100%; }
    button, select{
      width:100%; border-radius:8px; border:1px solid #2a3248;
      padding:8px 10px; background:#18202d; color:#e8eaf1; cursor:pointer;
    }
    button:hover{ background:#1c2737; }
    .row{ display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    details summary{ cursor:pointer; user-select:none; }
    pre{
      white-space:pre; background:#0c0f16; border:1px solid #1f2535;
      border-radius:8px; padding:10px; color:#d6dbef; font-size:12px; line-height:1.35;
      overflow:auto;
    }
    #metrics{
      position:fixed; left:10px; top:10px;
      background:rgba(8,10,14,.78); border:1px solid #1e2230; border-radius:8px;
      padding:8px 10px; backdrop-filter:blur(6px);
      max-width:560px;
    }
    canvas{ display:block; }
    .tiny{ font-size:11px; opacity:.85; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .kv { display:grid; grid-template-columns: 140px 1fr; gap:4px 10px; font-size:12px; }
    .kv div:nth-child(odd){ opacity:.85; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a3248; background:#141b28; font-size:11px; opacity:.95; }
    .warn { color:#ffd28a; }
    .good { color:#8bffb0; }
    .bad { color:#ff9a9a; }
    .sep { height:1px; background:#1f2535; margin:10px 0; opacity:.8; }
  </style>
</head>

<body>

<div id="ui">
  <h2>BCM v3 ‚Äî Entropy (2d6) + Keys + Voids + Internal Generation</h2>

  <div class="group">
    <div class="row">
      <button id="btnPause">Pause</button>
      <button id="btnReset">Reset</button>
    </div>
    <div class="tiny" style="margin-top:6px">
      Shortcuts: <span class="mono">Space</span>=pause, <span class="mono">R</span>=reset,
      <span class="mono">V</span>=spawn void, <span class="mono">E</span>=spawn energy
    </div>
    <div class="tiny" style="margin-top:6px">
      Click to select: agent / void / energy (white ring highlight).
    </div>
  </div>

  <div class="group" id="inspector">
    <h3 style="margin:6px 0 6px; font-size:13px">Inspector</h3>
    <div class="tiny">Select an agent, void, or energy source to see its state.</div>
    <div id="inspectContent" style="margin-top:8px"></div>
  </div>

  <div class="group">
    <label>Sim speed: <span id="lblSpeed">1.00</span></label>
    <input id="sSpeed" type="range" min="0.2" max="5" step="0.01" value="1.00" />

    <label>Agents: <span id="lblAgents">50</span></label>
    <input id="sAgents" type="range" min="1" max="200" step="1" value="50" />

    <label>Internal agents (%): <span id="lblInternal">35</span></label>
    <input id="sInternalPct" type="range" min="0" max="100" step="1" value="35" />

    <label>Key storage limit per agent: <span id="lblKCap">8</span></label>
    <input id="sKCap" type="range" min="2" max="18" step="1" value="8" />

    <label><input id="chkTrails" type="checkbox" checked /> Trails</label>
    <label><input id="chkSignals" type="checkbox" checked /> Signals (ripples)</label>
    <label><input id="chkShards" type="checkbox" checked /> Key shards (copy tokens)</label>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Movement Stabilizers</h3>
    <label>Energy Low (switch to Harvest): <span id="lblELow">0.30</span></label>
    <input id="sELow" type="range" min="0.05" max="0.80" step="0.01" value="0.30" />
    <label>Energy High (switch back to Solve): <span id="lblEHigh">0.55</span></label>
    <input id="sEHigh" type="range" min="0.10" max="1.20" step="0.01" value="0.55" />
    <label>Commit time (sec): <span id="lblCommit">2.5</span></label>
    <input id="sCommit" type="range" min="0" max="10" step="0.1" value="2.5" />
    <label>Switch margin (√ó): <span id="lblMargin">1.25</span></label>
    <input id="sMargin" type="range" min="1.00" max="2.50" step="0.01" value="1.25" />
    <div class="tiny">
      Stops ‚Äúbounce‚Äù: agents don‚Äôt immediately re-flip their target each frame.
    </div>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Voids (Locks)</h3>
    <label>Spawn rate / min: <span id="lblVoidRate">16</span></label>
    <input id="sVoidRate" type="range" min="0" max="120" step="1" value="16" />
    <label>Max active voids: <span id="lblVoidMax">40</span></label>
    <input id="sVoidMax" type="range" min="0" max="180" step="1" value="40" />
    <label>Growth rate: <span id="lblVoidGrow">0.05</span></label>
    <input id="sVoidGrow" type="range" min="0" max="0.25" step="0.005" value="0.05" />
    <label>Solve threshold (area %): <span id="lblSolveThr">20</span></label>
    <input id="sSolveThr" type="range" min="1" max="60" step="1" value="20" />
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Energy (Harvest)</h3>
    <label>Spawn rate / min: <span id="lblERate">40</span></label>
    <input id="sERate" type="range" min="0" max="180" step="1" value="40" />
    <label>Max active sources: <span id="lblEMax">55</span></label>
    <input id="sEMax" type="range" min="0" max="220" step="1" value="55" />
    <label>Harvest rate: <span id="lblHarvest">0.035</span></label>
    <input id="sHarvest" type="range" min="0" max="1.2" step="0.01" value="0.035" />
    <label>Energy spend (solve): <span id="lblSpend">0.20</span></label>
    <input id="sSpend" type="range" min="0" max="1.0" step="0.01" value="0.20" />
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Internal Key Generation</h3>
    <label>Generate if best ‚Äúgoodness‚Äù below: <span id="lblGenThr">0.45</span></label>
    <input id="sGenThr" type="range" min="0.05" max="0.95" step="0.01" value="0.45" />
    <label>Generation cost / sec: <span id="lblGenCost">0.08</span></label>
    <input id="sGenCost" type="range" min="0" max="0.50" step="0.01" value="0.08" />
    <label>Finish at progress (% of void area): <span id="lblGenFinish">60</span></label>
    <input id="sGenFinish" type="range" min="20" max="95" step="1" value="60" />
    <div class="tiny">
      Internal agents ‚Äúsit‚Äù on a lock and slowly learn a new key pattern from it.
    </div>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Copying / Memes</h3>
    <label>Drop key shard when helped (Œî area ‚â•): <span id="lblShardDelta">2</span></label>
    <input id="sShardDelta" type="range" min="1" max="10" step="1" value="2" />
    <label>Shard drop probability: <span id="lblShardP">0.55</span></label>
    <input id="sShardP" type="range" min="0" max="1" step="0.01" value="0.55" />
    <label>Shard pickup cost: <span id="lblShardCost">0.05</span></label>
    <input id="sShardCost" type="range" min="0" max="0.50" step="0.01" value="0.05" />
    <div class="tiny">
      Shards are ‚Äúcopies of solutions‚Äù you can pick up and replicate.
    </div>
  </div>

  <div class="group">
    <details>
      <summary class="tiny">Legend / Notes</summary>
      <div class="tiny" style="margin-top:8px">
        üü• void (lock): stamp shows remaining unsolved cells; radius ~ amount of work<br/>
        üü© energy: stamp shows harvest pattern; ring shows remaining amount<br/>
        üî∑ key shard: free copy token for a key shape<br/>
        Ripples: greener = key helped; orange = did nothing / worsened<br/>
        Agent colors: T=blue, F=red, N=purple, S=yellow; internal = darker
      </div>
    </details>
  </div>
</div>

<div id="metrics"></div>

<script>
/* =========================================================
   BCM v3
   - 2d6 rarity distribution (entropy)
   - external vs internal agents
   - internal key generation on locks
   - key shards (copying)
   - inspector for agent/void/energy
========================================================= */

let W, H, trails;
let paused = false;
let simTime = 0;
let dtSim = 0;

const UI = {};
const SHAPE_N = 7;
const SHAPE_C = SHAPE_N * SHAPE_N;

let SHAPES = [];           // {name, cells:Int8Array, mass, tier}
let COMMON = [];           // indices in SHAPES
let nextVoidId = 1;
let nextKeyId = 1;
let nextEnergyId = 1;

let agents = [];
let voids = [];
let energySources = [];
let signals = [];          // {x,y,t,ttl,payload:{voidId,areaB,keyId,areaA,shapeId,delta}}
let keyShards = [];        // {id,x,y,r,shapeId,ttl}

let selection = { type: null, id: null }; // "agent"|"void"|"energy"|null

/* ---------- basic math helpers ---------- */
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function wrap01(u){ u = u % 1; if (u < 0) u += 1; return u; }
function wrapDelta(d){ if (d > 0.5) d -= 1; if (d < -0.5) d += 1; return d; }
function idxS(x,y){ return y*SHAPE_N + x; }

function torusVec(ax, ay, bx, by){
  const dx = wrapDelta(bx-ax), dy = wrapDelta(by-ay);
  return {dx, dy, d: Math.hypot(dx,dy)};
}

function cloneCells(c){ const o = new Int8Array(c.length); o.set(c); return o; }
function shapeMass(c){ let m=0; for (let i=0;i<c.length;i++) m += c[i] ? 1 : 0; return m; }
function shapeOR(a,b){
  const o = new Int8Array(SHAPE_C);
  for (let i=0;i<SHAPE_C;i++) o[i] = (a[i] || b[i]) ? 1 : 0;
  return o;
}

function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* ---------- 2d6 entropy ---------- */
function dice2d6(){
  const a = 1 + Math.floor(Math.random()*6);
  const b = 1 + Math.floor(Math.random()*6);
  return a + b; // 2..12
}
function rarityFromRoll(r){
  // distance from 7 => rarity
  return clamp01(Math.abs(r - 7) / 5);
}

/* ---------- shapes ---------- */
function randomShape(density=0.22, smoothPasses=2){
  let c = new Int8Array(SHAPE_C);
  for (let y=0;y<SHAPE_N;y++){
    for (let x=0;x<SHAPE_N;x++){
      const cx = (x-(SHAPE_N-1)/2)/(SHAPE_N/2);
      const cy = (y-(SHAPE_N-1)/2)/(SHAPE_N/2);
      const centerBias = Math.exp(-(cx*cx+cy*cy)*1.2);
      const p = density*(0.65 + 0.7*centerBias);
      c[idxS(x,y)] = (Math.random() < p) ? 1 : 0;
    }
  }
  for (let pass=0; pass<smoothPasses; pass++){
    const n = new Int8Array(SHAPE_C);
    for (let y=0;y<SHAPE_N;y++){
      for (let x=0;x<SHAPE_N;x++){
        let sum=0;
        for (let oy=-1;oy<=1;oy++){
          for (let ox=-1;ox<=1;ox++){
            if (!ox && !oy) continue;
            const xx=x+ox, yy=y+oy;
            if (xx<0||xx>=SHAPE_N||yy<0||yy>=SHAPE_N) continue;
            sum += c[idxS(xx,yy)];
          }
        }
        const here = c[idxS(x,y)];
        n[idxS(x,y)] = (sum>=4) ? 1 : (sum<=1 ? 0 : here);
      }
    }
    c = n;
  }
  if (shapeMass(c) < 6){
    for (let i=0;i<SHAPE_C;i++) c[i]=0;
    const mid = Math.floor(SHAPE_N/2);
    for (let x=1;x<SHAPE_N-1;x++) c[idxS(x,mid)] = 1;
    for (let y=1;y<SHAPE_N-1;y++) c[idxS(mid,y)] = 1;
  }
  return c;
}

function initShapes(){
  SHAPES = [];
  COMMON = [];

  const mid = Math.floor(SHAPE_N/2);
  const blank = () => new Int8Array(SHAPE_C);
  const set = (c,x,y) => { if (x>=0&&x<SHAPE_N&&y>=0&&y<SHAPE_N) c[idxS(x,y)] = 1; };

  // Common prototypes
  const addShape = (name, cells, tier) => {
    SHAPES.push({name, cells, mass: shapeMass(cells), tier});
    return SHAPES.length - 1;
  };

  // plus (very common)
  {
    const c = blank();
    for (let x=1;x<SHAPE_N-1;x++) set(c,x,mid);
    for (let y=1;y<SHAPE_N-1;y++) set(c,mid,y);
    COMMON.push(addShape("plus", c, "common"));
  }
  // ring
  {
    const c = blank();
    for (let x=1;x<SHAPE_N-1;x++){ set(c,x,1); set(c,x,SHAPE_N-2); }
    for (let y=1;y<SHAPE_N-1;y++){ set(c,1,y); set(c,SHAPE_N-2,y); }
    COMMON.push(addShape("ring", c, "common"));
  }
  // diag
  {
    const c = blank();
    for (let i=1;i<SHAPE_N-1;i++) set(c,i,i);
    set(c,mid,mid-1); set(c,mid-1,mid);
    COMMON.push(addShape("diag", c, "common"));
  }
  // L
  {
    const c = blank();
    for (let y=1;y<SHAPE_N-1;y++) set(c,1,y);
    for (let x=1;x<SHAPE_N-1;x++) set(c,x,SHAPE_N-2);
    COMMON.push(addShape("L", c, "common"));
  }
  // blob
  {
    const c = blank();
    for (let y=2;y<=4;y++) for (let x=2;x<=4;x++) set(c,x,y);
    set(c,1,3); set(c,5,3); set(c,3,1); set(c,3,5);
    COMMON.push(addShape("blob", c, "common"));
  }

  // Uncommon / rare random shapes
  for (let i=0;i<14;i++){
    const rc = randomShape(0.18 + 0.12*Math.random(), 2);
    const tier = (i < 8) ? "uncommon" : "rare";
    addShape("rand"+i, rc, tier);
  }
}

/* Choose a shape using dice entropy:
   - 6-8 => common
   - 5,9 => mostly common + some uncommon
   - 4,10 => uncommon
   - 3,11 => rare
   - 2,12 => rare (or "exotic": random + later combos)
*/
function sampleShapeByDice(){
  const roll = dice2d6();
  if (roll === 7 || roll === 6 || roll === 8){
    return {shapeId: randChoice(COMMON), roll};
  }
  if (roll === 5 || roll === 9){
    if (Math.random() < 0.75) return {shapeId: randChoice(COMMON), roll};
    // uncommon
    const pool = SHAPES.map((s,idx)=>({s,idx})).filter(x=>x.s.tier==="uncommon").map(x=>x.idx);
    return {shapeId: randChoice(pool), roll};
  }
  if (roll === 4 || roll === 10){
    const pool = SHAPES.map((s,idx)=>({s,idx})).filter(x=>x.s.tier==="uncommon").map(x=>x.idx);
    return {shapeId: randChoice(pool), roll};
  }
  // 3,11,2,12
  const pool = SHAPES.map((s,idx)=>({s,idx})).filter(x=>x.s.tier==="rare").map(x=>x.idx);
  return {shapeId: randChoice(pool), roll};
}

/* ---------- keys ---------- */
function makeKey(shapeId){
  return {
    keyId: nextKeyId++,
    shapeId,
    cells: SHAPES[shapeId].cells,
    uses: 0,
    createdAt: simTime
  };
}
function agentHasShape(agent, shapeId){
  return agent.keys.some(k => k.shapeId === shapeId);
}
function ensureStorage(agent){
  const cap = parseInt(UI.sKCap.value);
  while (agent.keys.length > cap){
    agent.keys.sort((a,b) => (a.uses - b.uses) || (a.createdAt - b.createdAt));
    agent.keys.shift();
  }
}

function matchKeyToPattern(keyCells, patternCells){
  let fill=0, spill=0, mass=0;
  for (let i=0;i<SHAPE_C;i++){
    const p = patternCells[i];
    const k = keyCells[i];
    if (p) mass++;
    if (k){
      if (p) fill++;
      else spill++;
    }
  }
  const score = (fill - 1.25*spill) / (mass + 1e-6);
  const good = clamp01((score + 1) / 2);
  const bad  = clamp01((-score));
  return {fill, spill, mass, score, good, bad};
}

function bestKey(agent, patternCells){
  let best = null;
  for (const k of agent.keys){
    const m = matchKeyToPattern(k.cells, patternCells);
    if (!best || m.score > best.m.score) best = {k, m};
  }
  return best;
}

/* ---------- function colors (T/F/N/S) ---------- */
const FUNC = ["T","F","N","S"];
function funcColor(f){
  // base RGB per Bin: Thinking=blue, Feeling=red, Intuition=purple, Sensing=yellow
  if (f === "T") return [80, 140, 255];
  if (f === "F") return [255, 90, 90];
  if (f === "N") return [185, 105, 255];
  return [255, 215, 90]; // S
}
function mixRGB(a,b,t){
  return [
    Math.round(a[0]*(1-t)+b[0]*t),
    Math.round(a[1]*(1-t)+b[1]*t),
    Math.round(a[2]*(1-t)+b[2]*t),
  ];
}
function shade(rgb, factor){
  return [
    Math.round(rgb[0]*factor),
    Math.round(rgb[1]*factor),
    Math.round(rgb[2]*factor),
  ];
}

/* ---------- agents ---------- */
function createAgent(x,y, role){
  const a = {
    id: Math.random().toString(36).slice(2, 8),
    x, y, vx:0, vy:0,
    energy: 0.65 + 0.25*Math.random(),
    maxEnergy: 1.50,

    role,                 // "external" or "internal"
    func: randChoice(FUNC),

    keys: [],
    memory: new Map(),    // voidId -> {obs:[]}
    pulse: 0,

    mode: null,           // "solve" or "harvest" (internal mostly solve)
    targetType: null,     // "void"|"energy"|null
    targetId: null,
    lockUntil: 0,
    lastScore: 0,

    // internal generation state
    gen: null,            // {voidId, cells:Int8Array, t:number, progress:number}
  };

  // External agents start with more common keys
  // Internal agents start with fewer but may have a random rare key
  if (a.role === "external"){
    for (let i=0;i<4;i++){
      const sid = randChoice(COMMON);
      if (!agentHasShape(a, sid)) a.keys.push(makeKey(sid));
    }
    if (Math.random() < 0.35){
      const {shapeId} = sampleShapeByDice();
      if (!agentHasShape(a, shapeId)) a.keys.push(makeKey(shapeId));
    }
  } else {
    for (let i=0;i<2;i++){
      const sid = randChoice(COMMON);
      if (!agentHasShape(a, sid)) a.keys.push(makeKey(sid));
    }
    // give internal one rarer seed more often
    if (Math.random() < 0.75){
      const {shapeId} = sampleShapeByDice();
      if (!agentHasShape(a, shapeId)) a.keys.push(makeKey(shapeId));
    }
  }
  ensureStorage(a);

  const low = parseFloat(UI.sELow.value);
  a.mode = (a.energy < low) ? "harvest" : "solve";
  return a;
}

/* ---------- world objects ---------- */
function spawnVoid(){
  const maxV = parseInt(UI.sVoidMax.value);
  if (voids.length >= maxV) return;

  // dice selects rarity
  const roll = dice2d6();
  const rarity = rarityFromRoll(roll);

  // number of sub-voids increases with rarity (harder)
  const subCount = 1 + (rarity > 0.35 ? 1 : 0) + (rarity > 0.70 ? 1 : 0) + (Math.random()<0.25 ? 1 : 0);

  let merged = new Int8Array(SHAPE_C);
  const subs = [];
  for (let i=0;i<subCount;i++){
    const pick = sampleShapeByDice();
    const shapeId = pick.shapeId;
    const cells = cloneCells(SHAPES[shapeId].cells);
    subs.push({shapeId, cells});
    merged = shapeOR(merged, cells);
  }

  const mass0 = Math.max(1, shapeMass(merged));

  // void radius tied to amount of work (mass0) + rarity
  // sqrt makes growth smoother
  const base = 0.025;
  const work = 0.060 * Math.sqrt(mass0 / SHAPE_C);
  const rareBoost = 0.020 * rarity;
  const r = base + work + rareBoost + 0.005*Math.random();

  voids.push({
    id: nextVoidId++,
    x: Math.random(),
    y: Math.random(),
    r,
    roll,
    rarity,
    subs,
    cells: merged,
    mass0,
    age: 0
  });
}

function spawnEnergy(){
  const maxE = parseInt(UI.sEMax.value);
  if (energySources.length >= maxE) return;

  // energy also follows entropy, but slightly biased toward common
  // (more common energy patterns in environment)
  let roll = dice2d6();
  if (Math.random() < 0.35) roll = 7; // bias
  const rarity = rarityFromRoll(roll);

  const {shapeId} = sampleShapeByDice();
  const amount = 0.55 + 0.65*Math.random();
  const r = 0.026 + 0.018*(rarity) + 0.010*Math.random();

  energySources.push({
    id: nextEnergyId++,
    x: Math.random(),
    y: Math.random(),
    r,
    roll,
    rarity,
    shapeId,
    cells: SHAPES[shapeId].cells,
    amount0: amount,
    amount: amount,
    age: 0
  });
}

function growVoid(v, dt){
  const g = parseFloat(UI.sVoidGrow.value);
  v.age += dt;
  // rare voids grow slightly more often
  const chance = g*dt*(0.25 + 0.8*v.rarity);
  if (Math.random() < chance){
    const sid = (Math.random()<0.65)
      ? v.subs[Math.floor(Math.random()*v.subs.length)].shapeId
      : sampleShapeByDice().shapeId;
    const src = SHAPES[sid].cells;
    const i = Math.floor(Math.random()*SHAPE_C);
    if (src[i]) v.cells[i] = 1;
  }
}

function harvestEnergy(e, key, dt){
  const m = matchKeyToPattern(key.cells, e.cells);
  const rate = parseFloat(UI.sHarvest.value);
  const take = Math.min(e.amount, rate * dt * (0.10 + 1.1*m.good));
  e.amount -= take;
  key.uses++;
  return {take, m};
}

function applyKeyToVoid(v, key, dt, agentSpend){
  const m = matchKeyToPattern(key.cells, v.cells);
  const areaB = shapeMass(v.cells);
  if (areaB <= 0) return {areaB, areaA: 0, m, spend:0};

  // spend increases when mismatch/spill
  const spend = agentSpend * dt * (0.35 + 1.2*(1-m.good) + 0.9*m.bad);
  key.uses++;

  // success chance scales with spend + goodness
  const p = clamp01((0.10 + 0.85*m.good) * spend * 2.8);

  const newCells = cloneCells(v.cells);
  for (let i=0;i<SHAPE_C;i++){
    if (v.cells[i] && key.cells[i]){
      if (Math.random() < p) newCells[i] = 0;
    }
  }

  // wrong key can sometimes worsen (adds a couple of cells)
  const worsenChance = clamp01(0.12*m.bad + 0.02*(m.spill/(m.mass+1e-6)));
  if (Math.random() < worsenChance * dt * 2.0){
    const sid = sampleShapeByDice().shapeId;
    const src = SHAPES[sid].cells;
    for (let k2=0;k2<2;k2++){
      const i = Math.floor(Math.random()*SHAPE_C);
      if (src[i]) newCells[i] = 1;
    }
  }

  v.cells = newCells;
  const areaA = shapeMass(v.cells);
  return {areaB, areaA, m, spend};
}

/* ---------- copying / signals / shards ---------- */
function emitSignal(agent, v, key, areaB, areaA){
  if (!UI.chkSignals.checked) return;
  const delta = areaB - areaA;
  signals.push({
    x: v.x, y: v.y,
    t: 0,
    ttl: 6.5,
    payload: {
      voidId: v.id,
      areaB,
      keyId: key.keyId,
      shapeId: key.shapeId,
      areaA,
      delta
    }
  });
  agent.pulse = 0.25;
}

function maybeDropShard(v, shapeId, delta){
  if (!UI.chkShards.checked) return;
  const need = parseInt(UI.sShardDelta.value);
  if (delta < need) return;
  const p = parseFloat(UI.sShardP.value);
  if (Math.random() > p) return;

  keyShards.push({
    id: Math.random().toString(36).slice(2, 9),
    x: v.x + (Math.random()*0.04-0.02),
    y: v.y + (Math.random()*0.04-0.02),
    r: 0.018,
    shapeId,
    ttl: 14 + 10*Math.random()
  });
}

function absorbSignals(agent){
  // You already have a "broadcast" channel; keep it.
  // Here, we just store observations and optionally copy shapes (costly, not shards).
  const hearR = 0.18;
  const copyCost = 0.22;

  for (const s of signals){
    const tv = torusVec(agent.x, agent.y, s.x, s.y);
    if (tv.d > hearR) continue;

    const p = s.payload;
    if (!agent.memory.has(p.voidId)) agent.memory.set(p.voidId, {obs:[]});
    const rec = agent.memory.get(p.voidId);
    rec.obs.push({keyId:p.keyId, shapeId:p.shapeId, areaB:p.areaB, areaA:p.areaA, delta:p.delta});

    // external more likely to copy common solutions
    const helpful = p.delta > 0;
    const desire = helpful ? (agent.role==="external" ? 0.90 : 0.55) : 0.15;

    if (!agentHasShape(agent, p.shapeId) && Math.random() < desire){
      if (agent.energy >= copyCost){
        agent.keys.push(makeKey(p.shapeId));
        agent.energy -= copyCost;
        ensureStorage(agent);
      }
    }
  }

  for (const [vid, rec] of agent.memory.entries()){
    if (rec.obs.length > 24) rec.obs.splice(0, rec.obs.length - 24);
  }
}

function pickupShards(agent){
  const cost = parseFloat(UI.sShardCost.value);
  for (let i=keyShards.length-1; i>=0; i--){
    const sh = keyShards[i];
    const tv = torusVec(agent.x, agent.y, sh.x, sh.y);
    if (tv.d < sh.r){
      // pickup
      if (!agentHasShape(agent, sh.shapeId) && agent.energy >= cost){
        agent.keys.push(makeKey(sh.shapeId));
        agent.energy -= cost;
        ensureStorage(agent);

        // chain reaction chance: drop a weaker shard nearby
        if (Math.random() < 0.18){
          keyShards.push({
            id: Math.random().toString(36).slice(2, 9),
            x: wrap01(agent.x + (Math.random()*0.05-0.025)),
            y: wrap01(agent.y + (Math.random()*0.05-0.025)),
            r: 0.016,
            shapeId: sh.shapeId,
            ttl: 8 + 6*Math.random()
          });
        }
      }
      keyShards.splice(i,1);
    }
  }
}

/* ---------- internal key generation ---------- */
function startGen(agent, voidObj){
  agent.gen = {
    voidId: voidObj.id,
    cells: new Int8Array(SHAPE_C), // start empty
    t: 0,
    progress: 0,
  };
}

function genStep(agent, voidObj, dt){
  const genCost = parseFloat(UI.sGenCost.value);
  const finishPct = parseFloat(UI.sGenFinish.value) / 100;
  const areaNow = shapeMass(voidObj.cells);
  if (areaNow <= 0) { agent.gen = null; return; }

  if (!agent.gen || agent.gen.voidId !== voidObj.id){
    startGen(agent, voidObj);
  }

  // spend energy steadily to learn
  const spend = Math.min(agent.energy, genCost * dt);
  agent.energy = Math.max(0, agent.energy - spend);
  agent.gen.t += dt;

  // learning rate scales with spend
  // each step: copy some random "1" cells from void into candidate key
  const attempts = 1 + Math.floor(12 * spend / (genCost*dt + 1e-6));
  let copied = 0;
  for (let k=0;k<attempts;k++){
    const i = Math.floor(Math.random()*SHAPE_C);
    if (voidObj.cells[i] && !agent.gen.cells[i]){
      // copy with probability also influenced by how long they've focused
      const p = clamp01(0.10 + 0.35*(spend/(genCost*dt+1e-6)) + 0.12*Math.tanh(agent.gen.t/3));
      if (Math.random() < p){
        agent.gen.cells[i] = 1;
        copied++;
      }
    }
  }

  const genMass = shapeMass(agent.gen.cells);
  agent.gen.progress = genMass / (areaNow + 1e-6);

  // finish: create a new library shape, add key to agent, drop shards
  if (agent.gen.progress >= finishPct && genMass >= 4){
    const sid = SHAPES.length;
    SHAPES.push({name:`gen(void#${voidObj.id})`, cells: agent.gen.cells, mass: genMass, tier: "rare"});
    agent.keys.push(makeKey(sid));
    ensureStorage(agent);

    // drop a shard of this newly learned key (memetic copy)
    keyShards.push({
      id: Math.random().toString(36).slice(2, 9),
      x: wrap01(voidObj.x + (Math.random()*0.04-0.02)),
      y: wrap01(voidObj.y + (Math.random()*0.04-0.02)),
      r: 0.018,
      shapeId: sid,
      ttl: 16 + 10*Math.random()
    });

    // optional: ‚Äúannounce‚Äù via signal
    signals.push({
      x: voidObj.x, y: voidObj.y,
      t: 0, ttl: 8.0,
      payload: { voidId: voidObj.id, areaB: areaNow, keyId: -1, shapeId: sid, areaA: areaNow, delta: 0 }
    });

    agent.pulse = 0.25;
    agent.gen = null;
    return true;
  }

  return false;
}

/* ---------- targeting & movement ---------- */
function getVoidById(id){ for (const v of voids) if (v.id === id) return v; return null; }
function getEnergyById(id){ for (const e of energySources) if (e.id === id) return e; return null; }
function getAgentById(id){ for (const a of agents) if (a.id === id) return a; return null; }

function scoreVoid(agent, v, sight){
  const tv = torusVec(agent.x, agent.y, v.x, v.y);
  if (tv.d > sight) return null;
  const kb = bestKey(agent, v.cells);
  const area = shapeMass(v.cells);
  const good = kb ? kb.m.good : 0;
  const score = (0.3 + area/v.mass0) * (0.25 + good) * (0.6 + 0.7*v.rarity) / (0.04 + tv.d);
  return {score, tv, kb, area};
}
function scoreEnergy(agent, e, sight){
  const tv = torusVec(agent.x, agent.y, e.x, e.y);
  if (tv.d > sight) return null;
  const kb = bestKey(agent, e.cells);
  const good = kb ? kb.m.good : 0;
  const score = (0.25 + e.amount) * (0.25 + good) / (0.04 + tv.d);
  return {score, tv, kb};
}

function chooseBestTarget(agent, type, sight){
  if (type === "void"){
    let best=null;
    for (const v of voids){
      const s = scoreVoid(agent, v, sight);
      if (!s) continue;
      if (!best || s.score > best.score) best = {type:"void", id:v.id, obj:v, score:s.score};
    }
    return best;
  }
  if (type === "energy"){
    let best=null;
    for (const e of energySources){
      const s = scoreEnergy(agent, e, sight);
      if (!s) continue;
      if (!best || s.score > best.score) best = {type:"energy", id:e.id, obj:e, score:s.score};
    }
    return best;
  }
  return null;
}

function updateAgentMode(agent){
  const low = parseFloat(UI.sELow.value);
  const high = parseFloat(UI.sEHigh.value);

  const lo = Math.min(low, high - 0.01);
  const hi = Math.max(high, low + 0.01);

  // internal agents stay in "solve" unless *really* low
  if (agent.role === "internal"){
    if (agent.energy < lo*0.8) agent.mode = "harvest";
    else if (agent.energy > hi*0.9) agent.mode = "solve";
    else if (!agent.mode) agent.mode = (agent.energy < lo*0.8) ? "harvest" : "solve";
    return;
  }

  // external hysteresis as usual
  if (agent.mode === "solve" && agent.energy < lo) agent.mode = "harvest";
  else if (agent.mode === "harvest" && agent.energy > hi) agent.mode = "solve";
  else if (!agent.mode) agent.mode = (agent.energy < lo) ? "harvest" : "solve";
}

function validateTarget(agent){
  if (!agent.targetType || agent.targetId == null) return null;
  if (agent.targetType === "void") return getVoidById(agent.targetId);
  if (agent.targetType === "energy") return getEnergyById(agent.targetId);
  return null;
}

function retargetIfNeeded(agent, sight){
  updateAgentMode(agent);

  const commit = parseFloat(UI.sCommit.value);
  const margin = parseFloat(UI.sMargin.value);

  const curObj = validateTarget(agent);
  if (!curObj){
    agent.targetType = null;
    agent.targetId = null;
    agent.lastScore = 0;
    agent.lockUntil = 0;
  }

  // internal: if currently generating on a void, keep that target
  if (agent.role === "internal" && agent.gen && agent.gen.voidId != null){
    const v = getVoidById(agent.gen.voidId);
    if (v){
      agent.targetType = "void";
      agent.targetId = v.id;
      agent.lockUntil = simTime + Math.max(0.6, commit*0.5);
      return;
    } else {
      agent.gen = null;
    }
  }

  if (!agent.targetType){
    const desiredType = (agent.mode === "harvest") ? "energy" : "void";
    const best = chooseBestTarget(agent, desiredType, sight);
    if (best){
      agent.targetType = best.type;
      agent.targetId = best.id;
      agent.lastScore = best.score;
      agent.lockUntil = simTime + commit;
    }
    return;
  }

  const critical = agent.energy < 0.12;
  if (!critical && simTime < agent.lockUntil) return;

  const desiredType = (agent.mode === "harvest") ? "energy" : "void";

  if (agent.targetType !== desiredType){
    const best = chooseBestTarget(agent, desiredType, sight);
    if (best){
      agent.targetType = best.type;
      agent.targetId = best.id;
      agent.lastScore = best.score;
      agent.lockUntil = simTime + commit;
    }
    return;
  }

  const best = chooseBestTarget(agent, desiredType, sight);
  if (!best) return;
  const curScore = agent.lastScore || 0;
  if (best.id !== agent.targetId && best.score > curScore * margin){
    agent.targetType = best.type;
    agent.targetId = best.id;
    agent.lastScore = best.score;
    agent.lockUntil = simTime + commit;
  } else {
    const cur = validateTarget(agent);
    if (cur){
      if (agent.targetType === "void"){
        const s = scoreVoid(agent, cur, sight);
        if (s) agent.lastScore = s.score;
      } else {
        const s = scoreEnergy(agent, cur, sight);
        if (s) agent.lastScore = s.score;
      }
    }
  }
}

function steerAgent(agent, target){
  // internal agents move slower (they tend to park and work)
  const accel = (agent.role==="internal") ? 1.10 : 1.60;
  const maxV  = (agent.role==="internal") ? 0.26 : 0.36;
  const damp  = 0.88;

  let dirx=0, diry=0;
  if (target){
    const tv = torusVec(agent.x, agent.y, target.x, target.y);
    const d = tv.d || 1e-6;
    dirx = tv.dx/d; diry = tv.dy/d;

    const r = target.r || 0.03;
    const close = clamp01((d - 0.18*r) / (0.82*r + 1e-6));
    dirx *= close; diry *= close;
  } else {
    const ang = Math.random()*Math.PI*2;
    dirx = Math.cos(ang); diry = Math.sin(ang);
  }

  // external agents explore more noise; internal less
  const noise = (agent.role==="external") ? 0.12 : 0.07;
  dirx += noise*randn();
  diry += noise*randn();
  const g = Math.hypot(dirx,diry) || 1e-6;
  dirx/=g; diry/=g;

  agent.vx += dirx * accel * dtSim;
  agent.vy += diry * accel * dtSim;

  const dd = Math.pow(damp, dtSim);
  agent.vx *= dd;
  agent.vy *= dd;

  const sp = Math.hypot(agent.vx, agent.vy);
  if (sp > maxV){
    const s = maxV / sp;
    agent.vx *= s; agent.vy *= s;
  }

  agent.x = wrap01(agent.x + agent.vx * dtSim);
  agent.y = wrap01(agent.y + agent.vy * dtSim);
}

/* ---------- selection / inspector ---------- */
function setSelection(type, id){
  selection.type = type;
  selection.id = id;
  refreshInspector();
}

function cellsToAscii(cells){
  let out = "";
  for (let y=0;y<SHAPE_N;y++){
    for (let x=0;x<SHAPE_N;x++){
      out += cells[idxS(x,y)] ? "‚ñà" : "¬∑";
    }
    out += "\n";
  }
  return out;
}

function recentSignalsForVoid(voidId, maxN=6){
  const xs = signals.filter(s => s.payload && s.payload.voidId === voidId);
  xs.sort((a,b)=> (a.t - b.t)); // smaller t => newer
  return xs.slice(0, maxN).map(s => s.payload);
}

function topAgentsForPattern(patternCells, topN=6){
  const scored = agents.map(a => {
    const kb = bestKey(a, patternCells);
    return { a, kb };
  }).filter(x => x.kb != null);
  scored.sort((x,y)=> y.kb.m.score - x.kb.m.score);
  return scored.slice(0, topN);
}

function refreshInspector(){
  const el = document.getElementById("inspectContent");
  if (!el) return;

  if (!selection.type){
    el.innerHTML = `<div class="tiny">Nothing selected.</div>`;
    return;
  }

  if (selection.type === "agent"){
    const a = getAgentById(selection.id);
    if (!a){
      el.innerHTML = `<div class="tiny warn">Selected agent no longer exists.</div>`;
      selection.type = null; selection.id = null;
      return;
    }

    const target = validateTarget(a);
    const lockLeft = Math.max(0, a.lockUntil - simTime);

    let matchInfo = "";
    if (target){
      const kb = bestKey(a, target.cells);
      if (kb){
        matchInfo = `
          <div style="margin-top:8px">
            <div class="pill">Best key vs current target</div>
            <div class="kv" style="margin-top:6px">
              <div>shapeId</div><div>${kb.k.shapeId} <span class="tiny">(${SHAPES[kb.k.shapeId]?.name ?? "?"})</span></div>
              <div>score</div><div>${kb.m.score.toFixed(3)} | good=${kb.m.good.toFixed(2)} | spill=${kb.m.spill}</div>
            </div>
          </div>
        `;
      }
    }

    const keysHtml = a.keys
      .slice()
      .sort((x,y)=> y.uses - x.uses)
      .map(k => {
        const nm = SHAPES[k.shapeId]?.name ?? "?";
        return `<div class="tiny mono">keyId=${k.keyId} shapeId=${k.shapeId} (${nm}) uses=${k.uses}</div>`;
      }).join("");

    const genHtml = (() => {
      if (!a.gen) return `<div class="tiny">Not generating a key right now.</div>`;
      const v = getVoidById(a.gen.voidId);
      const area = v ? shapeMass(v.cells) : 0;
      const genMass = shapeMass(a.gen.cells);
      return `
        <div class="kv">
          <div>void</div><div>#${a.gen.voidId} ${v ? "" : `<span class="warn">(gone)</span>`}</div>
          <div>progress</div><div>${(100*a.gen.progress).toFixed(1)}%</div>
          <div>learned cells</div><div>${genMass} / ${area || "?"}</div>
          <div>focus time</div><div>${a.gen.t.toFixed(1)}s</div>
        </div>
        <details style="margin-top:8px">
          <summary class="tiny">Candidate key pattern (7√ó7)</summary>
          <pre style="margin-top:8px">${cellsToAscii(a.gen.cells)}</pre>
        </details>
      `;
    })();

    el.innerHTML = `
      <div class="pill">Agent</div> <span class="mono">#${a.id}</span>
      <div class="kv" style="margin-top:8px">
        <div>role</div><div><span class="pill">${a.role}</span></div>
        <div>function</div><div><span class="pill">${a.func}</span> <span class="tiny">(color-coded)</span></div>
        <div>mode</div><div><span class="pill">${a.mode ?? "?"}</span></div>
        <div>energy</div><div>${a.energy.toFixed(2)} / ${a.maxEnergy.toFixed(2)}</div>
        <div>target</div><div>${a.targetType ? `${a.targetType} #${a.targetId}` : "none"}</div>
        <div>commit left</div><div>${lockLeft.toFixed(2)}s</div>
        <div>keys</div><div>${a.keys.length} (cap ${parseInt(UI.sKCap.value)})</div>
      </div>
      ${matchInfo}
      <div class="sep"></div>
      <details open>
        <summary class="tiny">Keys (sorted by uses)</summary>
        <div style="margin-top:8px">${keysHtml || `<div class="tiny warn">No keys.</div>`}</div>
      </details>
      <div class="sep"></div>
      <details ${a.role==="internal" ? "open" : ""}>
        <summary class="tiny">Internal generation</summary>
        <div style="margin-top:8px">${genHtml}</div>
      </details>
    `;
    return;
  }

  if (selection.type === "void"){
    const v = getVoidById(selection.id);
    if (!v){
      el.innerHTML = `<div class="tiny warn">Selected void no longer exists (solved or removed).</div>`;
      selection.type = null; selection.id = null;
      return;
    }

    const area = shapeMass(v.cells);
    const pct = 100 * area / (v.mass0 + 1e-6);

    const subs = v.subs.map(s => {
      const nm = SHAPES[s.shapeId]?.name ?? "?";
      return `<div class="tiny mono">shapeId=${s.shapeId} (${nm})</div>`;
    }).join("");

    const top = topAgentsForPattern(v.cells, 6);
    const topHtml = top.map(t => {
      const nm = SHAPES[t.kb.k.shapeId]?.name ?? "?";
      const score = t.kb.m.score;
      const cls = score > 0.25 ? "good" : (score < -0.25 ? "bad" : "");
      return `<div class="tiny mono ${cls}">agent #${t.a.id} (${t.a.role}/${t.a.func}): best shapeId=${t.kb.k.shapeId} (${nm}) score=${score.toFixed(3)} good=${t.kb.m.good.toFixed(2)}</div>`;
    }).join("");

    const sigs = recentSignalsForVoid(v.id, 6);
    const sigHtml = sigs.map(p => {
      const nm = SHAPES[p.shapeId]?.name ?? "?";
      const cls = (p.delta > 0) ? "good" : (p.delta < 0 ? "bad" : "");
      return `<div class="tiny mono ${cls}">shapeId=${p.shapeId} (${nm}) area: ${p.areaB} ‚Üí ${p.areaA} (Œî=${p.delta})</div>`;
    }).join("");

    el.innerHTML = `
      <div class="pill">Void (Lock)</div> <span class="mono">#${v.id}</span>
      <div class="kv" style="margin-top:8px">
        <div>2d6 roll</div><div>${v.roll} <span class="tiny">(7 common, 2/12 rare)</span></div>
        <div>rarity</div><div>${v.rarity.toFixed(2)}</div>
        <div>radius</div><div>${v.r.toFixed(3)} <span class="tiny">(work size)</span></div>
        <div>age</div><div>${v.age.toFixed(1)}s</div>
        <div>area</div><div>${area} / ${v.mass0} <span class="${pct<=20 ? "good" : ""}">(${pct.toFixed(1)}%)</span></div>
      </div>

      <details style="margin-top:10px" open>
        <summary class="tiny">Pattern (7√ó7 remaining void cells)</summary>
        <pre style="margin-top:8px">${cellsToAscii(v.cells)}</pre>
      </details>

      <details style="margin-top:10px">
        <summary class="tiny">Sub-void components</summary>
        <div style="margin-top:8px">${subs || `<div class="tiny warn">No subs.</div>`}</div>
      </details>

      <details style="margin-top:10px" open>
        <summary class="tiny">Top matching agents (best key score)</summary>
        <div style="margin-top:8px">${topHtml || `<div class="tiny warn">No agents.</div>`}</div>
      </details>

      <details style="margin-top:10px">
        <summary class="tiny">Recent signals (attempts on this void)</summary>
        <div style="margin-top:8px">${sigHtml || `<div class="tiny">No signals yet.</div>`}</div>
      </details>
    `;
    return;
  }

  if (selection.type === "energy"){
    const e = getEnergyById(selection.id);
    if (!e){
      el.innerHTML = `<div class="tiny warn">Selected energy source no longer exists (depleted).</div>`;
      selection.type = null; selection.id = null;
      return;
    }
    const nm = SHAPES[e.shapeId]?.name ?? "?";
    const pct = 100 * e.amount / (e.amount0 + 1e-6);

    const top = topAgentsForPattern(e.cells, 6);
    const topHtml = top.map(t => {
      const nm2 = SHAPES[t.kb.k.shapeId]?.name ?? "?";
      const score = t.kb.m.score;
      const cls = score > 0.25 ? "good" : (score < -0.25 ? "bad" : "");
      return `<div class="tiny mono ${cls}">agent #${t.a.id} (${t.a.role}/${t.a.func}): best shapeId=${t.kb.k.shapeId} (${nm2}) score=${score.toFixed(3)} good=${t.kb.m.good.toFixed(2)}</div>`;
    }).join("");

    el.innerHTML = `
      <div class="pill">Energy Source</div> <span class="mono">#${e.id}</span>
      <div class="kv" style="margin-top:8px">
        <div>2d6 roll</div><div>${e.roll} <span class="tiny">(7 common, 2/12 rare)</span></div>
        <div>shape</div><div>${e.shapeId} <span class="tiny">(${nm})</span></div>
        <div>rarity</div><div>${e.rarity.toFixed(2)}</div>
        <div>radius</div><div>${e.r.toFixed(3)}</div>
        <div>amount</div><div>${e.amount.toFixed(2)} / ${e.amount0.toFixed(2)} <span class="${pct<25 ? "warn" : ""}">(${pct.toFixed(1)}%)</span></div>
        <div>age</div><div>${e.age.toFixed(1)}s</div>
      </div>

      <details style="margin-top:10px" open>
        <summary class="tiny">Pattern (7√ó7)</summary>
        <pre style="margin-top:8px">${cellsToAscii(e.cells)}</pre>
      </details>

      <details style="margin-top:10px" open>
        <summary class="tiny">Top matching agents (best key score)</summary>
        <div style="margin-top:8px">${topHtml || `<div class="tiny warn">No agents.</div>`}</div>
      </details>
    `;
    return;
  }

  el.innerHTML = `<div class="tiny">Unknown selection.</div>`;
}

/* ---------- simulation reset ---------- */
function resetAll(){
  paused = false;
  simTime = 0;
  UI.btnPause.textContent = "Pause";

  nextVoidId = 1;
  nextKeyId = 1;
  nextEnergyId = 1;
  voids = [];
  energySources = [];
  signals = [];
  keyShards = [];
  trails.clear();

  selection = { type: null, id: null };

  initShapes();

  agents = [];
  const n = parseInt(UI.sAgents.value);
  const internalPct = parseInt(UI.sInternalPct.value)/100;

  for (let i=0;i<n;i++){
    const role = (Math.random() < internalPct) ? "internal" : "external";
    agents.push(createAgent(Math.random(), Math.random(), role));
  }

  refreshInspector();
}

/* ---------- main update loop ---------- */
function updateSim(dt){
  dtSim = dt;
  simTime += dt;

  // spawns
  const vRate = parseFloat(UI.sVoidRate.value)/60;
  const eRate = parseFloat(UI.sERate.value)/60;
  if (Math.random() < vRate*dt) spawnVoid();
  if (Math.random() < eRate*dt) spawnEnergy();

  // growth/aging
  for (const v of voids) growVoid(v, dt);
  for (const e of energySources) e.age += dt;
  energySources = energySources.filter(e => e.amount > 0.01);

  // signals age
  for (const s of signals) s.t += dt;
  signals = signals.filter(s => s.t < s.ttl);

  // shards age
  for (const sh of keyShards) sh.ttl -= dt;
  keyShards = keyShards.filter(sh => sh.ttl > 0);

  // agents
  const spend = parseFloat(UI.sSpend.value);
  const sight = 0.26;
  const genThr = parseFloat(UI.sGenThr.value);

  for (const a of agents){
    absorbSignals(a);

    retargetIfNeeded(a, sight);

    const target = validateTarget(a);
    steerAgent(a, target);

    pickupShards(a);

    if (target && a.targetType === "energy"){
      const tv = torusVec(a.x, a.y, target.x, target.y);
      if (tv.d < target.r){
        const kb = bestKey(a, target.cells);
        if (kb){
          const {take} = harvestEnergy(target, kb.k, dt);
          a.energy = Math.min(a.maxEnergy, a.energy + take);
        }
      }
    }

    if (target && a.targetType === "void"){
      const v = target;
      const tv = torusVec(a.x, a.y, v.x, v.y);

      // internal: if close to void and key fit is weak => generate key
      if (a.role === "internal" && tv.d < v.r*1.05){
        const kb = bestKey(a, v.cells);
        const good = kb ? kb.m.good : 0;
        if (good < genThr && a.energy > 0.02){
          genStep(a, v, dt);
        } else {
          // if good enough, stop generating
          if (a.gen && a.gen.voidId === v.id) a.gen = null;
        }
      }

      // apply key to void (both roles)
      if (tv.d < v.r && a.energy > 0.02){
        const kb = bestKey(a, v.cells);
        if (kb){
          const agentSpend = Math.min(a.energy, spend);
          const res = applyKeyToVoid(v, kb.k, dt, agentSpend);
          a.energy = Math.max(0, a.energy - (res.spend ?? 0));
          emitSignal(a, v, kb.k, res.areaB, res.areaA);

          const delta = (res.areaB - res.areaA) || 0;
          maybeDropShard(v, kb.k.shapeId, delta);
        }
      }
    }

    // trails + pulse decay
    if (UI.chkTrails.checked){
      trails.noStroke();
      trails.fill(235,235,255,28);
      trails.circle(a.x*W, a.y*H, 2.2);
    }
    a.pulse = Math.max(0, a.pulse - dt);
  }

  // solve threshold
  const thrPct = parseFloat(UI.sSolveThr.value)/100;
  voids = voids.filter(v => (shapeMass(v.cells) / (v.mass0+1e-6)) > thrPct);

  // selection validity check
  if (selection.type === "void" && selection.id != null && !getVoidById(selection.id)){
    selection.type = null; selection.id = null; refreshInspector();
  }
  if (selection.type === "energy" && selection.id != null && !getEnergyById(selection.id)){
    selection.type = null; selection.id = null; refreshInspector();
  }
  if (selection.type === "agent" && selection.id != null && !getAgentById(selection.id)){
    selection.type = null; selection.id = null; refreshInspector();
  }

  // gentle trail fade
  if (UI.chkTrails.checked){
    trails.push();
    trails.erase(12,12);
    trails.rect(0,0,W,H);
    trails.noErase();
    trails.pop();
  }

  // cap counts
  const maxV = parseInt(UI.sVoidMax.value);
  if (voids.length > maxV) voids.length = maxV;
  const maxE = parseInt(UI.sEMax.value);
  if (energySources.length > maxE) energySources.length = maxE;
}

/* ---------- rendering ---------- */
function drawPatternStamp(x, y, rPx, cells, rgb, alpha=140){
  const stamp = rPx*2;
  const cell = stamp / SHAPE_N;
  const ox = x - stamp/2;
  const oy = y - stamp/2;

  noStroke();
  for (let yy=0; yy<SHAPE_N; yy++){
    for (let xx=0; xx<SHAPE_N; xx++){
      const i = idxS(xx,yy);
      if (!cells[i]) continue;
      fill(rgb[0], rgb[1], rgb[2], alpha);
      rect(ox + xx*cell, oy + yy*cell, cell*0.92, cell*0.92, 2);
    }
  }
}

function drawSelectionRing(px, py, rPx){
  noFill();
  stroke(255, 255, 255, 230);
  strokeWeight(2);
  circle(px, py, Math.max(18, rPx*2.4));
}

function draw(){
  background(12,14,18);

  const speed = parseFloat(UI.sSpeed.value);
  const dt = (deltaTime/1000) * speed;

  if (!paused) updateSim(dt);

  if (UI.chkTrails.checked) image(trails, 0,0);

  // energy sources
  for (const e of energySources){
    const px = e.x*W, py = e.y*H;
    const rPx = e.r*Math.min(W,H);
    const a = 60 + 180*(e.amount/(e.amount0+1e-6));
    drawPatternStamp(px, py, rPx, e.cells, [120,255,140], 95);
    noFill();
    stroke(120,255,140,a);
    strokeWeight(2);
    circle(px,py, rPx*2.1);

    noStroke();
    fill(240,240,255,170);
    textSize(10);
    textAlign(CENTER, CENTER);
    text(e.roll, px, py - rPx*1.25);

    if (selection.type === "energy" && selection.id === e.id){
      drawSelectionRing(px, py, rPx);
    }
  }

  // voids
  for (const v of voids){
    const px = v.x*W, py = v.y*H;
    const rPx = v.r*Math.min(W,H);
    const area = shapeMass(v.cells);
    const sev = clamp01(area/(v.mass0+1e-6));
    const a = 70 + 180*sev;

    drawPatternStamp(px, py, rPx, v.cells, [255,110,110], 110);
    noFill();
    stroke(255,110,110,a);
    strokeWeight(2);
    circle(px,py, rPx*(2.0 + 0.9*sev));

    noStroke();
    fill(255,255,255,200);
    textSize(11);
    textAlign(CENTER, CENTER);
    text("#"+v.id, px, py + rPx*1.38);

    noStroke();
    fill(240,240,255,170);
    textSize(10);
    text(v.roll, px, py - rPx*1.25);

    if (selection.type === "void" && selection.id === v.id){
      drawSelectionRing(px, py, rPx);
    }
  }

  // key shards
  if (UI.chkShards.checked){
    for (const sh of keyShards){
      const px = sh.x*W, py = sh.y*H;
      const rPx = sh.r*Math.min(W,H);
      const nm = SHAPES[sh.shapeId]?.name ?? "?";

      // little diamond
      push();
      translate(px, py);
      rotate(Math.PI/4);
      noStroke();
      fill(160, 210, 255, 220);
      rectMode(CENTER);
      rect(0,0, rPx*1.5, rPx*1.5, 3);
      pop();

      noFill();
      stroke(160,210,255,140);
      strokeWeight(1.5);
      circle(px,py, rPx*3);

      noStroke();
      fill(230,235,255,160);
      textSize(9);
      textAlign(CENTER, CENTER);
      text(nm.slice(0,4), px, py + rPx*2.2);
    }
  }

  // signals (ripples)
  if (UI.chkSignals.checked){
    for (const s of signals){
      const px = s.x*W, py = s.y*H;
      const wave = (s.t*0.9)%1.0;
      const r = (0.02 + 0.14*wave)*Math.min(W,H);
      const a = Math.max(0, 170*(1-wave));

      const delta = s.payload.delta || 0;
      // green if helped, orange if not
      const t = clamp01(delta / 5);
      const R = Math.round(255*(1 - 0.55*t) + 110*(t));
      const G = Math.round(170*(t) + 130*(1-t));
      const B = Math.round(90*(1 - t) + 120*(t));

      noFill();
      stroke(R,G,B,a);
      strokeWeight(1.5);
      circle(px,py,r*2);
    }
  }

  // agents
  for (const a of agents){
    const px = a.x*W, py = a.y*H;

    const base = funcColor(a.func);

    // external lighter, internal darker
    const roleShade = (a.role === "external") ? 1.05 : 0.70;
    let col = shade(base, roleShade);

    // energy affects brightness
    const eT = clamp01(a.energy/(a.maxEnergy+1e-6));
    col = mixRGB(shade(col, 0.55), shade(col, 1.25), eT);

    noStroke();
    fill(col[0], col[1], col[2], 245);
    circle(px,py, 8.0);

    // internal generation halo
    if (a.gen){
      noFill();
      stroke(col[0], col[1], col[2], 180);
      strokeWeight(2);
      circle(px,py, 18 + 12*Math.sin(simTime*3));
    }

    if (a.pulse > 0){
      noFill();
      stroke(255,230,120,220*a.pulse/0.25);
      strokeWeight(2);
      circle(px,py, 16 + 24*(1 - a.pulse/0.25));
    }

    noStroke();
    fill(255,255,255,190);
    textSize(10);
    textAlign(CENTER, CENTER);
    const label = (a.mode === "harvest") ? "H" : "S";
    text(label, px, py - 12);

    // tiny role label
    fill(255,255,255,140);
    textSize(9);
    text(a.role==="external" ? "E" : "I", px, py + 12);

    if (selection.type === "agent" && selection.id === a.id){
      drawSelectionRing(px, py, 10);
    }
  }

  renderMetrics();

  // keep inspector live-updated (light cadence)
  if (selection.type && frameCount % 10 === 0) refreshInspector();
}

function renderMetrics(){
  let avgE=0, avgK=0;
  let nI=0, nE=0;
  for (const a of agents){
    avgE += a.energy;
    avgK += a.keys.length;
    if (a.role==="internal") nI++; else nE++;
  }
  avgE = agents.length ? avgE/agents.length : 0;
  avgK = agents.length ? avgK/agents.length : 0;

  const el = document.getElementById("metrics");
  el.innerHTML = `
    <div><b>Agents</b>: ${agents.length} (I:${nI} / E:${nE}) | <b>Voids</b>: ${voids.length} | <b>Energy</b>: ${energySources.length} | <b>Shards</b>: ${keyShards.length}</div>
    <div><b>Avg energy</b>: ${avgE.toFixed(2)} / 1.50 | <b>Avg keys</b>: ${avgK.toFixed(1)} (cap ${parseInt(UI.sKCap.value)})</div>
    <div class="tiny">Library size: ${SHAPES.length} | time: ${simTime.toFixed(1)} | fps: ${Math.round(frameRate())}</div>
  `;
}

/* ---------- mouse selection ---------- */
function mousePressed(){
  if (mouseX < 0 || mouseX > W || mouseY < 0 || mouseY > H) return;

  let best = null; // {type,id,scorePx}
  const consider = (type, id, scorePx) => {
    if (scorePx == null || !isFinite(scorePx)) return;
    if (!best || scorePx < best.scorePx) best = {type, id, scorePx};
  };

  // Agents
  for (const a of agents){
    const px = a.x*W, py = a.y*H;
    const d = dist(mouseX, mouseY, px, py);
    if (d <= 14) consider("agent", a.id, d);
  }

  // Voids
  for (const v of voids){
    const px = v.x*W, py = v.y*H;
    const rPx = v.r*Math.min(W,H) * 1.25;
    const d = dist(mouseX, mouseY, px, py);
    if (d <= Math.max(18, rPx)) consider("void", v.id, d);
  }

  // Energy
  for (const e of energySources){
    const px = e.x*W, py = e.y*H;
    const rPx = e.r*Math.min(W,H) * 1.25;
    const d = dist(mouseX, mouseY, px, py);
    if (d <= Math.max(18, rPx)) consider("energy", e.id, d);
  }

  if (best) setSelection(best.type, best.id);
  else setSelection(null, null);
}

/* ---------- setup / UI ---------- */
function setup(){
  W = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
  H = windowHeight;
  createCanvas(W,H);

  trails = createGraphics(W,H);
  trails.clear();

  hookUI();
  resetAll();
  frameRate(60);
}

function windowResized(){
  W = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
  H = windowHeight;
  resizeCanvas(W,H);
  trails = createGraphics(W,H);
  trails.clear();
}

function hookUI(){
  UI.btnPause = document.getElementById("btnPause");
  UI.btnReset = document.getElementById("btnReset");

  UI.sSpeed  = document.getElementById("sSpeed");
  UI.sAgents = document.getElementById("sAgents");
  UI.sInternalPct = document.getElementById("sInternalPct");
  UI.sKCap   = document.getElementById("sKCap");
  UI.chkTrails = document.getElementById("chkTrails");
  UI.chkSignals = document.getElementById("chkSignals");
  UI.chkShards = document.getElementById("chkShards");

  UI.sELow  = document.getElementById("sELow");
  UI.sEHigh = document.getElementById("sEHigh");
  UI.sCommit = document.getElementById("sCommit");
  UI.sMargin = document.getElementById("sMargin");

  UI.sVoidRate = document.getElementById("sVoidRate");
  UI.sVoidMax  = document.getElementById("sVoidMax");
  UI.sVoidGrow = document.getElementById("sVoidGrow");
  UI.sSolveThr = document.getElementById("sSolveThr");

  UI.sERate    = document.getElementById("sERate");
  UI.sEMax     = document.getElementById("sEMax");
  UI.sHarvest  = document.getElementById("sHarvest");
  UI.sSpend    = document.getElementById("sSpend");

  UI.sGenThr = document.getElementById("sGenThr");
  UI.sGenCost = document.getElementById("sGenCost");
  UI.sGenFinish = document.getElementById("sGenFinish");

  UI.sShardDelta = document.getElementById("sShardDelta");
  UI.sShardP = document.getElementById("sShardP");
  UI.sShardCost = document.getElementById("sShardCost");

  const refresh = ()=>{
    document.getElementById("lblSpeed").textContent = parseFloat(UI.sSpeed.value).toFixed(2);
    document.getElementById("lblAgents").textContent = parseInt(UI.sAgents.value);
    document.getElementById("lblInternal").textContent = parseInt(UI.sInternalPct.value);
    document.getElementById("lblKCap").textContent = parseInt(UI.sKCap.value);

    document.getElementById("lblELow").textContent = parseFloat(UI.sELow.value).toFixed(2);
    document.getElementById("lblEHigh").textContent = parseFloat(UI.sEHigh.value).toFixed(2);
    document.getElementById("lblCommit").textContent = parseFloat(UI.sCommit.value).toFixed(1);
    document.getElementById("lblMargin").textContent = parseFloat(UI.sMargin.value).toFixed(2);

    document.getElementById("lblVoidRate").textContent = parseInt(UI.sVoidRate.value);
    document.getElementById("lblVoidMax").textContent = parseInt(UI.sVoidMax.value);
    document.getElementById("lblVoidGrow").textContent = parseFloat(UI.sVoidGrow.value).toFixed(2);
    document.getElementById("lblSolveThr").textContent = parseInt(UI.sSolveThr.value);

    document.getElementById("lblERate").textContent = parseInt(UI.sERate.value);
    document.getElementById("lblEMax").textContent = parseInt(UI.sEMax.value);
    document.getElementById("lblHarvest").textContent = parseFloat(UI.sHarvest.value).toFixed(2);
    document.getElementById("lblSpend").textContent = parseFloat(UI.sSpend.value).toFixed(2);

    document.getElementById("lblGenThr").textContent = parseFloat(UI.sGenThr.value).toFixed(2);
    document.getElementById("lblGenCost").textContent = parseFloat(UI.sGenCost.value).toFixed(2);
    document.getElementById("lblGenFinish").textContent = parseInt(UI.sGenFinish.value);

    document.getElementById("lblShardDelta").textContent = parseInt(UI.sShardDelta.value);
    document.getElementById("lblShardP").textContent = parseFloat(UI.sShardP.value).toFixed(2);
    document.getElementById("lblShardCost").textContent = parseFloat(UI.sShardCost.value).toFixed(2);

    refreshInspector();
  };
  refresh();

  ["input","change"].forEach(evt=>{
    [
      UI.sSpeed, UI.sAgents, UI.sInternalPct, UI.sKCap,
      UI.sELow, UI.sEHigh, UI.sCommit, UI.sMargin,
      UI.sVoidRate, UI.sVoidMax, UI.sVoidGrow, UI.sSolveThr,
      UI.sERate, UI.sEMax, UI.sHarvest, UI.sSpend,
      UI.sGenThr, UI.sGenCost, UI.sGenFinish,
      UI.sShardDelta, UI.sShardP, UI.sShardCost
    ].forEach(el => el.addEventListener(evt, refresh));
  });

  UI.btnPause.addEventListener("click", ()=>{
    paused = !paused;
    UI.btnPause.textContent = paused ? "Resume" : "Pause";
  });
  UI.btnReset.addEventListener("click", ()=> resetAll());

  UI.sAgents.addEventListener("input", ()=>{
    resetAll();
  });
  UI.sInternalPct.addEventListener("input", ()=>{
    resetAll();
  });

  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space"){ paused = !paused; UI.btnPause.textContent = paused ? "Resume" : "Pause"; e.preventDefault(); }
    if (e.key.toLowerCase() === "r"){ resetAll(); }
    if (e.key.toLowerCase() === "v"){ spawnVoid(); refreshInspector(); }
    if (e.key.toLowerCase() === "e"){ spawnEnergy(); refreshInspector(); }
  });
}

/* ---------- randn ---------- */
let spare = null;
function randn(){
  if (spare !== null){ const v = spare; spare = null; return v; }
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  const mag=Math.sqrt(-2*Math.log(u));
  const z0=mag*Math.cos(TWO_PI*v);
  const z1=mag*Math.sin(TWO_PI*v);
  spare=z1; return z0;
}
</script>

</body>
</html>
