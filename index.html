<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BCM Spectrum Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
  <script src="simulation.js"></script>
  <style>
    body { margin: 0; background:#0b0f14; color:#e8eef6; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; overflow: hidden; }
    .panel { position: fixed; left: 10px; top: 10px; width: 380px; background: rgba(10,14,20,0.92); border: 1px solid rgba(255,255,255,0.08);
             border-radius: 10px; padding: 12px 12px 10px; backdrop-filter: blur(8px); max-height: calc(100vh - 40px); overflow-y: auto; }
    .row { display:flex; justify-content:space-between; gap:10px; align-items:center; margin: 6px 0; }
    .row label { font-size: 12px; opacity: 0.9; flex-shrink: 0; }
    .row .val { font-size: 12px; opacity: 0.85; min-width: 50px; text-align:right; }
    .row input[type="range"] { flex: 1; max-width: 180px; }
    .btns { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
    button { background:#1b2432; color:#e8eef6; border:1px solid rgba(255,255,255,0.12); border-radius:8px; padding:7px 12px; cursor:pointer; font-size: 12px; }
    button:hover { background:#243247; }
    button:active { background:#2d3d52; }
    .hint { font-size: 11px; opacity: 0.75; line-height: 1.4; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .section-title { font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; opacity: 0.6; margin: 12px 0 6px; }
    .inspector {
      margin-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.10);
      padding-top: 10px;
    }
    .inspector h3 {
      margin: 0 0 8px;
      font-size: 11px;
      letter-spacing: 0.02em;
      opacity: 0.8;
      text-transform: uppercase;
    }
    .inspector pre {
      margin: 0;
      max-height: 200px;
      overflow: auto;
      font-size: 10px;
      line-height: 1.35;
      padding: 8px;
      border-radius: 6px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
      white-space: pre-wrap;
      word-break: break-word;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div class="panel" id="ui"></div>

<script>
/**
 * BCM Spectrum Simulator - Visual Layer
 * Uses simulation.js for core logic
 */

// ========================
// State
// ========================

let sim = null;
let explosions = [];
let paused = false;
let showHud = true;

// UI elements
let sliders = {};
let btnPause, btnReset, btnHud, btnDownload;

// Inspector state
let inspectorPre = null;
let selectedType = null;
let selectedId = null;

// Config (local copy for UI binding, plus visual-specific settings)
let CFG = {
  ...BCMSimulator.DEFAULT_CFG,
  // Visual settings not in simulation module
  backgroundFade: 28,
  drawTrails: false,
  ticksPerFrame: 6,
  telemetryBins: 36,
  vaultKeyTTLBoost: 1.35,
  enableModes: true
};

// ========================
// p5.js Setup
// ========================

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  noStroke();
  initUI();
  initSimulation();
  background(220, 35, 8);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function initSimulation() {
  sim = new BCMSimulator.Simulation(CFG);
  sim.init();
  explosions = [];
  paused = false;
  btnPause.html("Pause");
  selectedType = null;
  selectedId = null;
  renderInspector();
}

// ========================
// Main Draw Loop
// ========================

function draw() {
  // Background fade
  fill(220, 35, 8, CFG.backgroundFade / 255);
  rect(0, 0, width, height);

  // Run simulation
  if (!paused) {
    for (let i = 0; i < CFG.ticksPerFrame; i++) {
      sim.stepTick();
      if (sim.lastExplosions && sim.lastExplosions.length) {
        for (const v of sim.lastExplosions) {
          spawnExplosion(v);
        }
        sim.lastExplosions.length = 0;
      }
    }
  }

  // Update explosion ages
  for (const e of explosions) e.age += 1;
  explosions = explosions.filter(e => e.age < e.life);

  // Draw voids
  drawVoids();

  // Draw explosions
  drawExplosions();

  // Draw agents
  drawAgents();

  // Draw selection highlight
  drawSelection();

  // Draw HUD
  if (showHud) {
    drawHUD();
  }

  // Apply UI changes
  applyUI();
}

// ========================
// Drawing Functions
// ========================

function drawVoids() {
  for (const v of sim.voids) {
    if (v.state !== "active") continue;

    const px = map(v.x, 0, CFG.arenaSize, 0, width);
    const py = map(v.y, 0, CFG.arenaSize, 0, height);
    const hue = v.val;
    const urg = v.urgency();
    const bright = BCMSimulator.clamp(30 + urg / 2, 30, 100);

    // Draw X shape for voids
    stroke(hue, 80, bright, 0.9);
    strokeWeight(2);
    line(px - 6, py - 6, px + 6, py + 6);
    line(px - 6, py + 6, px + 6, py - 6);
    noStroke();
  }
}

function spawnExplosion(v) {
  const sparks = [];
  const sparkCount = 18;
  for (let i = 0; i < sparkCount; i++) {
    sparks.push({
      a: Math.random() * TWO_PI,
      r: 0.35 + Math.random() * 0.85,
      w: 0.6 + Math.random() * 1.8,
      delay: Math.random() * 0.18
    });
  }

  explosions.push({
    x: v.x,
    y: v.y,
    age: 0,
    life: 36,
    hue: v.val,
    sparks
  });
}

function drawExplosions() {
  if (!explosions.length) return;
  const maxR = map(CFG.blastRadius, 0, CFG.arenaSize, 0, Math.min(width, height));

  for (const e of explosions) {
    const px = map(e.x, 0, CFG.arenaSize, 0, width);
    const py = map(e.y, 0, CFG.arenaSize, 0, height);
    const t = BCMSimulator.clamp(e.age / e.life, 0, 1);
    const te = easeOutCubic(t);
    const ringR = lerp(8, maxR, te);

    push();
    blendMode(ADD);

    // Expanding glow
    noStroke();
    fill(e.hue, 80, 100, 0.38 * (1 - t));
    circle(px, py, ringR * 2.1);

    // Shock ring
    stroke(e.hue, 40, 100, 0.6 * (1 - t));
    strokeWeight(2 + 3 * (1 - t));
    noFill();
    circle(px, py, ringR * 2);

    // Core flash
    noStroke();
    fill(0, 0, 100, 0.7 * (1 - t));
    circle(px, py, lerp(22, 4, te));

    // Sparks
    stroke(e.hue, 90, 100, 0.8 * (1 - t));
    for (const s of e.sparks) {
      const sp = (t - s.delay) / (1 - s.delay);
      if (sp <= 0) continue;
      const tt = BCMSimulator.clamp(sp, 0, 1);
      const len = maxR * s.r * tt;
      const sx = px + Math.cos(s.a) * (len * 0.2);
      const sy = py + Math.sin(s.a) * (len * 0.2);
      const ex = px + Math.cos(s.a) * len;
      const ey = py + Math.sin(s.a) * len;
      strokeWeight(s.w * (1 - tt));
      line(sx, sy, ex, ey);
    }

    pop();
  }
}

function drawAgents() {
  for (const a of sim.agents) {
    if (!a.alive) continue;

    const px = map(a.x, 0, CFG.arenaSize, 0, width);
    const py = map(a.y, 0, CFG.arenaSize, 0, height);

    // Calculate stress level from remembered voids
    let maxUrg = 0;
    for (const m of a.voidMem) maxUrg = Math.max(maxUrg, m.urgency || 0);
    const t = BCMSimulator.clamp(maxUrg / 100.0, 0, 1);

    // Hue: blue (calm) -> red (stressed)
    const hue = lerpHue(220, 0, t);
    const alpha = a.sleeping ? 0.25 : 0.75;

    // Mode affects saturation and brightness
    const sat = a.sleeping ? 10 : (a.mode === "vault" ? 55 : 75);
    const bri = a.sleeping ? 70 : (a.mode === "vault" ? 85 : 92);

    fill(hue, sat, bri, alpha);
    circle(px, py, a.sleeping ? 7 : 9);

    // Mode indicator - distinct shapes for visibility
    if (!a.sleeping) {
      if (a.mode === "vault") {
        // Green diamond for vault (key storage)
        fill(140, 80, 95, 1.0);
        stroke(140, 90, 60, 1.0);
        strokeWeight(1);
        push();
        translate(px + 8, py - 8);
        rotate(PI / 4);
        rectMode(CENTER);
        rect(0, 0, 6, 6);
        pop();
        noStroke();
      } else {
        // Orange/yellow circle for router (information sharing)
        fill(35, 90, 100, 1.0);
        stroke(25, 100, 70, 1.0);
        strokeWeight(1);
        circle(px + 8, py - 8, 7);
        noStroke();
      }
    }
  }
}

function drawSelection() {
  if (selectedType === "agent") {
    const a = sim.agents.find(x => x.id === selectedId);
    if (a) {
      const px = map(a.x, 0, CFG.arenaSize, 0, width);
      const py = map(a.y, 0, CFG.arenaSize, 0, height);
      noFill();
      stroke(0, 0, 100, 0.9);
      strokeWeight(2);
      circle(px, py, 18);
      noStroke();
    }
  } else if (selectedType === "void") {
    const v = sim.voidMap.get(selectedId);
    if (v && v.state === "active") {
      const px = map(v.x, 0, CFG.arenaSize, 0, width);
      const py = map(v.y, 0, CFG.arenaSize, 0, height);
      noFill();
      stroke(0, 0, 100, 0.9);
      strokeWeight(2);
      circle(px, py, 22);
      noStroke();
    }
  }
}

function drawHUD() {
  const pop = sim.agents.length;
  const voids = sim.voids.filter(v => v.state === "active").length;
  const active = sim.agents.filter(a => a.alive && !a.sleeping).length;
  const vaults = sim.agents.filter(a => a.mode === "vault").length;
  const routers = sim.agents.filter(a => a.mode === "router").length;

  const ent = sim.computeEntropyProxy();
  const cov = sim.computeCoverage();

  // Background panel
  fill(0, 0, 100, 0.88);
  rect(width - 360, 10, 350, 155, 10);

  // Text
  fill(220, 20, 10, 1);
  textSize(12);
  textAlign(LEFT, TOP);

  const stats = sim.currentDayStats;
  const bhLine = stats
    ? `Behavior: shareGate=${stats.behavior.shareSuppressedByGate} routerGenSkip=${stats.behavior.routerGenSolveSkipped}`
    : "Behavior: (n/a)";

  text(
    `Day: ${sim.day}   Tick: ${sim.tick}\n` +
    `Pop: ${pop}   Active: ${active}\n` +
    `Modes: vault=${vaults} router=${routers}\n` +
    `Voids: ${voids}   Entropy~: ${ent.toFixed(0)}\n` +
    `Coverage: ${(cov * 100).toFixed(1)}%\n` +
    `${bhLine}\n` +
    `Telemetry days: ${sim.dayStats.length}`,
    width - 350, 18
  );

  // Spectrum mini-chart
  drawSpectrumChart(width - 350, 148, 330, 14);
}

function drawSpectrumChart(x0, y0, w, h) {
  const bins = CFG.telemetryBins || 36;
  const vb = new Array(bins).fill(0);
  const kb = new Array(bins).fill(0);

  for (const v of sim.voids) {
    if (v.state !== "active") continue;
    const idx = Math.floor((v.val / 360) * bins);
    vb[BCMSimulator.clamp(idx, 0, bins - 1)]++;
  }

  for (const a of sim.agents) {
    for (const k of a.keys) {
      const idx = Math.floor((k.val / 360) * bins);
      kb[BCMSimulator.clamp(idx, 0, bins - 1)]++;
    }
  }

  const maxV = Math.max(1, ...vb);
  const maxK = Math.max(1, ...kb);

  // Void histogram bars
  for (let i = 0; i < bins; i++) {
    const x = x0 + (i / bins) * w;
    const bw = w / bins;
    const hh = (vb[i] / maxV) * h;
    fill(i * (360 / bins), 70, 90, 0.55);
    rect(x, y0 + (h - hh), bw, hh);
  }

  // Key distribution line
  stroke(120, 10, 95, 0.8);
  strokeWeight(1);
  noFill();
  beginShape();
  for (let i = 0; i < bins; i++) {
    const x = x0 + (i + 0.5) / bins * w;
    const yy = y0 + h - (kb[i] / maxK) * h;
    vertex(x, yy);
  }
  endShape();
  noStroke();
}

function lerpHue(h1, h2, t) {
  return h1 + (h2 - h1) * t;
}

function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}

// ========================
// UI Controls
// ========================

function initUI() {
  const ui = select("#ui");
  ui.html("");

  const mkSlider = (name, label, min, max, value, step = 1) => {
    const row = createDiv("").addClass("row").parent(ui);
    createElement("label", label).parent(row);
    const s = createSlider(min, max, value, step).parent(row);
    const v = createSpan(String(value)).addClass("val mono").parent(row);
    sliders[name] = { s, v };
  };

  createElement("div", "Simulation").addClass("section-title").parent(ui);
  mkSlider("ticksPerFrame", "Speed", 1, 40, CFG.ticksPerFrame, 1);
  mkSlider("targetVoids", "Target voids", 5, 100, CFG.targetVoids, 1);
  mkSlider("voidHp", "Void HP", 1, 160, CFG.voidHp, 1);
  mkSlider("maxPop", "Max population", 10, 500, CFG.maxPop, 10);

  createElement("div", "Keys & Memory").addClass("section-title").parent(ui);
  mkSlider("maxMem", "Memory capacity", 10, 200, CFG.maxMem, 5);
  mkSlider("keyTTLMax", "Key TTL (days)", 2, 60, CFG.keyTTLMax, 1);
  mkSlider("matchEps", "Match tolerance", 0, 12, CFG.matchEps, 1);

  createElement("div", "Explosions").addClass("section-title").parent(ui);
  mkSlider("blastRadius", "Blast radius", 40, 260, CFG.blastRadius, 5);
  mkSlider("kDeath", "Blast lethality", 0.00, 0.60, CFG.kDeath, 0.01);

  // Buttons
  const btnRow = createDiv("").addClass("btns").parent(ui);
  btnPause = createButton("Pause").parent(btnRow).mousePressed(() => {
    paused = !paused;
    btnPause.html(paused ? "Resume" : "Pause");
  });
  btnReset = createButton("Reset").parent(btnRow).mousePressed(() => {
    initSimulation();
  });
  btnHud = createButton("Toggle HUD").parent(btnRow).mousePressed(() => {
    showHud = !showHud;
  });
  btnDownload = createButton("Download Telemetry").parent(btnRow).mousePressed(() => {
    downloadTelemetry();
  });

  // Hints
  createDiv(`<div class="hint">
    <b>Controls:</b> Space=pause, R=reset, Click=inspect<br/>
    <b>Agent color:</b> <span style="color:#7af">●</span> Calm
    <span style="color:#f77">●</span> Stressed
    <span style="color:#888">●</span> Sleeping<br/>
    <b>Mode marker:</b> <span style="color:#5d5; font-weight:bold">◆</span> Vault (diverse keys)
    <span style="color:#fa0">●</span> Router (clustered)<br/>
    <b>X</b> = Void (color = spectrum type, brightness = urgency)
  </div>`).parent(ui);

  // Inspector
  initInspectorUI(ui);
}

function applyUI() {
  const get = (k) => sliders[k].s.value();

  CFG.ticksPerFrame = Number(get("ticksPerFrame"));
  CFG.targetVoids = Number(get("targetVoids"));
  CFG.voidHp = Number(get("voidHp"));
  CFG.maxPop = Number(get("maxPop"));
  CFG.maxMem = Number(get("maxMem"));
  CFG.keyTTLMax = Number(get("keyTTLMax"));
  CFG.matchEps = Number(get("matchEps"));
  CFG.blastRadius = Number(get("blastRadius"));
  CFG.kDeath = Number(get("kDeath"));

  // Update slider value displays
  for (const k of Object.keys(sliders)) {
    sliders[k].v.html(String(sliders[k].s.value()));
  }

  // Apply to simulation config
  sim.cfg.targetVoids = CFG.targetVoids;
  sim.cfg.voidHp = CFG.voidHp;
  sim.cfg.maxPop = CFG.maxPop;
  sim.cfg.maxMem = CFG.maxMem;
  sim.cfg.keyTTLMax = CFG.keyTTLMax;
  sim.cfg.matchEps = CFG.matchEps;
  sim.cfg.blastRadius = CFG.blastRadius;
  sim.cfg.kDeath = CFG.kDeath;

  // Live apply to existing agents
  for (const a of sim.agents) {
    if (a.totalMem !== CFG.maxMem) {
      a.totalMem = CFG.maxMem;
      a.recomputeCaps();
    }
    for (const key of a.keys) {
      if (CFG.enableModes && a.mode === "vault") {
        key.ttlMax = Math.round(CFG.keyTTLMax * CFG.vaultKeyTTLBoost);
      } else {
        key.ttlMax = CFG.keyTTLMax;
      }
      key.ttl = Math.min(key.ttl, key.ttlMax);
    }
  }

  renderInspector();
}

// ========================
// Inspector
// ========================

function initInspectorUI(parentDiv) {
  const wrap = createDiv("").addClass("inspector").parent(parentDiv);
  createElement("h3", "Inspector").parent(wrap);
  inspectorPre = createElement("pre", "Click an agent or void to inspect.\nTip: Shift-click to pin selection.")
    .addClass("mono")
    .parent(wrap);
}

function renderInspector() {
  if (!inspectorPre) return;

  if (!selectedType) {
    inspectorPre.html("Click an agent or void to inspect.\nTip: Shift-click to pin selection.");
    return;
  }

  if (selectedType === "agent") {
    const a = sim.agents.find(x => x.id === selectedId);
    if (!a) {
      inspectorPre.html("Selected agent no longer exists.");
      selectedType = null;
      selectedId = null;
      return;
    }

    const sampleKeys = a.keys.slice(-8).map(k => ({
      val: k.val,
      ttl: k.ttl,
      uses: k.uses
    }));

    const sampleVoids = a.voidMem
      .slice()
      .sort((x, y) => (y.urgency || 0) - (x.urgency || 0))
      .slice(0, 6)
      .map(m => ({
        voidId: m.voidId,
        val: m.val,
        urg: +(m.urgency || 0).toFixed(1)
      }));

    const obj = {
      id: a.id,
      mode: a.mode,
      ageDays: a.ageDays,
      sleeping: a.sleeping,
      energy: +a.energy.toFixed(1),
      agentValue: a.agentValue,
      keys: { count: a.keys.length, max: a.maxKeys, sample: sampleKeys },
      voidMem: { count: a.voidMem.length, max: a.maxVoidMem, sample: sampleVoids }
    };

    inspectorPre.html(JSON.stringify(obj, null, 2));
    return;
  }

  if (selectedType === "void") {
    const v = sim.voidMap.get(selectedId);
    if (!v || v.state !== "active") {
      inspectorPre.html("Selected void no longer exists.");
      selectedType = null;
      selectedId = null;
      return;
    }

    const obj = {
      id: v.id,
      val: v.val,
      hp: +v.hp.toFixed(1),
      hpMax: v.hpMax,
      lifespan: v.lifespan,
      lifespanMax: v.lifespanMax,
      urgency: +v.urgency().toFixed(1)
    };

    inspectorPre.html(JSON.stringify(obj, null, 2));
  }
}

function pickEntityAt(mx, my) {
  const THR_AGENT = 12;
  const THR_VOID = 16;

  let best = null;
  let bestD = Infinity;

  // Check agents
  for (const a of sim.agents) {
    if (!a.alive) continue;
    const px = map(a.x, 0, CFG.arenaSize, 0, width);
    const py = map(a.y, 0, CFG.arenaSize, 0, height);
    const d = Math.hypot(mx - px, my - py);
    if (d < THR_AGENT && d < bestD) {
      best = { type: "agent", id: a.id };
      bestD = d;
    }
  }

  // Check voids
  for (const v of sim.voids) {
    if (v.state !== "active") continue;
    const px = map(v.x, 0, CFG.arenaSize, 0, width);
    const py = map(v.y, 0, CFG.arenaSize, 0, height);
    const d = Math.hypot(mx - px, my - py);
    if (d < THR_VOID && d < bestD) {
      best = { type: "void", id: v.id };
      bestD = d;
    }
  }

  return best;
}

// ========================
// Telemetry Download
// ========================

function downloadTelemetry() {
  const telemetry = {
    meta: {
      version: "bcm-sim-v2.0",
      downloadedAtISO: new Date().toISOString()
    },
    config: { ...CFG },
    days: sim.dayStats,
    live: {
      day: sim.day,
      tick: sim.tick,
      pop: sim.agents.length,
      voids: sim.voids.filter(v => v.state === "active").length,
      coverage: sim.computeCoverage(),
      entropyProxy: sim.computeEntropyProxy()
    }
  };

  const json = JSON.stringify(telemetry, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = `bcm_telemetry_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

// ========================
// Keyboard & Mouse
// ========================

function keyPressed() {
  if (key === ' ') {
    paused = !paused;
    btnPause.html(paused ? "Resume" : "Pause");
  }
  if (key === 'r' || key === 'R') {
    initSimulation();
  }
}

function mousePressed() {
  // Ignore clicks on UI panel
  const uiEl = document.getElementById("ui");
  const rect = uiEl.getBoundingClientRect();
  if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
    return;
  }

  const hit = pickEntityAt(mouseX, mouseY);
  if (!hit) {
    selectedType = null;
    selectedId = null;
    renderInspector();
    return;
  }

  selectedType = hit.type;
  selectedId = hit.id;
  renderInspector();
}
</script>
</body>
</html>
