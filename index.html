<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BCM Void–Key Simulator v2 (memes/pruning + void awareness + play exchange)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    :root { --uiw: 390px; }
    html, body {
      margin: 0; height: 100%;
      background: #0b0d12; color: #e8eaf1;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    canvas { display: block; }
    #ui {
      position: fixed; top: 0; right: 0; width: var(--uiw); height: 100%;
      box-sizing: border-box; padding: 14px 14px 140px;
      background: #11141b; border-left: 1px solid #1f2535;
      overflow-y: auto;
    }
    #ui h2 { margin: 8px 0 10px; font-size: 16px; font-weight: 800; letter-spacing: 0.2px; }
    #ui h3 { margin: 8px 0 8px; font-size: 13px; font-weight: 750; opacity: 0.95; }
    .group {
      border: 1px solid #1f2535; border-radius: 12px;
      padding: 10px; margin-bottom: 12px; background: #0f1218;
    }
    label { display: block; font-size: 12px; opacity: 0.88; margin: 6px 0 4px; }
    input[type="range"] { width: 100%; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    button, select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #2a3248;
      padding: 8px 10px;
      background: #16202d;
      color: #e8eaf1;
      cursor: pointer;
    }
    button:hover { background: #1b2a3b; }
    .tiny { font-size: 11px; opacity: 0.82; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .badge {
      display: inline-block; padding: 2px 7px; border-radius: 999px;
      border: 1px solid #2a3248; background: #141c28; font-size: 11px;
      margin-right: 6px;
    }
    .split { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-items: start; }
    .previewBox {
      border: 1px solid #2a3248; border-radius: 10px;
      padding: 8px; background: #0d1118;
    }
    #hud {
      position: fixed; left: 10px; top: 10px;
      background: rgba(8, 10, 14, 0.78);
      padding: 8px 10px; border-radius: 10px;
      border: 1px solid #1e2230;
      backdrop-filter: blur(6px);
      font-size: 12px;
      max-width: calc(100vw - var(--uiw) - 30px);
    }
  </style>
</head>

<body>
  <div id="ui">
    <h2>BCM Simulator v2</h2>

    <div class="group">
      <div class="row">
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset World</button>
      </div>
      <div class="tiny" style="margin-top: 8px">
        Click an <b>agent</b> or a <b>void</b> to inspect. Shift-click deletes selected.
      </div>
    </div>

    <div class="group">
      <h3>Presets</h3>
      <label>Scenario</label>
      <select id="configPreset"></select>
      <div class="row" style="margin-top: 8px">
        <button id="btnApplyPreset">Apply Preset</button>
      </div>
      <div class="tiny" style="margin-top: 6px">
        Applies counts + speed and resets the world.
      </div>
    </div>

    <div class="group">
      <h3>Simulation</h3>
      <label>Speed: <span id="lblSpeed">1.00</span></label>
      <input id="sSpeed" type="range" min="0.2" max="10.0" step="0.01" value="1.00" />

      <label>Entropy pressure (global): <span id="lblEnt">0.55</span></label>
      <input id="sEntropy" type="range" min="0.0" max="1.5" step="0.01" value="0.55" />
      <label class="tiny">
        Higher = unsolved voids drain more energy/health and mutate/grow more.
      </label>

      <label><input id="chkSignals" type="checkbox" checked /> Show ripples (signals)</label>
      <label><input id="chkPatterns" type="checkbox" checked /> Show 7×7 patterns in-world</label>
      <label><input id="chkLinks" type="checkbox" /> Show agent→target links</label>

      <label style="margin-top: 10px"><input id="chkMemes" type="checkbox" checked /> Enable meme dynamics (key charges + decay + replication)</label>
      <label><input id="chkPlay" type="checkbox" checked /> Enable Play (agent↔agent exchanges)</label>
      <label><input id="chkRewards" type="checkbox" checked /> Enable void rewards (older/bigger → more payout)</label>
    </div>

    <div class="group">
      <h3>World</h3>
      <label>Voids: <span id="lblVoids">14</span></label>
      <input id="sVoids" type="range" min="0" max="50" step="1" value="14" />

      <label>Energy sources: <span id="lblEnergy">10</span></label>
      <input id="sEnergy" type="range" min="0" max="35" step="1" value="10" />

      <label>Void spawn rate: <span id="lblSpawn">0.25</span></label>
      <input id="sSpawn" type="range" min="0.0" max="2.0" step="0.01" value="0.25" />

      <label>Void growth rate: <span id="lblGrow">0.20</span></label>
      <input id="sGrow" type="range" min="0.0" max="1.0" step="0.01" value="0.20" />

      <div class="row" style="margin-top: 8px">
        <button id="btnAddVoid">Spawn Void</button>
        <button id="btnAddEnergy">Spawn Energy</button>
      </div>
    </div>

    <div class="group">
      <h3>Agents</h3>
      <label>Agents: <span id="lblAgents">30</span></label>
      <input id="sAgents" type="range" min="0" max="140" step="1" value="30" />

      <label>Spawn preset</label>
      <select id="spawnPreset"></select>

      <label><input id="chkAddAgent" type="checkbox" checked /> Add agent by clicking world</label>

      <div class="row" style="margin-top: 8px">
        <button id="btnAdd10">Add 10 mixed</button>
        <button id="btnClearSel">Clear selection</button>
      </div>

      <div class="tiny" style="margin-top: 8px">
        <b>Double Observer</b> = efficient at <b>S + N</b> (yellow + purple).<br/>
        <b>Double Decider</b> = efficient at <b>T + F</b> (blue + red).<br/>
        v2 adds: keys have <b>charges</b> (fatigue) + <b>decay</b> (forgetting) + <b>replication</b> (useful memes spread).
      </div>
    </div>

    <div class="group">
      <h3>Selected</h3>
      <div id="selHeader" class="tiny">None</div>

      <div class="split" style="margin-top: 10px">
        <div class="previewBox">
          <div class="tiny" style="margin-bottom: 6px"><b>Void / Lock</b> pattern</div>
          <canvas id="voidPreview" width="140" height="140"></canvas>
          <div id="voidInfo" class="tiny" style="margin-top: 6px">—</div>
        </div>

        <div class="previewBox">
          <div class="tiny" style="margin-bottom: 6px"><b>Key</b> (best for target)</div>
          <canvas id="keyPreview" width="140" height="140"></canvas>
          <div id="keyInfo" class="tiny" style="margin-top: 6px">—</div>
        </div>
      </div>

      <div id="selDetails" class="tiny" style="margin-top: 10px">—</div>

      <div class="row" style="margin-top: 8px">
        <button id="btnDeleteSel">Delete selected</button>
        <button id="btnGiveEnergy">+20 energy</button>
      </div>
    </div>

    <div class="group tiny">
      <div style="font-weight: 800; margin-bottom: 6px">Legend</div>
      <div>
        <span class="badge" style="border-color:#2a78ff">T (Thinking)</span>
        <span class="badge" style="border-color:#ff4b4b">F (Feeling)</span>
        <span class="badge" style="border-color:#ffd34a">S (Sensing)</span>
        <span class="badge" style="border-color:#b055ff">N (Intuition)</span>
      </div>
      <div style="margin-top: 6px">
        Ripples = broadcasts of <span class="mono">voidId, keyId, areaBefore→after</span>.
        Color matches the void domain (yellow ripples = S void events).
      </div>
    </div>
  </div>

  <div id="hud" class="tiny"></div>

<script>
/* ============================================================
   BCM Simulator v2
   Adds what Bin asked for:
   - Keys as memes: charges (fatigue), decay (forgetting), replication (useful → more copies)
   - Agent awareness: void-memory catalog that can be exchanged
   - Play: nearby agents exchange one key + one void-memory
   - Rewards: solved void spawns energy payout, scaled by age & size (lottery-ish)
   ============================================================ */

let uiW = 390, canvasW, canvasH;
let paused = false;
let lastT = 0;

// ---------- UI refs ----------
const UI = {};
const PARAMS = {
  speed: 1.0,
  entropyPressure: 0.55,
  showSignals: true,
  showPatterns: true,
  showLinks: false,

  enableMemes: true,
  enablePlay: true,
  enableRewards: true,

  desiredVoids: 14,
  desiredEnergy: 10,
  voidSpawnRate: 0.25,
  voidGrowthRate: 0.20,

  desiredAgents: 30,
  addAgentByClick: true,
  spawnPreset: "Mixed"
};

const CONFIG_PRESETS = {
  "Single (1/1/1)": { speed: 5.0, voids: 1, energy: 1, agents: 1, spawn: 0 },
  "Two (2/1/1)": { speed: 5.0, voids: 1, energy: 1, agents: 2, spawn: 0 },
  "Four (4/1/1)": { speed: 5.0, voids: 1, energy: 1, agents: 4, spawn: 0 },
  "5x5 (5/5/5 agents/voids/energy)": { speed: 5.0, voids: 5, energy: 5, agents: 5, spawn: 0 },
};
const CONFIG_PRESET_NAMES = Object.keys(CONFIG_PRESETS);

// ---------- Domains ----------
const DOMAINS = ["T","F","S","N"];
const DOMAIN_NAME = { T:"Thinking", F:"Feeling", S:"Sensing", N:"Intuition" };
const DOMAIN_RGB = {
  T: [42, 140, 255],
  F: [255, 75, 75],
  S: [255, 211, 74],
  N: [176, 85, 255],
};
function domainColor(d, a=255) {
  const c = DOMAIN_RGB[d] || [200,200,200];
  return color(c[0], c[1], c[2], a);
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

// ---------- Pattern helpers ----------
const P = 7, Pn = P*P;
function bitsClone(bits){ const b = new Uint8Array(bits.length); b.set(bits); return b; }
function bitsCount(bits){ let c=0; for(let i=0;i<bits.length;i++) c += bits[i]?1:0; return c; }
function bitsOverlap(a,b){ let c=0; for(let i=0;i<a.length;i++) c += (a[i] && b[i])?1:0; return c; }
function bitsExtraOnes(k,t){ let c=0; for(let i=0;i<k.length;i++) if(k[i] && !t[i]) c++; return c; }
function bitsOrInPlace(dst, src){ for(let i=0;i<dst.length;i++) dst[i] = (dst[i] || src[i]) ? 1 : 0; }

function makeBlob(k) {
  const bits = new Uint8Array(Pn);
  let x = Math.floor(Math.random()*P);
  let y = Math.floor(Math.random()*P);
  bits[y*P + x] = 1;
  let placed = 1;
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  while(placed < k) {
    const [dx,dy] = randChoice(dirs);
    x = clamp(x+dx, 0, P-1);
    y = clamp(y+dy, 0, P-1);
    const idx = y*P + x;
    if(!bits[idx]) { bits[idx]=1; placed++; }
    if(Math.random() < 0.10) {
      x = clamp(x + Math.floor((Math.random()*5)-2), 0, P-1);
      y = clamp(y + Math.floor((Math.random()*5)-2), 0, P-1);
    }
  }
  return bits;
}

// 2d6 entropy weighting
function roll2d6(){ return (1+Math.floor(Math.random()*6)) + (1+Math.floor(Math.random()*6)); }

// ---------- Global shapes (keys) ----------
let SHAPES = [];
let shapeIdCounter = 1;
function addShape(domain, bits, rarity, parents=null) {
  const shape = { id:`K${shapeIdCounter++}`, domain, bits:bitsClone(bits), rarity, createdAt: performance.now(), parents };
  SHAPES.push(shape);
  return shape;
}
function shapesBy(domain, rarity=null){
  return SHAPES.filter(s => s.domain===domain && (rarity? s.rarity===rarity : true));
}
function initBaseShapes() {
  SHAPES = []; shapeIdCounter = 1;
  for(const d of DOMAINS) {
    for(let i=0;i<9;i++) addShape(d, makeBlob(9+Math.floor(Math.random()*6)), "common");
    for(let i=0;i<5;i++) addShape(d, makeBlob(16+Math.floor(Math.random()*7)), "rare");
  }
}
function pickShapeByEntropy(domain) {
  const r = roll2d6();
  const rareChance = (r<=3 || r>=11) ? 0.9 : (r<=4 || r>=10) ? 0.35 : 0.10;
  const wantRare = Math.random() < rareChance;
  const pool = shapesBy(domain, wantRare ? "rare" : "common");
  if(pool.length) return randChoice(pool);
  const all = shapesBy(domain);
  return randChoice(all);
}
function getShape(id){ return SHAPES.find(s => s.id===id) || null; }

// ---------- World entities ----------
let voids = [];
let energies = [];
let shards = [];
let signals = [];
let solveBursts = [];
let agents = [];

let voidIdCounter=1, energyIdCounter=1, shardIdCounter=1, signalIdCounter=1, burstIdCounter=1, agentIdCounter=1;

// Selection
let selected = { kind:null, id:null };

// Chaos
let worldChaos = 0.0;

// ---------- Presets ----------
const PRESETS = {
  "Double Observer (S+N)": { primary:["S","N"], secondary:["T","F"], extro:0.45, intro:0.55 },
  "Double Decider (T+F)":  { primary:["T","F"], secondary:["S","N"], extro:0.45, intro:0.55 },
  "Sensor (S)":            { primary:["S"], secondary:["N","T","F"], extro:0.55, intro:0.45 },
  "Intuitive (N)":         { primary:["N"], secondary:["S","T","F"], extro:0.55, intro:0.45 },
  "Thinker (T)":           { primary:["T"], secondary:["F","S","N"], extro:0.55, intro:0.45 },
  "Feeler (F)":            { primary:["F"], secondary:["T","S","N"], extro:0.55, intro:0.45 },
  "Extro Gatherer":        { primary:["T","F","S","N"], secondary:[], extro:0.85, intro:0.15 },
  "Intro Refiner":         { primary:["T","F","S","N"], secondary:[], extro:0.20, intro:0.80 },
  "Mixed":                 { primary:["T","F","S","N"], secondary:[], extro:0.50, intro:0.50 },
};
const SPAWN_PRESETS = Object.keys(PRESETS);

// ---------- Agent “animals” (light mapping) ----------
function deriveAnimals(agent) {
  // simple bias: extro -> play/blast; intro -> sleep/consume
  const play  = clamp(0.10 + 0.90*agent.extro, 0, 1);
  const sleep = clamp(0.10 + 0.90*agent.intro, 0, 1);
  const consume = clamp(0.25 + 0.65*agent.intro, 0, 1);
  const blast   = clamp(0.25 + 0.65*agent.extro, 0, 1);
  return { play, sleep, consume, blast };
}

function domainCostMultiplier(agent, domain) {
  if(agent.primary.includes(domain)) return 0.65;
  if(agent.secondary.includes(domain)) return 1.05;
  return 1.35;
}

// ---------- Meme dynamics (key inventory) ----------
function keyTTLBase(shape) {
  // rare keys stick around longer
  return (shape && shape.rarity==="rare") ? 44 : 30;
}
function keyMaxCharges(shape) {
  // rare keys replicate slower / fewer copies (keeps them rare-ish)
  return (shape && shape.rarity==="rare") ? 4 : 6;
}

// ---------- Agent model ----------
function makeAgent(x,y,presetName) {
  const p = PRESETS[presetName] || PRESETS["Mixed"];
  const a = {
    id:`A${agentIdCounter++}`,
    x,y, vx:0, vy:0,
    energy: 70 + Math.random()*20,
    health: 100,
    preset: presetName,
    primary:[...p.primary],
    secondary:[...p.secondary],
    extro: p.extro,
    intro: p.intro,

    // behavior
    state:"WANDER", // HARVEST | SOLVE | INVENT | SLEEP | WANDER
    target:null,    // {kind,id}
    boredom:0,
    lastProgress:0,
    lastPlayAt: 0,

    // key memes: Map shapeId -> {charges, ttl, uses, lastUsed, source}
    keys: new Map(),
    storageLimit: 18,

    // void awareness: Map voidId -> {id, domain, x,y, area, lastSeen, createdAt}
    voidMem: new Map(),
    voidMemLimit: 30,

    inventing: null,
  };

  // void memory capacity depends on consume-ish
  const animals = deriveAnimals(a);
  a.voidMemLimit = Math.floor(18 + animals.consume*42);

  seedAgentKeys(a);
  return a;
}

function seedAgentKeys(agent) {
  agent.keys.clear();
  const animals = deriveAnimals(agent);

  const commonCount = Math.floor(8 + agent.extro*12);
  const rareCount   = Math.floor(2 + agent.intro*5);

  const pri = agent.primary.length ? agent.primary : DOMAINS;
  const sec = agent.secondary.length ? agent.secondary : DOMAINS;

  function addKey(shape, source, charges=1) {
    if(!shape) return;
    const old = agent.keys.get(shape.id);
    if(old) {
      old.charges = Math.min(keyMaxCharges(shape), old.charges + charges);
      old.ttl = keyTTLBase(shape);
      return;
    }
    if(agent.keys.size >= agent.storageLimit) dropWorstKey(agent);
    agent.keys.set(shape.id, {
      charges: Math.min(keyMaxCharges(shape), charges),
      ttl: keyTTLBase(shape),
      uses: 0,
      lastUsed: performance.now(),
      source: source || "seed"
    });
  }

  // common keys: more copies (they're everywhere)
  for(let i=0;i<commonCount;i++){
    const d = (Math.random()<0.70) ? randChoice(pri) : randChoice(sec);
    const pool = shapesBy(d,"common");
    addKey(randChoice(pool), "seed-common", 1 + (Math.random()<0.25?1:0));
  }

  // rare keys: fewer copies
  for(let i=0;i<rareCount;i++){
    const d = (Math.random()<0.85) ? randChoice(pri) : randChoice(sec);
    const pool = shapesBy(d,"rare");
    addKey(randChoice(pool), "seed-rare", 1);
  }
}

function dropWorstKey(agent) {
  // remove lowest (uses, charges, recency)
  let worstId=null, worstScore=1e18;
  for(const [id,m] of agent.keys.entries()){
    const sh = getShape(id);
    const score =
      (m.uses*2) +
      (m.charges*1.5) +
      ((m.lastUsed||0)/1e9);
    if(score < worstScore) { worstScore=score; worstId=id; }
  }
  if(worstId) agent.keys.delete(worstId);
}

function agentHasUsableKey(agent, shapeId) {
  const m = agent.keys.get(shapeId);
  return m && m.charges > 0;
}

function agentCopyKey(agent, shapeId, source, costMult=1.0) {
  const shape = getShape(shapeId);
  if(!shape) return false;

  const cost = 6.0 * costMult * domainCostMultiplier(agent, shape.domain);
  if(agent.energy < cost) return false;

  agent.energy -= cost;
  let m = agent.keys.get(shapeId);
  if(!m) {
    if(agent.keys.size >= agent.storageLimit) dropWorstKey(agent);
    agent.keys.set(shapeId, {
      charges: 1,
      ttl: keyTTLBase(shape),
      uses: 0,
      lastUsed: performance.now(),
      source: source || "copy",
    });
  } else {
    // receiving a meme reinforces it
    m.charges = Math.min(keyMaxCharges(shape), m.charges + 1);
    m.ttl = keyTTLBase(shape);
    m.lastUsed = performance.now();
  }
  return true;
}

// ---------- Voids ----------
function makeVoid(x,y,domain) {
  const layers = 1 + (Math.random()<0.35?1:0) + (Math.random()<0.15?1:0);
  const bits = new Uint8Array(Pn);

  for(let i=0;i<layers;i++){
    const s = pickShapeByEntropy(domain);
    bitsOrInPlace(bits, s.bits);
  }

  if(Math.random()<0.30){
    for(let k=0;k<2+Math.floor(Math.random()*4);k++){
      bits[Math.floor(Math.random()*Pn)] = 1;
    }
  }

  const area = bitsCount(bits);
  const v = {
    id:`V${voidIdCounter++}`,
    x,y, domain,
    bits,
    area,
    area0: area,
    createdAt: performance.now(),
    lastTouchedAt: 0,
    solved: false,
    severity: 1.0 + Math.random()*0.6,
  };
  return v;
}
function voidRadiusPx(v) {
  const base=18, k=3.2;
  return base + k*Math.sqrt(Math.max(1,v.area));
}

// ---------- Energy sources ----------
function makeEnergy(x,y,domain=null) {
  const d = domain || randChoice(DOMAINS);
  const s = randChoice(shapesBy(d,"common"));
  return {
    id:`E${energyIdCounter++}`,
    x,y, domain:d,
    bits: bitsClone(s.bits),
    amount: 140 + Math.random()*120,
    radiusPx: 26 + Math.random()*10,
    createdAt: performance.now(),
  };
}

// ---------- Shards ----------
function makeShard(x,y,shapeId) {
  const shape = getShape(shapeId);
  return {
    id:`S${shardIdCounter++}`,
    x,y,
    shapeId,
    domain: shape ? shape.domain : "T",
    ttl: 18 + Math.random()*10,
    createdAt: performance.now(),
  };
}

// ---------- Signals (ripples) ----------
function makeSignal(x,y,domain,payload) {
  return { id:`R${signalIdCounter++}`, x,y, domain, t:0, ttl:2.2, payload };
}
function makeSolveBurst(x,y,domain) {
  return {
    id:`B${burstIdCounter++}`,
    x,y, domain,
    t:0,
    ttl:1.4,
    spin: Math.random()*Math.PI*2,
  };
}

// ---------- Matching ----------
function matchScore(keyBits, targetBits) {
  const overlap = bitsOverlap(keyBits, targetBits);
  const area = Math.max(1, bitsCount(targetBits));
  const extra = bitsExtraOnes(keyBits, targetBits);
  const penalty = 0.25;
  return clamp((overlap - penalty*extra)/area, 0, 1);
}

function agentBestKeyFor(agent, domain, targetBits) {
  let best=null;
  for(const [id,m] of agent.keys.entries()){
    if(m.charges <= 0 && PARAMS.enableMemes) continue;
    const shape = getShape(id);
    if(!shape) continue;
    if(shape.domain !== domain) continue;
    const s = matchScore(shape.bits, targetBits);
    if(!best || s > best.score) best = { shape, meta: m, score: s };
  }
  return best;
}

// ---------- Torus movement ----------
function wrap01(u){ u = u % 1; if(u<0) u += 1; return u; }
function wrapDelta(d){ if(d>0.5) d -= 1; if(d<-0.5) d += 1; return d; }
function torusVec(ax,ay,bx,by){
  const dx = wrapDelta(bx-ax);
  const dy = wrapDelta(by-ay);
  return { dx, dy, dist: Math.hypot(dx,dy) };
}

// ---------- Agent awareness ----------
function agentRememberVoid(agent, v) {
  // keep a memory record updated when nearby
  const entry = agent.voidMem.get(v.id) || {
    id:v.id, domain:v.domain, x:v.x, y:v.y, area:v.area,
    createdAt: v.createdAt, lastSeen: performance.now()
  };
  entry.domain = v.domain;
  entry.x = v.x; entry.y = v.y;
  entry.area = v.area;
  entry.lastSeen = performance.now();
  agent.voidMem.set(v.id, entry);

  // prune memory if too big
  if(agent.voidMem.size > agent.voidMemLimit) {
    // drop oldest lastSeen
    let worstId=null, worst=1e18;
    for(const [id,e] of agent.voidMem.entries()){
      if(e.lastSeen < worst) { worst = e.lastSeen; worstId = id; }
    }
    if(worstId) agent.voidMem.delete(worstId);
  }
}
function agentDecayVoidMemory(agent) {
  // forget entries not seen recently
  const now = performance.now();
  for(const [id,e] of agent.voidMem.entries()){
    if(now - e.lastSeen > 120_000) agent.voidMem.delete(id);
  }
}

// ---------- Play exchange ----------
function agentTryPlayExchange(a, dt) {
  if(!PARAMS.enablePlay) return;
  const animalsA = deriveAnimals(a);
  const now = performance.now();
  if(now - a.lastPlayAt < 900) return; // simple cooldown

  // meet radius
  const meetR = 0.02;
  // chance scales with play
  const p = animalsA.play * 0.22;

  if(Math.random() > p * dt * 60) return;

  // find nearest neighbor within meetR
  let best=null;
  for(const b of agents) {
    if(b.id === a.id) continue;
    const v = torusVec(a.x,a.y,b.x,b.y);
    if(v.dist < meetR && (!best || v.dist < best.dist)) best = { b, dist:v.dist };
  }
  if(!best) return;

  const b = best.b;

  // exchange one void memory (largest area known) and one key (highest uses)
  function pickMem(agent) {
    let bestE=null;
    for(const e of agent.voidMem.values()){
      // prefer big & not too old
      const age = (now - e.lastSeen);
      const score = e.area - 0.00004*age;
      if(!bestE || score > bestE.score) bestE = { e, score };
    }
    return bestE ? bestE.e : null;
  }
  function pickKey(agent) {
    let bestK=null;
    for(const [id,m] of agent.keys.entries()){
      const sh = getShape(id);
      if(!sh) continue;
      const score = (m.uses*2) + (m.charges*1.2) + (sh.rarity==="rare"? 1.5 : 0);
      if(!bestK || score > bestK.score) bestK = { id, m, score, sh };
    }
    return bestK ? bestK : null;
  }

  const memA = pickMem(a), memB = pickMem(b);
  const keyA = pickKey(a), keyB = pickKey(b);

  // swap void awareness (free)
  if(memA) b.voidMem.set(memA.id, {...memA, lastSeen: performance.now()});
  if(memB) a.voidMem.set(memB.id, {...memB, lastSeen: performance.now()});

  // swap a key meme (cost energy to copy, but only if receiver doesn’t have it)
  if(keyA && !b.keys.has(keyA.id)) agentCopyKey(b, keyA.id, "play", 1.0);
  if(keyB && !a.keys.has(keyB.id)) agentCopyKey(a, keyB.id, "play", 1.0);

  // ripple
  if(UI.chkSignals.checked) {
    signals.push(makeSignal(a.x, a.y, "T", { play:true, a:a.id, b:b.id }));
  }
  a.lastPlayAt = now;
  b.lastPlayAt = now;
}

// ---------- Meme decay + replication ----------
function agentMemeStep(agent, dt) {
  if(!PARAMS.enableMemes) return;
  for(const [id,m] of agent.keys.entries()){
    const sh = getShape(id);
    if(!sh) { agent.keys.delete(id); continue; }
    m.ttl -= dt;
    if(m.ttl <= 0) {
      // decay event: lose a charge; reset ttl if still alive
      m.charges -= 1;
      if(m.charges <= 0) {
        agent.keys.delete(id);
      } else {
        m.ttl = keyTTLBase(sh);
      }
    }
  }
}

// ---------- Agent target selection ----------
function pickAgentTarget(agent) {
  const low = agent.energy < 22;

  // If low energy: go harvest
  if(low && energies.length) {
    let best=null;
    for(const e of energies){
      if(e.amount <= 1) continue;
      const v = torusVec(agent.x,agent.y,e.x,e.y);
      const bias = agent.primary.includes(e.domain) ? 0.85 : 1.0;
      const score = v.dist * bias;
      if(!best || score < best.score) best = { kind:"energy", id:e.id, score };
    }
    if(best) return { kind:best.kind, id:best.id };
  }

  // If boredom high and sleep strong: go SLEEP (internal)
  const animals = deriveAnimals(agent);
  if(agent.boredom > 2.2 && animals.sleep > 0.55 && agent.energy > 35) {
    return { kind:"sleep", id:"SLEEP" };
  }

  // Prefer voids from memory if consume high (awareness-driven)
  const preferMem = animals.consume > 0.55 && agent.voidMem.size > 0;

  // keep current void target unless very bored
  if(agent.target && agent.target.kind==="void") {
    const v = voids.find(x => x.id===agent.target.id && !x.solved);
    if(v && agent.boredom < 1.4) return agent.target;
  }

  let best=null;
  const domainOrder = [
    ...agent.primary,
    ...agent.secondary,
    ...DOMAINS.filter(d => !agent.primary.includes(d) && !agent.secondary.includes(d))
  ];

  function scoreVoid(v0) {
    const vec = torusVec(agent.x,agent.y,v0.x,v0.y);
    const urgency = 1.0 + 0.06*v0.area*v0.severity;
    const costBias = domainCostMultiplier(agent, v0.domain);
    // solvability bonus: do I have any usable key?
    const bestKey = agentBestKeyFor(agent, v0.domain, v0.bits);
    const solv = bestKey ? (0.6 + 0.8*bestKey.score) : 0.2;
    return (vec.dist*0.9 + 0.08) * costBias / (urgency * solv);
  }

  if(preferMem) {
    // choose a remembered void that still exists
    for(const d of domainOrder) {
      for(const e of agent.voidMem.values()) {
        if(e.domain !== d) continue;
        const v0 = voids.find(v => v.id===e.id && !v.solved);
        if(!v0) continue;
        const score = scoreVoid(v0);
        if(!best || score < best.score) best = { kind:"void", id:v0.id, score };
      }
      if(best && agent.primary.includes(d)) break;
    }
    if(best) return { kind:"void", id:best.id };
  }

  // otherwise scan actual void list
  if(voids.length) {
    for(const d of domainOrder) {
      for(const v0 of voids) {
        if(v0.solved) continue;
        if(v0.domain !== d) continue;
        const score = scoreVoid(v0);
        if(!best || score < best.score) best = { kind:"void", id:v0.id, score };
      }
      if(best && agent.primary.includes(d)) break;
    }
    if(best) return { kind:"void", id:best.id };
  }

  return null;
}

// ---------- Agent actions ----------
function removeRandomOverlappingCells(voidBits, keyBits, count) {
  const overlap = [];
  for(let i=0;i<Pn;i++) if(voidBits[i] && keyBits[i]) overlap.push(i);
  if(!overlap.length) return 0;
  let removed=0;
  for(let k=0;k<count;k++){
    if(!overlap.length) break;
    const idx = Math.floor(Math.random()*overlap.length);
    const cell = overlap[idx];
    if(voidBits[cell]) { voidBits[cell]=0; removed++; }
    overlap.splice(idx,1);
  }
  return removed;
}

function agentHarvest(agent, e, dt) {
  const best = agentBestKeyFor(agent, e.domain, e.bits);
  const score = best ? best.score : 0.0;
  const base = 18.0;
  const gain = base * (0.25 + 0.75*score);
  const take = Math.min(e.amount, gain*dt);

  agent.energy = Math.min(100, agent.energy + take*0.55);
  e.amount -= take;

  // harvesting reduces boredom
  agent.boredom = Math.max(0, agent.boredom - 0.6*dt);

  // reinforce the meme used to harvest (optional)
  if(best) {
    best.meta.uses++;
    best.meta.lastUsed = performance.now();
    if(PARAMS.enableMemes) {
      // small chance to recharge a charge by “practice”
      if(Math.random() < 0.06*dt*60) {
        const cap = keyMaxCharges(best.shape);
        best.meta.charges = Math.min(cap, best.meta.charges + 1);
        best.meta.ttl = keyTTLBase(best.shape);
      }
    }
  }
}

function agentSleep(agent, dt) {
  agent.state = "SLEEP";
  // spend a little energy to internally refresh/prune/recharge key memes
  const cost = 6.5 * dt;
  if(agent.energy < cost) { agent.boredom += 0.15*dt; return; }
  agent.energy -= cost;

  // pick top 2 keys by uses and recharge them
  const keysArr = [];
  for(const [id,m] of agent.keys.entries()){
    const sh = getShape(id);
    if(!sh) continue;
    keysArr.push({id,m,sh,score:(m.uses*2)+(m.charges*1.2)+(sh.rarity==="rare"?1.2:0)});
  }
  keysArr.sort((a,b)=>b.score-a.score);
  const top = keysArr.slice(0,2);
  for(const k of top) {
    const cap = keyMaxCharges(k.sh);
    if(PARAMS.enableMemes) {
      k.m.charges = Math.min(cap, k.m.charges + 1);
      k.m.ttl = keyTTLBase(k.sh);
    }
  }

  // prune if too many
  while(agent.keys.size > agent.storageLimit) dropWorstKey(agent);

  agent.boredom = Math.max(0, agent.boredom - 1.0*dt);
}

function agentInvent(agent, v, dt) {
  // Build candidate key by copying void cells
  if(!agent.inventing || agent.inventing.voidId !== v.id) {
    agent.inventing = {
      voidId: v.id, domain: v.domain,
      candidateBits: new Uint8Array(Pn),
      steps: 0,
      startedAt: performance.now(),
    };
  }

  const inv = agent.inventing;
  const costMult = domainCostMultiplier(agent, v.domain);
  const cost = 14.0*costMult;
  if(agent.energy < cost*dt) { agent.boredom += 0.25*dt; return; }
  agent.energy -= cost*dt;

  const wantPerSec = 6.5;
  const adds = Math.max(1, Math.floor(wantPerSec*dt));
  let added = 0;
  for(let k=0;k<adds;k++){
    let tries=0;
    while(tries++<40) {
      const idx = Math.floor(Math.random()*Pn);
      if(v.bits[idx] && !inv.candidateBits[idx]) {
        inv.candidateBits[idx] = 1;
        added++;
        break;
      }
    }
  }
  inv.steps += added;

  const score = matchScore(inv.candidateBits, v.bits);
  agent.boredom = Math.max(0, agent.boredom - 0.35*dt);

  if(score >= 0.62 && bitsCount(inv.candidateBits) >= 10) {
    const newShape = addShape(v.domain, inv.candidateBits, "rare", { fromVoid:v.id });
    agentCopyKey(agent, newShape.id, "invent", 0.4);

    shards.push(makeShard(v.x + random(-0.012,0.012), v.y + random(-0.012,0.012), newShape.id));
    if(Math.random()<0.55) shards.push(makeShard(v.x + random(-0.012,0.012), v.y + random(-0.012,0.012), newShape.id));

    if(UI.chkSignals.checked) {
      signals.push(makeSignal(v.x, v.y, v.domain, {
        voidId: v.id, keyId: newShape.id,
        before: v.area, after: v.area, delta: 0,
        domain: v.domain, invented: true
      }));
    }

    agent.inventing = null;
    agent.boredom = Math.max(0, agent.boredom - 0.8);
  }
}

function agentWorkOnVoid(agent, v, dt) {
  const best = agentBestKeyFor(agent, v.domain, v.bits);
  const score = best ? best.score : 0.0;

  const animals = deriveAnimals(agent);
  const canInvent = animals.consume > 0.55 && agent.energy > 18;
  const stuck = !best || score < 0.10;

  if(stuck && canInvent) {
    agent.state = "INVENT";
    agentInvent(agent, v, dt);
    return;
  }

  agent.state = "SOLVE";

  // Energy cost
  const costMult = domainCostMultiplier(agent, v.domain);
  const baseCost = 10.0;
  const cost = baseCost * (1.15 - 0.6*score) * costMult;
  if(agent.energy < cost*dt) { agent.boredom += 0.25*dt; return; }
  agent.energy -= cost*dt;

  // Meme fatigue: using a key consumes a charge
  if(PARAMS.enableMemes && best) {
    best.meta.charges -= 1;
    if(best.meta.charges < 0) best.meta.charges = 0;
  }

  // Progress
  const workRate = 14.0;
  const eff = (0.25 + 0.75*score);
  // Allow fractional work at normal frame rates.
  const workBudget = workRate*eff*dt;
  let removedTarget = Math.floor(workBudget);
  if(Math.random() < (workBudget - removedTarget)) removedTarget += 1;

  const before = v.area;
  const removed = best ? removeRandomOverlappingCells(v.bits, best.shape.bits, removedTarget) : 0;
  v.area = bitsCount(v.bits);
  const after = v.area;
  const delta = before - after;

  // Immediate satisfaction energy, but still net-negative overall
  agent.energy = Math.min(100, agent.energy + delta*0.18);

  if(delta > 0) {
    agent.boredom = Math.max(0, agent.boredom - 0.9*dt);
    agent.lastProgress = delta;
  } else {
    agent.boredom += 0.35*dt;
    agent.lastProgress = 0;
  }

  v.lastTouchedAt = performance.now();

  // key usage stats + meme replication if successful
  if(best) {
    best.meta.uses++;
    best.meta.lastUsed = performance.now();
    best.meta.ttl = keyTTLBase(best.shape);

    if(PARAMS.enableMemes && delta > 0) {
      // replication chance grows with impact, but capped
      const cap = keyMaxCharges(best.shape);
      const repChance = clamp(0.10 + 0.02*delta + 0.10*score, 0.0, 0.55);
      if(Math.random() < repChance) {
        best.meta.charges = Math.min(cap, best.meta.charges + 1);
      }
    }
  }

  // Ripple broadcast
  if(UI.chkSignals.checked && best) {
    signals.push(makeSignal(v.x, v.y, v.domain, {
      voidId: v.id, keyId: best.shape.id,
      before, after, delta, domain: v.domain
    }));
  }

  // Shard drop
  if(delta > 0 && best && Math.random() < 0.10) {
    shards.push(makeShard(v.x + random(-0.01,0.01), v.y + random(-0.01,0.01), best.shape.id));
  }

  // Solve condition
  const solveThresh = 5;
  const solveMatch = 0.90;
  
  if(v.area <= solveThresh || (best && best.score >= solveMatch && removed > 0)) {
    v.solved = true;
    solveBursts.push(makeSolveBurst(v.x, v.y, v.domain));

    // reward: energy payout scales with age & initial area (lottery-ish)
    if(PARAMS.enableRewards) {
      const ageSec = (performance.now() - v.createdAt)/1000;
      const reward = clamp(60 + 1.2*ageSec + 3.0*v.area0, 80, 520);
      const e = makeEnergy(v.x, v.y, v.domain);
      e.amount = reward;
      energies.push(e);
    }

    // also shard(s)
    if(best && Math.random() < 0.8) shards.push(makeShard(v.x, v.y, best.shape.id));
    if(Math.random() < 0.35) agent.energy = Math.min(100, agent.energy + 8);
  }
}

// ---------- Listening & shards ----------
function agentListenToSignals(agent, dt) {
  if(!UI.chkSignals.checked) return;
  const animals = deriveAnimals(agent);
  const listenRadius = 0.12 + 0.10*animals.consume;
  const copyChance = 0.06 + 0.16*animals.play;

  for(const s of signals) {
    if(!s.payload || !s.payload.keyId) continue;
    const v = torusVec(agent.x,agent.y,s.x,s.y);
    if(v.dist > listenRadius) continue;

    const helped = (s.payload.delta || 0) > 0 || s.payload.invented;
    if(!helped) continue;

    if(Math.random() < copyChance * dt * 30) {
      agentCopyKey(agent, s.payload.keyId, "signal", 1.0);
    }
  }
}

function agentPickupShards(agent) {
  const pickR = 0.02;
  for(let i=shards.length-1;i>=0;i--){
    const sh = shards[i];
    const v = torusVec(agent.x,agent.y,sh.x,sh.y);
    if(v.dist < pickR) {
      const ok = agentCopyKey(agent, sh.shapeId, "shard", 0.35);
      shards.splice(i,1);
      if(ok) agent.energy = Math.min(100, agent.energy + 2);
    }
  }
}

// ---------- World dynamics ----------
function maintainCounts() {
  while(voids.filter(v=>!v.solved).length < PARAMS.desiredVoids) {
    voids.push(makeVoid(Math.random(), Math.random(), randChoice(DOMAINS)));
  }
  while(energies.length < PARAMS.desiredEnergy) {
    energies.push(makeEnergy(Math.random(), Math.random(), randChoice(DOMAINS)));
  }
}

function worldStep(dt) {
  energies = energies.filter(e => e.amount > 1);

  for(let i=shards.length-1;i>=0;i--){
    shards[i].ttl -= dt;
    if(shards[i].ttl <= 0) shards.splice(i,1);
  }

  for(let i=signals.length-1;i>=0;i--){
    signals[i].t += dt;
    if(signals[i].t >= signals[i].ttl) signals.splice(i,1);
  }
  for(let i=solveBursts.length-1;i>=0;i--){
    solveBursts[i].t += dt;
    if(solveBursts[i].t >= solveBursts[i].ttl) solveBursts.splice(i,1);
  }

  // compute total area for chaos
  let totalArea=0, activeVoids=0;
  for(const v of voids){ if(!v.solved){ activeVoids++; totalArea += v.area; } }

  const pressure = PARAMS.entropyPressure;
  worldChaos += dt * (0.015 * pressure * (totalArea/120.0) - 0.010);
  worldChaos = Math.max(0, worldChaos);

  // growth + mutation
  const gRate = PARAMS.voidGrowthRate * (1.0 + 0.45*worldChaos);
  const mutateChance = 0.02 * pressure * (0.6 + worldChaos); // rare

  for(const v of voids) {
    if(v.solved) continue;

    // basic regrowth
    if(Math.random() < gRate*dt) {
      for(let k=0;k<1+(Math.random()<0.25?1:0);k++){
        v.bits[Math.floor(Math.random()*Pn)] = 1;
      }
      v.area = bitsCount(v.bits);
    }

    // occasional mutation: add a small blob of same domain (harder over time)
    if(Math.random() < mutateChance*dt) {
      const blob = makeBlob(4 + Math.floor(Math.random()*4));
      bitsOrInPlace(v.bits, blob);
      v.area = bitsCount(v.bits);
    }
  }

  // spawn new void
  const spawn = PARAMS.voidSpawnRate * (1.0 + 0.8*worldChaos);
  if(Math.random() < spawn*dt) {
    voids.push(makeVoid(Math.random(), Math.random(), randChoice(DOMAINS)));
  }

  maintainCounts();
}

// ---------- Agents step ----------
function agentsStep(dt) {
  const chaosDrain = 0.35 * PARAMS.entropyPressure * worldChaos;
  const chaosHealth = 0.18 * PARAMS.entropyPressure * worldChaos;

  for(let i=agents.length-1;i>=0;i--){
    const a = agents[i];

    // chaos drains
    a.energy -= chaosDrain*dt;
    a.energy = clamp(a.energy, 0, 100);
    if(a.energy <= 0.2) a.health -= chaosHealth*dt*18;

    if(a.health <= 0) {
      agents.splice(i,1);
      if(selected.kind==="agent" && selected.id===a.id) selected = {kind:null,id:null};
      continue;
    }

    // meme decay
    agentMemeStep(a, dt);

    // awareness update: remember nearby voids
    const senseR = 0.06;
    for(const v of voids){
      if(v.solved) continue;
      const dv = torusVec(a.x,a.y,v.x,v.y);
      if(dv.dist < senseR) agentRememberVoid(a, v);
    }
    agentDecayVoidMemory(a);

    // listen/pickup/play
    agentListenToSignals(a, dt);
    agentPickupShards(a);
    agentTryPlayExchange(a, dt);

    // pick target
    if(!a.target || a.boredom > 2.5 || a.state==="WANDER") {
      a.target = pickAgentTarget(a);
    }

    // movement / action
    let tx=null, ty=null, targetObj=null;

    if(a.target && a.target.kind==="void") {
      targetObj = voids.find(v => v.id===a.target.id && !v.solved) || null;
      if(targetObj) { tx=targetObj.x; ty=targetObj.y; }
      else a.target=null;
    } else if(a.target && a.target.kind==="energy") {
      targetObj = energies.find(e => e.id===a.target.id) || null;
      if(targetObj) { tx=targetObj.x; ty=targetObj.y; }
      else a.target=null;
    } else if(a.target && a.target.kind==="sleep") {
      // sleep is internal, no movement target
      tx=null; ty=null;
      agentSleep(a, dt);
    }

    if(a.target && a.target.kind==="sleep") {
      // already handled
    } else if(tx === null) {
      a.state="WANDER";
      const jitter = 0.35;
      a.vx += random(-jitter,jitter)*dt;
      a.vy += random(-jitter,jitter)*dt;
      a.boredom += 0.04*dt;
    } else {
      const v = torusVec(a.x,a.y,tx,ty);
      const steer = 1.7;
      a.vx += (v.dx/(v.dist+1e-6))*steer*dt;
      a.vy += (v.dy/(v.dist+1e-6))*steer*dt;

      const arrive = 0.03;
      if(v.dist < arrive) {
        if(a.target.kind==="energy" && targetObj) { a.state="HARVEST"; agentHarvest(a, targetObj, dt); }
        if(a.target.kind==="void" && targetObj)   { agentWorkOnVoid(a, targetObj, dt); }
      } else {
        a.boredom += 0.05*dt;
      }
    }

    // speed/friction
    const maxSpd = 0.18;
    const spd = Math.hypot(a.vx,a.vy);
    if(spd > maxSpd) { a.vx *= maxSpd/spd; a.vy *= maxSpd/spd; }
    a.vx *= Math.pow(0.50, dt);
    a.vy *= Math.pow(0.50, dt);

    a.x = wrap01(a.x + a.vx*dt);
    a.y = wrap01(a.y + a.vy*dt);

    a.boredom = clamp(a.boredom, 0, 5);
  }
}

// ---------- Rendering ----------
function drawPatternStamp(bits, x, y, sizePx, domain, alpha=200) {
  const cell = sizePx / P;
  noStroke();
  fill(domainColor(domain, alpha));
  for(let j=0;j<P;j++){
    for(let i=0;i<P;i++){
      if(!bits[j*P+i]) continue;
      rect(x + i*cell, y + j*cell, cell*0.92, cell*0.92, 2);
    }
  }
}

function drawVoid(v) {
  if(v.solved) return;
  const px = v.x*canvasW, py = v.y*canvasH;
  const r = voidRadiusPx(v);
  const col = domainColor(v.domain,255);

  noStroke();
  fill(red(col), green(col), blue(col), 40);
  circle(px, py, r*2.1);

  stroke(red(col), green(col), blue(col), 200);
  strokeWeight(2.2);
  fill(0,0,0,60);
  circle(px, py, r*2);

  noStroke();
  fill(red(col), green(col), blue(col), 18);
  circle(px, py, r*1.6);

  if(UI.chkPatterns.checked) {
    const stamp = Math.min(70, r*1.15);
    drawPatternStamp(v.bits, px-stamp/2, py-stamp/2, stamp, v.domain, 185);
  }

  noStroke();
  fill(240,240,255,210);
  textSize(11);
  textAlign(CENTER,CENTER);
  const ageSec = ((performance.now()-v.createdAt)/1000).toFixed(0);
  text(`${v.id} ${v.domain}  a:${v.area}  age:${ageSec}s`, px, py + r + 12);

  if(selected.kind==="void" && selected.id===v.id) {
    noFill();
    stroke(255,230,120,240);
    strokeWeight(2);
    circle(px, py, r*2.4);
  }
}

function drawEnergy(e) {
  const px=e.x*canvasW, py=e.y*canvasH;
  const t = (performance.now()-e.createdAt)/1000;
  const pulse = 0.75 + 0.25*Math.sin(t*2.1);
  const r = e.radiusPx*pulse;

  noStroke();
  fill(80,255,140,20);
  circle(px,py,r*2.4);
  fill(80,255,140,55);
  circle(px,py,r*2.0);

  stroke(80,255,140,190);
  strokeWeight(1.8);
  fill(0,0,0,35);
  circle(px,py,r*1.5);

  if(UI.chkPatterns.checked) {
    const stamp = Math.min(58, r*1.0);
    drawPatternStamp(e.bits, px-stamp/2, py-stamp/2, stamp, e.domain, 140);
  }

  const frac = clamp(e.amount/220.0, 0, 1);
  noStroke();
  fill(12,14,18,170);
  rect(px-22, py+r+8, 44, 6, 3);
  fill(80,255,140,220);
  rect(px-22, py+r+8, 44*frac, 6, 3);
}

function drawShard(sh) {
  const px=sh.x*canvasW, py=sh.y*canvasH;
  const col = domainColor(sh.domain,255);
  push();
  translate(px,py);
  rotate(Math.PI/4);
  noStroke();
  fill(red(col), green(col), blue(col), 210);
  rectMode(CENTER);
  rect(0,0,10,10,2);
  pop();
}

function drawSignal(sig) {
  // if play marker, use white-ish
  const play = sig.payload && sig.payload.play;
  const col = play ? color(230,230,255,255) : domainColor(sig.domain,255);
  const a = 1 - (sig.t/sig.ttl);
  const px=sig.x*canvasW, py=sig.y*canvasH;
  const r = (sig.t/sig.ttl)*160;

  noFill();
  stroke(red(col), green(col), blue(col), 160*a);
  strokeWeight(2);
  circle(px,py,r);

  if(sig.payload && sig.payload.invented) {
    stroke(red(col), green(col), blue(col), 220*a);
    strokeWeight(3.2);
    circle(px,py,r*0.55);
  }
}

function drawSolveBurst(b) {
  const px=b.x*canvasW, py=b.y*canvasH;
  const p = clamp(b.t / b.ttl, 0, 1);
  const ease = 1 - Math.pow(1 - p, 2);
  const col = domainColor(b.domain,255);
  const a = 1 - p;
  const r = 18 + 90*ease;

  push();
  blendMode(ADD);

  noFill();
  stroke(red(col), green(col), blue(col), 210*a);
  strokeWeight(2.2);
  circle(px,py,r*2.0);
  strokeWeight(1.2);
  circle(px,py,r*1.45);

  const rayCount = 12;
  const rayLen = 10 + 50*ease;
  stroke(red(col), green(col), blue(col), 170*a);
  strokeWeight(1.4);
  for(let i=0;i<rayCount;i++){
    const ang = b.spin + i*(TWO_PI/rayCount);
    const inner = r*0.4;
    const outer = r*0.4 + rayLen;
    line(px + Math.cos(ang)*inner, py + Math.sin(ang)*inner,
         px + Math.cos(ang)*outer, py + Math.sin(ang)*outer);
  }

  noStroke();
  fill(red(col), green(col), blue(col), 150*a);
  circle(px,py,14 + 18*(1-p));

  pop();
}

function agentBodyColors(a) {
  const d0 = a.primary.length ? a.primary[0] : "T";
  const d1 = a.primary.length>1 ? a.primary[1] : null;
  return { d0, d1 };
}

function drawAgent(a) {
  const px=a.x*canvasW, py=a.y*canvasH;
  const {d0,d1} = agentBodyColors(a);

  noStroke();
  fill(230,232,242,180);
  circle(px,py,12);

  stroke(domainColor(d0,255));
  strokeWeight(2.4);
  noFill();
  circle(px,py,14);

  if(d1) {
    noStroke();
    fill(domainColor(d1,235));
    circle(px+6, py-6, 5.5);
  }

  const ef = clamp(a.energy/100, 0, 1);
  noFill();
  stroke(80,255,140,120);
  strokeWeight(2);
  arc(px,py,18,18,-HALF_PI, -HALF_PI + TWO_PI*ef);

  if(UI.chkLinks.checked && a.target) {
    let tx=null, ty=null;
    if(a.target.kind==="void") {
      const v = voids.find(v => v.id===a.target.id && !v.solved);
      if(v) { tx=v.x*canvasW; ty=v.y*canvasH; }
    } else if(a.target.kind==="energy") {
      const e = energies.find(e => e.id===a.target.id);
      if(e) { tx=e.x*canvasW; ty=e.y*canvasH; }
    }
    if(tx!==null) {
      stroke(200,210,255,90);
      strokeWeight(1.2);
      line(px,py,tx,ty);
    }
  }

  if(selected.kind==="agent" && selected.id===a.id) {
    noFill();
    stroke(255,230,120,240);
    strokeWeight(2);
    circle(px,py,22);
  }
}

// ---------- Inspector preview drawing ----------
function drawPreviewCanvas(canvasEl, bits, domain) {
  const ctx = canvasEl.getContext("2d");
  const w=canvasEl.width, h=canvasEl.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#0c1017";
  ctx.fillRect(0,0,w,h);

  const pad=10;
  const size=Math.min(w,h)-pad*2;
  const cell=size/P;

  const rgb = DOMAIN_RGB[domain] || [220,220,220];

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1;
  for(let i=0;i<=P;i++){
    const x=pad+i*cell;
    ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,pad+size); ctx.stroke();
    const y=pad+i*cell;
    ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(pad+size,y); ctx.stroke();
  }

  ctx.fillStyle=`rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.85)`;
  for(let j=0;j<P;j++){
    for(let i=0;i<P;i++){
      const idx=j*P+i;
      if(!bits || !bits[idx]) continue;
      ctx.fillRect(pad+i*cell+1, pad+j*cell+1, cell-2, cell-2);
    }
  }

  ctx.strokeStyle=`rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.9)`;
  ctx.lineWidth=2;
  ctx.strokeRect(pad-1, pad-1, size+2, size+2);
}

// ---------- Mouse selection ----------
function findNearestAgent(u,v) {
  let best=null;
  for(const a of agents){
    const vv=torusVec(u,v,a.x,a.y);
    if(!best || vv.dist<best.dist) best={obj:a, dist:vv.dist};
  }
  return best;
}
function findNearestVoid(u,v) {
  let best=null;
  for(const vo of voids){
    if(vo.solved) continue;
    const vv=torusVec(u,v,vo.x,vo.y);
    if(!best || vv.dist<best.dist) best={obj:vo, dist:vv.dist};
  }
  return best;
}
function deleteSelected() {
  if(!selected.kind) return;
  if(selected.kind==="agent") agents = agents.filter(a => a.id!==selected.id);
  if(selected.kind==="void") voids = voids.filter(v => v.id!==selected.id);
  selected = {kind:null,id:null};
  refreshSelectionUI();
}
function mousePressed() {
  if(mouseX<0 || mouseX>=canvasW || mouseY<0 || mouseY>=canvasH) return;
  const u=mouseX/canvasW, v=mouseY/canvasH;
  const nearA=findNearestAgent(u,v);
  const nearV=findNearestVoid(u,v);

  const pxThresh=14;
  const dApx=nearA ? nearA.dist*Math.min(canvasW,canvasH) : 1e9;
  const dVpx=nearV ? nearV.dist*Math.min(canvasW,canvasH) : 1e9;
  const shift = keyIsDown(SHIFT);

  if(nearA && dApx<pxThresh && (!nearV || dApx<=dVpx)) {
    selected={kind:"agent",id:nearA.obj.id};
    if(shift) deleteSelected();
    refreshSelectionUI();
    return;
  }

  if(nearV) {
    const rpx=voidRadiusPx(nearV.obj);
    if(dVpx<rpx) {
      selected={kind:"void",id:nearV.obj.id};
      if(shift) deleteSelected();
      refreshSelectionUI();
      return;
    }
  }

  if(UI.chkAddAgent.checked) {
    addAgentAt(u,v,UI.spawnPreset.value);
    refreshSelectionUI();
  } else {
    selected={kind:null,id:null};
    refreshSelectionUI();
  }
}

// ---------- UI wiring ----------
function hookUI() {
  UI.pauseBtn=document.getElementById("pauseBtn");
  UI.resetBtn=document.getElementById("resetBtn");
  UI.configPreset=document.getElementById("configPreset");
  UI.btnApplyPreset=document.getElementById("btnApplyPreset");

  UI.sSpeed=document.getElementById("sSpeed");
  UI.sEntropy=document.getElementById("sEntropy");
  UI.chkSignals=document.getElementById("chkSignals");
  UI.chkPatterns=document.getElementById("chkPatterns");
  UI.chkLinks=document.getElementById("chkLinks");

  UI.chkMemes=document.getElementById("chkMemes");
  UI.chkPlay=document.getElementById("chkPlay");
  UI.chkRewards=document.getElementById("chkRewards");

  UI.sVoids=document.getElementById("sVoids");
  UI.sEnergy=document.getElementById("sEnergy");
  UI.sSpawn=document.getElementById("sSpawn");
  UI.sGrow=document.getElementById("sGrow");
  UI.btnAddVoid=document.getElementById("btnAddVoid");
  UI.btnAddEnergy=document.getElementById("btnAddEnergy");

  UI.sAgents=document.getElementById("sAgents");
  UI.spawnPreset=document.getElementById("spawnPreset");
  UI.chkAddAgent=document.getElementById("chkAddAgent");
  UI.btnAdd10=document.getElementById("btnAdd10");
  UI.btnClearSel=document.getElementById("btnClearSel");

  UI.selHeader=document.getElementById("selHeader");
  UI.voidPreview=document.getElementById("voidPreview");
  UI.keyPreview=document.getElementById("keyPreview");
  UI.voidInfo=document.getElementById("voidInfo");
  UI.keyInfo=document.getElementById("keyInfo");
  UI.selDetails=document.getElementById("selDetails");

  UI.btnDeleteSel=document.getElementById("btnDeleteSel");
  UI.btnGiveEnergy=document.getElementById("btnGiveEnergy");

  UI.configPreset.innerHTML="";
  for(const name of CONFIG_PRESET_NAMES){
    const opt=document.createElement("option");
    opt.value=name; opt.textContent=name;
    UI.configPreset.appendChild(opt);
  }
  UI.configPreset.value=CONFIG_PRESET_NAMES[0];

  UI.spawnPreset.innerHTML="";
  for(const name of SPAWN_PRESETS){
    const opt=document.createElement("option");
    opt.value=name; opt.textContent=name;
    UI.spawnPreset.appendChild(opt);
  }
  UI.spawnPreset.value="Mixed";

  function refreshLabels() {
    document.getElementById("lblSpeed").textContent=parseFloat(UI.sSpeed.value).toFixed(2);
    document.getElementById("lblEnt").textContent=parseFloat(UI.sEntropy.value).toFixed(2);
    document.getElementById("lblVoids").textContent=parseInt(UI.sVoids.value);
    document.getElementById("lblEnergy").textContent=parseInt(UI.sEnergy.value);
    document.getElementById("lblSpawn").textContent=parseFloat(UI.sSpawn.value).toFixed(2);
    document.getElementById("lblGrow").textContent=parseFloat(UI.sGrow.value).toFixed(2);
    document.getElementById("lblAgents").textContent=parseInt(UI.sAgents.value);
  }
  refreshLabels();

  function syncParams() {
    PARAMS.speed=parseFloat(UI.sSpeed.value);
    PARAMS.entropyPressure=parseFloat(UI.sEntropy.value);
    PARAMS.showSignals=UI.chkSignals.checked;
    PARAMS.showPatterns=UI.chkPatterns.checked;
    PARAMS.showLinks=UI.chkLinks.checked;

    PARAMS.enableMemes=UI.chkMemes.checked;
    PARAMS.enablePlay=UI.chkPlay.checked;
    PARAMS.enableRewards=UI.chkRewards.checked;

    PARAMS.desiredVoids=parseInt(UI.sVoids.value);
    PARAMS.desiredEnergy=parseInt(UI.sEnergy.value);
    PARAMS.voidSpawnRate=parseFloat(UI.sSpawn.value);
    PARAMS.voidGrowthRate=parseFloat(UI.sGrow.value);

    PARAMS.desiredAgents=parseInt(UI.sAgents.value);
    PARAMS.addAgentByClick=UI.chkAddAgent.checked;
    PARAMS.spawnPreset=UI.spawnPreset.value;
  }

  function applyConfigPreset(name) {
    const p = CONFIG_PRESETS[name];
    if(!p) return;
    UI.sSpeed.value = String(p.speed);
    UI.sVoids.value = p.voids;
    UI.sEnergy.value = p.energy;
    UI.sAgents.value = p.agents;
    if(p.spawn !== undefined) UI.sSpawn.value = p.spawn;
    if(p.grow !== undefined) UI.sGrow.value = p.grow;
    refreshLabels();
    syncParams();
    resetWorld();
  }

  ["input","change"].forEach(evt => {
    [
      UI.sSpeed, UI.sEntropy, UI.chkSignals, UI.chkPatterns, UI.chkLinks,
      UI.chkMemes, UI.chkPlay, UI.chkRewards,
      UI.sVoids, UI.sEnergy, UI.sSpawn, UI.sGrow,
      UI.sAgents, UI.spawnPreset, UI.chkAddAgent
    ].forEach(el => el.addEventListener(evt, () => { refreshLabels(); syncParams(); }));
  });

  UI.pauseBtn.addEventListener("click", () => togglePause());
  UI.resetBtn.addEventListener("click", () => resetWorld());
  UI.btnApplyPreset.addEventListener("click", () => applyConfigPreset(UI.configPreset.value));

  UI.btnAddVoid.addEventListener("click", () => voids.push(makeVoid(Math.random(), Math.random(), randChoice(DOMAINS))));
  UI.btnAddEnergy.addEventListener("click", () => energies.push(makeEnergy(Math.random(), Math.random(), randChoice(DOMAINS))));

  UI.btnAdd10.addEventListener("click", () => {
    for(let i=0;i<10;i++){
      const preset = randChoice(SPAWN_PRESETS.filter(p=>p!=="Mixed")) || "Mixed";
      addAgentAt(Math.random(), Math.random(), preset);
    }
    UI.sAgents.value = agents.length;
    refreshLabels(); syncParams();
  });

  UI.btnClearSel.addEventListener("click", () => { selected={kind:null,id:null}; refreshSelectionUI(); });
  UI.btnDeleteSel.addEventListener("click", () => deleteSelected());
  UI.btnGiveEnergy.addEventListener("click", () => {
    if(selected.kind==="agent") {
      const a = agents.find(x=>x.id===selected.id);
      if(a) a.energy = Math.min(100, a.energy+20);
    }
    refreshSelectionUI();
  });

  window.addEventListener("keydown", (e) => {
    if(e.code==="Space") { togglePause(); e.preventDefault(); }
    if(e.key.toLowerCase()==="d") deleteSelected();
    if(e.key.toLowerCase()==="r") resetWorld();
  });

  syncParams();
}

function togglePause() {
  paused = !paused;
  UI.pauseBtn.textContent = paused ? "Resume" : "Pause";
  lastT = performance.now();
}

function addAgentAt(u,v,presetName){
  const preset = presetName || "Mixed";
  agents.push(makeAgent(u,v,preset));
  selected = { kind:"agent", id: agents[agents.length-1].id };
}

// ---------- Reset ----------
function resetWorld() {
  initBaseShapes();

  voids=[]; energies=[]; shards=[]; signals=[]; solveBursts=[]; agents=[];
  selected={kind:null,id:null};
  worldChaos=0;

  for(let i=0;i<PARAMS.desiredVoids;i++) voids.push(makeVoid(Math.random(), Math.random(), randChoice(DOMAINS)));
  for(let i=0;i<PARAMS.desiredEnergy;i++) energies.push(makeEnergy(Math.random(), Math.random(), randChoice(DOMAINS)));

  for(let i=0;i<PARAMS.desiredAgents;i++){
    const preset = (PARAMS.spawnPreset==="Mixed")
      ? randChoice(["Double Observer (S+N)","Double Decider (T+F)","Sensor (S)","Intuitive (N)","Thinker (T)","Feeler (F)","Extro Gatherer","Intro Refiner"])
      : PARAMS.spawnPreset;
    agents.push(makeAgent(Math.random(), Math.random(), preset));
  }

  UI.sAgents.value = agents.length;
  UI.sVoids.value = PARAMS.desiredVoids;
  UI.sEnergy.value = PARAMS.desiredEnergy;
  refreshSelectionUI();
  lastT = performance.now();
}

// ---------- Selection UI ----------
function refreshSelectionUI() {
  drawPreviewCanvas(UI.voidPreview, new Uint8Array(Pn), "T");
  drawPreviewCanvas(UI.keyPreview, new Uint8Array(Pn), "T");
  UI.voidInfo.textContent="—";
  UI.keyInfo.textContent="—";

  if(!selected.kind) {
    UI.selHeader.textContent="None";
    UI.selDetails.innerHTML="—";
    return;
  }

  if(selected.kind==="agent") {
    const a = agents.find(x=>x.id===selected.id);
    if(!a) { selected={kind:null,id:null}; refreshSelectionUI(); return; }

    UI.selHeader.innerHTML = `<b>Agent</b> <span class="mono">${a.id}</span> (${a.preset})`;

    let tv=null;
    if(a.target && a.target.kind==="void") tv = voids.find(v=>v.id===a.target.id && !v.solved) || null;

    let best=null;
    if(tv) best = agentBestKeyFor(a, tv.domain, tv.bits);

    if(tv) {
      drawPreviewCanvas(UI.voidPreview, tv.bits, tv.domain);
      const ageSec = ((performance.now()-tv.createdAt)/1000).toFixed(0);
      UI.voidInfo.innerHTML = `<b>${tv.id}</b> ${DOMAIN_NAME[tv.domain]} (${tv.domain})<br/>Area: <b>${tv.area}</b> | Age: ${ageSec}s | Sev: ${tv.severity.toFixed(2)}`;
    } else {
      UI.voidInfo.textContent="No current void target.";
    }

    if(best) {
      drawPreviewCanvas(UI.keyPreview, best.shape.bits, best.shape.domain);
      const charges = best.meta ? best.meta.charges : 0;
      UI.keyInfo.innerHTML =
        `<b>${best.shape.id}</b> ${DOMAIN_NAME[best.shape.domain]} (${best.shape.domain})<br/>Match: <b>${(best.score*100).toFixed(1)}%</b> | Rarity: ${best.shape.rarity} | Charges: <b>${charges}</b>`;
    } else {
      UI.keyInfo.textContent="No matching usable key for current target.";
    }

    const animals = deriveAnimals(a);
    const pri = a.primary.map(d=>`<span class="badge" style="border-color: rgba(${DOMAIN_RGB[d].join(",")},1)">${d}</span>`).join("");
    const sec = a.secondary.length ? a.secondary.map(d=>`<span class="badge">${d}</span>`).join("") : `<span class="badge">—</span>`;

    // keys top
    const keysArr = [];
    for(const [id,m] of a.keys.entries()) {
      const sh = getShape(id);
      if(!sh) continue;
      keysArr.push({id,sh,m,score:(m.uses*2)+(m.charges*1.2)+(sh.rarity==="rare"?1.2:0)});
    }
    keysArr.sort((A,B)=>B.score-A.score);
    const keyLines = keysArr.slice(0,8).map(k => {
      const d=k.sh.domain;
      return `• <span class="mono">${k.id}</span> <span class="badge" style="border-color: rgba(${DOMAIN_RGB[d].join(",")},1)">${d}</span> ${k.sh.rarity}
              <span class="tiny">(chg:${k.m.charges}, ttl:${k.m.ttl.toFixed(0)}s, uses:${k.m.uses})</span>`;
    }).join("<br/>") || "—";

    // void memory top
    const memArr = Array.from(a.voidMem.values());
    memArr.sort((A,B)=>B.area-A.area);
    const memLines = memArr.slice(0,8).map(e => {
      const age = ((performance.now()-e.lastSeen)/1000).toFixed(0);
      const c = DOMAIN_RGB[e.domain];
      return `• <span class="mono">${e.id}</span> <span class="badge" style="border-color: rgba(${c[0]},${c[1]},${c[2]},1)">${e.domain}</span>
              area:${e.area} <span class="tiny">(seen ${age}s ago)</span>`;
    }).join("<br/>") || "—";

    UI.selDetails.innerHTML = `
      <div><b>Energy</b>: ${a.energy.toFixed(1)} | <b>Health</b>: ${a.health.toFixed(1)} | <b>State</b>: ${a.state}</div>
      <div><b>Target</b>: ${a.target ? `${a.target.kind}:${a.target.id}` : "none"} | <b>Boredom</b>: ${a.boredom.toFixed(2)}</div>
      <div style="margin-top:6px"><b>Primary</b>: ${pri}</div>
      <div style="margin-top:6px"><b>Secondary</b>: ${sec}</div>
      <div style="margin-top:6px"><b>Animals</b> (approx): Consume ${animals.consume.toFixed(2)} | Play ${animals.play.toFixed(2)} | Sleep ${animals.sleep.toFixed(2)} | Blast ${animals.blast.toFixed(2)}</div>
      <div style="margin-top:6px"><b>Void memory</b> (${a.voidMem.size}/${a.voidMemLimit})</div>
      <div class="mono tiny" style="margin-top:4px">${memLines}</div>
      <div style="margin-top:8px"><b>Key memes</b> (${a.keys.size}/${a.storageLimit})</div>
      <div class="mono tiny" style="margin-top:4px">${keyLines}</div>
    `;
    return;
  }

  if(selected.kind==="void") {
    const v = voids.find(x=>x.id===selected.id);
    if(!v) { selected={kind:null,id:null}; refreshSelectionUI(); return; }

    UI.selHeader.innerHTML = `<b>Void</b> <span class="mono">${v.id}</span> (${DOMAIN_NAME[v.domain]} / ${v.domain})`;
    drawPreviewCanvas(UI.voidPreview, v.bits, v.domain);

    const ageSec = ((performance.now()-v.createdAt)/1000).toFixed(0);
    UI.voidInfo.innerHTML = `<b>${v.id}</b> ${DOMAIN_NAME[v.domain]} (${v.domain})<br/>Area: <b>${v.area}</b> | Init: ${v.area0} | Age: ${ageSec}s | Sev: ${v.severity.toFixed(2)}`;

    // best global fit
    let bestGlobal=null;
    for(const sh of shapesBy(v.domain)) {
      const s = matchScore(sh.bits, v.bits);
      if(!bestGlobal || s>bestGlobal.score) bestGlobal={shape:sh, score:s};
    }
    if(bestGlobal) {
      drawPreviewCanvas(UI.keyPreview, bestGlobal.shape.bits, bestGlobal.shape.domain);
      UI.keyInfo.innerHTML = `<b>${bestGlobal.shape.id}</b> (${bestGlobal.shape.domain}) | ${bestGlobal.shape.rarity}<br/>Best global fit: <b>${(bestGlobal.score*100).toFixed(1)}%</b>`;
    } else {
      UI.keyInfo.textContent="—";
    }

    UI.selDetails.innerHTML = `
      <div class="tiny">
        v2 mechanics: applying a key consumes a <b>charge</b>. Useful keys replicate (gain charges).
        Unused keys decay (lose charges). Agents also store voids in memory and exchange them in Play.
      </div>
    `;
  }
}

// ---------- Setup/draw ----------
function setup() {
  canvasW = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
  canvasH = windowHeight;
  createCanvas(canvasW, canvasH);
  textFont("system-ui");
  hookUI();
  initBaseShapes();
  resetWorld();
  lastT = performance.now();
}

function windowResized() {
  canvasW = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
  canvasH = windowHeight;
  resizeCanvas(canvasW, canvasH);
}

function drawHUD(dt) {
  const activeVoids = voids.filter(v=>!v.solved).length;
  const totalArea = voids.reduce((s,v)=>s+(v.solved?0:v.area),0);
  const avgEnergy = agents.length ? agents.reduce((s,a)=>s+a.energy,0)/agents.length : 0;

  // collective awareness: fraction of active voids known by at least one agent
  const known = new Set();
  for(const a of agents) for(const id of a.voidMem.keys()) known.add(id);
  const totalActiveIds = voids.filter(v=>!v.solved).map(v=>v.id);
  let covered=0;
  for(const id of totalActiveIds) if(known.has(id)) covered++;
  const coverage = totalActiveIds.length ? (covered/totalActiveIds.length) : 1;

  document.getElementById("hud").innerHTML = `
    <div><b>Agents</b>: ${agents.length} | <b>Voids</b>: ${activeVoids} | <b>Energy</b>: ${energies.length}</div>
    <div><b>Total void area</b>: ${totalArea} | <b>World chaos</b>: ${worldChaos.toFixed(2)} | <b>Avg energy</b>: ${avgEnergy.toFixed(1)}</div>
    <div><b>Collective awareness</b>: ${(coverage*100).toFixed(1)}%</div>
    <div class="tiny">dt: ${(dt*1000).toFixed(1)} ms | fps: ${Math.round(frameRate())}</div>
  `;
}

function draw() {
  const now = performance.now();
  let dt = (now - lastT) / 1000;
  lastT = now;
  dt = Math.min(dt, 0.05);
  if(paused) dt = 0;
  dt *= PARAMS.speed;

  if(dt > 0) {
    // adjust agent count towards target
    while(agents.length < PARAMS.desiredAgents) {
      const preset = (PARAMS.spawnPreset==="Mixed")
        ? randChoice(["Double Observer (S+N)","Double Decider (T+F)","Sensor (S)","Intuitive (N)","Thinker (T)","Feeler (F)","Extro Gatherer","Intro Refiner"])
        : PARAMS.spawnPreset;
      agents.push(makeAgent(Math.random(), Math.random(), preset));
    }
    while(agents.length > PARAMS.desiredAgents) {
      const removed = agents.pop();
      if(selected.kind==="agent" && removed && selected.id===removed.id) selected={kind:null,id:null};
    }

    worldStep(dt);
    agentsStep(dt);
  }

  background(11,13,18);

  if(UI.chkSignals.checked) for(const s of signals) drawSignal(s);
  for(const e of energies) drawEnergy(e);
  for(const sh of shards) drawShard(sh);
  for(const v of voids) drawVoid(v);
  for(const b of solveBursts) drawSolveBurst(b);
  for(const a of agents) drawAgent(a);

  if(frameCount % 6 === 0) refreshSelectionUI();
  drawHUD(dt);
}
</script>
</body>
</html>
