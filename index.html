<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BCM v2 ‚Äî Voids (Locks) + Energy (Harvest) + Keys (Compose/Transfer) + Stable Movement</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    :root { --uiw: 460px; }
    html, body { margin:0; height:100%; background:#0e0f12; color:#e8eaf1; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    #ui{
      position:fixed; top:0; right:0; width:var(--uiw); height:100%;
      overflow:auto; box-sizing:border-box; padding:14px 14px 120px;
      background:#14161b; border-left:1px solid #1e2230;
    }
    #ui h2{ margin:6px 0 10px; font-size:16px; font-weight:700; }
    .group{ border:1px solid #1f2535; border-radius:10px; padding:10px; margin-bottom:12px; background:#10131a; }
    label{ display:block; font-size:12px; opacity:.9; margin:6px 0 4px; }
    input[type="range"]{ width:100%; }
    button, select{
      width:100%; border-radius:8px; border:1px solid #2a3248;
      padding:8px 10px; background:#18202d; color:#e8eaf1; cursor:pointer;
    }
    button:hover{ background:#1c2737; }
    .row{ display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    details summary{ cursor:pointer; user-select:none; }
    pre{
      white-space:pre-wrap; background:#0c0f16; border:1px solid #1f2535;
      border-radius:8px; padding:10px; color:#d6dbef; font-size:12px; line-height:1.35;
    }
    #metrics{
      position:fixed; left:10px; top:10px;
      background:rgba(8,10,14,.78); border:1px solid #1e2230; border-radius:8px;
      padding:8px 10px; backdrop-filter:blur(6px);
      max-width:520px;
    }
    canvas{ display:block; }
    .tiny{ font-size:11px; opacity:.85; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>

<body>

<div id="ui">
  <h2>BCM v2 ‚Äî Harvest ‚Üí Spend ‚Üí Adapt (stable movement)</h2>

  <div class="group">
    <div class="row">
      <button id="btnPause">Pause</button>
      <button id="btnReset">Reset</button>
    </div>
    <div class="tiny" style="margin-top:6px">
      Shortcuts: <span class="mono">Space</span>=pause, <span class="mono">R</span>=reset, <span class="mono">V</span>=spawn void, <span class="mono">E</span>=spawn energy
    </div>
  </div>

  <div class="group">
    <label>Sim speed: <span id="lblSpeed">1.00</span></label>
    <input id="sSpeed" type="range" min="0.2" max="5" step="0.01" value="1.00" />
    <label>Agents: <span id="lblAgents">40</span></label>
    <input id="sAgents" type="range" min="1" max="160" step="1" value="40" />
    <label>Key storage limit per agent: <span id="lblKCap">8</span></label>
    <input id="sKCap" type="range" min="2" max="18" step="1" value="8" />
    <label><input id="chkTrails" type="checkbox" checked /> Trails</label>
    <label><input id="chkSignals" type="checkbox" checked /> Signals (ripples)</label>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Movement Stabilizers</h3>
    <label>Energy Low (switch to Harvest): <span id="lblELow">0.30</span></label>
    <input id="sELow" type="range" min="0.05" max="0.80" step="0.01" value="0.30" />
    <label>Energy High (switch back to Solve): <span id="lblEHigh">0.55</span></label>
    <input id="sEHigh" type="range" min="0.10" max="1.20" step="0.01" value="0.55" />
    <label>Commit time (sec): <span id="lblCommit">2.5</span></label>
    <input id="sCommit" type="range" min="0" max="10" step="0.1" value="2.5" />
    <label>Switch margin (√ó): <span id="lblMargin">1.25</span></label>
    <input id="sMargin" type="range" min="1.00" max="2.50" step="0.01" value="1.25" />
    <div class="tiny">
      The ‚Äúbounce‚Äù happens when decisions re-flip every frame. These four controls stop that.
    </div>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Voids (Locks)</h3>
    <label>Spawn rate / min: <span id="lblVoidRate">18</span></label>
    <input id="sVoidRate" type="range" min="0" max="120" step="1" value="18" />
    <label>Max active voids: <span id="lblVoidMax">36</span></label>
    <input id="sVoidMax" type="range" min="0" max="140" step="1" value="36" />
    <label>Growth rate: <span id="lblVoidGrow">0.05</span></label>
    <input id="sVoidGrow" type="range" min="0" max="0.25" step="0.005" value="0.05" />
    <label>Solve threshold (area %): <span id="lblSolveThr">20</span></label>
    <input id="sSolveThr" type="range" min="1" max="60" step="1" value="20" />
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Energy (Harvest)</h3>
    <label>Spawn rate / min: <span id="lblERate">22</span></label>
    <input id="sERate" type="range" min="0" max="180" step="1" value="22" />
    <label>Max active sources: <span id="lblEMax">45</span></label>
    <input id="sEMax" type="range" min="0" max="200" step="1" value="45" />
    <label>Harvest rate: <span id="lblHarvest">0.35</span></label>
    <input id="sHarvest" type="range" min="0" max="1.2" step="0.01" value="0.35" />
    <label>Energy spend (solve): <span id="lblSpend">0.20</span></label>
    <input id="sSpend" type="range" min="0" max="1.0" step="0.01" value="0.20" />
    <div class="tiny">
      Energy sources are patterns. Keys match them to harvest. Solving also costs energy.
    </div>
  </div>

  <div class="group">
    <h3 style="margin:6px 0 6px; font-size:13px">Key Evolution</h3>
    <label>Try compose keys when stuck: <span id="lblCompose">On</span></label>
    <select id="selCompose">
      <option value="on" selected>On</option>
      <option value="off">Off</option>
    </select>
    <label>Compose cost: <span id="lblComposeCost">0.55</span></label>
    <input id="sComposeCost" type="range" min="0" max="2.0" step="0.01" value="0.55" />
    <div class="tiny">
      Composition is geometric OR (A ‚à™ B). It creates a new ‚Äútool shape‚Äù in the library.
    </div>
  </div>

  <div class="group tiny">
    <div><b>Legend</b></div>
    <div>üü• void (lock) ‚Äî stamp shows remaining unsolved cells</div>
    <div>üü© energy source ‚Äî stamp shows harvest pattern, ring shows remaining amount</div>
    <div>‚óè agent ‚Äî color shifts with energy; tiny label shows mode: S/H</div>
    <div>Ripples: greener = key helped, orange = did nothing / worsened</div>
  </div>
</div>

<div id="metrics"></div>

<script>
/* =========================================================
   BCM v2 (stable movement patch)
   - Modes: Solve vs Harvest with hysteresis thresholds
   - Targets: commitment time + switch margin
   - Smooth steering: velocity-based motion
   - Locks/keys: 7x7 bit patterns, gradual solve, optional worsening
========================================================= */

let W, H, trails;
let paused = false;
let simTime = 0;

const UI = {};
const SHAPE_N = 7;
const SHAPE_C = SHAPE_N * SHAPE_N;

let SHAPES = [];           // {name, cells:Int8Array, mass}
let COMMON = [];           // indices in SHAPES
let nextVoidId = 1;
let nextKeyId = 1;
let nextEnergyId = 1;

let agents = [];
let voids = [];
let energySources = [];
let signals = [];          // {x,y,t,ttl, payload:{voidId, areaB, keyId, areaA, shapeId, delta}}

function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function wrap01(u){ u = u % 1; if (u < 0) u += 1; return u; }
function wrapDelta(d){ if (d > 0.5) d -= 1; if (d < -0.5) d += 1; return d; }
function torusVec(ax, ay, bx, by){
  const dx = wrapDelta(bx-ax), dy = wrapDelta(by-ay);
  return {dx, dy, d: Math.hypot(dx,dy)};
}

function idxS(x,y){ return y*SHAPE_N + x; }
function cloneCells(c){ const o = new Int8Array(c.length); o.set(c); return o; }

function shapeMass(c){
  let m=0; for (let i=0;i<c.length;i++) m += c[i] ? 1 : 0;
  return m;
}
function shapeOR(a,b){
  const o = new Int8Array(SHAPE_C);
  for (let i=0;i<SHAPE_C;i++) o[i] = (a[i] || b[i]) ? 1 : 0;
  return o;
}

function randomShape(density=0.22, smoothPasses=2){
  let c = new Int8Array(SHAPE_C);
  for (let y=0;y<SHAPE_N;y++){
    for (let x=0;x<SHAPE_N;x++){
      const cx = (x-(SHAPE_N-1)/2)/(SHAPE_N/2);
      const cy = (y-(SHAPE_N-1)/2)/(SHAPE_N/2);
      const centerBias = Math.exp(-(cx*cx+cy*cy)*1.2);
      const p = density*(0.65 + 0.7*centerBias);
      c[idxS(x,y)] = (Math.random() < p) ? 1 : 0;
    }
  }
  for (let pass=0; pass<smoothPasses; pass++){
    const n = new Int8Array(SHAPE_C);
    for (let y=0;y<SHAPE_N;y++){
      for (let x=0;x<SHAPE_N;x++){
        let sum=0;
        for (let oy=-1;oy<=1;oy++){
          for (let ox=-1;ox<=1;ox++){
            if (!ox && !oy) continue;
            const xx=x+ox, yy=y+oy;
            if (xx<0||xx>=SHAPE_N||yy<0||yy>=SHAPE_N) continue;
            sum += c[idxS(xx,yy)];
          }
        }
        const here = c[idxS(x,y)];
        n[idxS(x,y)] = (sum>=4) ? 1 : (sum<=1 ? 0 : here);
      }
    }
    c = n;
  }
  if (shapeMass(c) < 6){
    for (let i=0;i<SHAPE_C;i++) c[i]=0;
    const mid = Math.floor(SHAPE_N/2);
    for (let x=1;x<SHAPE_N-1;x++) c[idxS(x,mid)] = 1;
    for (let y=1;y<SHAPE_N-1;y++) c[idxS(mid,y)] = 1;
  }
  return c;
}

function matchKeyToPattern(keyCells, patternCells){
  let fill=0, spill=0, mass=0;
  for (let i=0;i<SHAPE_C;i++){
    const p = patternCells[i];
    const k = keyCells[i];
    if (p) mass++;
    if (k){
      if (p) fill++;
      else spill++;
    }
  }
  const score = (fill - 1.25*spill) / (mass + 1e-6);
  const good = clamp01((score + 1) / 2);
  const bad  = clamp01((-score));
  return {fill, spill, mass, score, good, bad};
}

function initShapes(){
  SHAPES = [];
  COMMON = [];

  const mid = Math.floor(SHAPE_N/2);
  const blank = () => new Array(SHAPE_C).fill(0);
  const set = (c,x,y) => { if (x>=0&&x<SHAPE_N&&y>=0&&y<SHAPE_N) c[idxS(x,y)] = 1; };

  // plus
  {
    const c = blank();
    for (let x=1;x<SHAPE_N-1;x++) set(c,x,mid);
    for (let y=1;y<SHAPE_N-1;y++) set(c,mid,y);
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"plus", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }
  // ring
  {
    const c = blank();
    for (let x=1;x<SHAPE_N-1;x++){ set(c,x,1); set(c,x,SHAPE_N-2); }
    for (let y=1;y<SHAPE_N-1;y++){ set(c,1,y); set(c,SHAPE_N-2,y); }
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"ring", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }
  // diag
  {
    const c = blank();
    for (let i=1;i<SHAPE_N-1;i++) set(c,i,i);
    set(c,mid,mid-1); set(c,mid-1,mid);
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"diag", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }
  // L
  {
    const c = blank();
    for (let y=1;y<SHAPE_N-1;y++) set(c,1,y);
    for (let x=1;x<SHAPE_N-1;x++) set(c,x,SHAPE_N-2);
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"L", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }
  // blob
  {
    const c = blank();
    for (let y=2;y<=4;y++) for (let x=2;x<=4;x++) set(c,x,y);
    set(c,1,3); set(c,5,3); set(c,3,1); set(c,3,5);
    const cells = new Int8Array(c);
    const id = SHAPES.length;
    SHAPES.push({name:"blob", cells, mass:shapeMass(cells)});
    COMMON.push(id);
  }

  for (let i=0;i<10;i++){
    const rc = randomShape(0.20 + 0.10*Math.random(), 2);
    SHAPES.push({name:"rand"+i, cells:rc, mass:shapeMass(rc)});
  }
}

function makeKey(shapeId){
  return {
    keyId: nextKeyId++,
    shapeId,
    cells: SHAPES[shapeId].cells,
    uses: 0,
    createdAt: simTime
  };
}
function agentHasShape(agent, shapeId){
  return agent.keys.some(k => k.shapeId === shapeId);
}
function ensureStorage(agent){
  const cap = parseInt(UI.sKCap.value);
  while (agent.keys.length > cap){
    agent.keys.sort((a,b) => (a.uses - b.uses) || (a.createdAt - b.createdAt));
    agent.keys.shift();
  }
}

function createAgent(x,y){
  const a = {
    x, y, vx:0, vy:0,
    energy: 0.65 + 0.25*Math.random(),
    maxEnergy: 1.50,
    keys: [],
    memory: new Map(),      // voidId -> {obs:[]}
    pulse: 0,

    // movement stabilizers
    mode: null,             // "solve" or "harvest"
    targetType: null,       // "void"|"energy"|null
    targetId: null,
    lockUntil: 0,           // simTime until which target is ‚Äúcommitted‚Äù
    lastScore: 0,
  };

  const kCommon = 3;
  for (let i=0;i<kCommon;i++){
    const sid = COMMON[Math.floor(Math.random()*COMMON.length)];
    if (!agentHasShape(a, sid)) a.keys.push(makeKey(sid));
  }
  const sidR = Math.floor(COMMON.length + Math.random()*(SHAPES.length-COMMON.length));
  a.keys.push(makeKey(sidR));
  ensureStorage(a);

  // initial mode
  a.mode = (a.energy < parseFloat(UI.sELow.value)) ? "harvest" : "solve";
  return a;
}

function resetAll(){
  paused = false;
  simTime = 0;
  UI.btnPause.textContent = "Pause";

  nextVoidId = 1;
  nextKeyId = 1;
  nextEnergyId = 1;
  voids = [];
  energySources = [];
  signals = [];
  trails.clear();

  initShapes();

  agents = [];
  const n = parseInt(UI.sAgents.value);
  for (let i=0;i<n;i++) agents.push(createAgent(Math.random(), Math.random()));
}

function spawnVoid(){
  const maxV = parseInt(UI.sVoidMax.value);
  if (voids.length >= maxV) return;

  const rarity = clamp01(Math.random()*Math.random());
  const complex = (rarity > 0.65 && Math.random() < 0.6) ? 2 : 1;

  const subCount = complex + (Math.random()<0.25 ? 1 : 0); // 1..3
  let merged = new Int8Array(SHAPE_C);
  const subs = [];
  for (let i=0;i<subCount;i++){
    const shapeId = (rarity < 0.45)
      ? COMMON[Math.floor(Math.random()*COMMON.length)]
      : Math.floor(Math.random()*SHAPES.length);
    const cells = cloneCells(SHAPES[shapeId].cells);
    subs.push({shapeId, cells});
    merged = shapeOR(merged, cells);
  }

  const baseR = 0.030 + 0.018*complex;
  const r = baseR * (0.8 + 0.8*Math.random());

  const v = {
    id: nextVoidId++,
    x: Math.random(),
    y: Math.random(),
    r,
    rarity,
    complex,
    subs,
    cells: merged,
    mass0: Math.max(1, shapeMass(merged)),
    age: 0
  };
  voids.push(v);
}

function spawnEnergy(){
  const maxE = parseInt(UI.sEMax.value);
  if (energySources.length >= maxE) return;

  const rare = Math.random() < 0.25;
  const shapeId = rare
    ? Math.floor(Math.random()*SHAPES.length)
    : COMMON[Math.floor(Math.random()*COMMON.length)];

  const amount = 0.55 + 0.65*Math.random();
  const r = 0.028 + 0.020*(rare ? 1 : 0) + 0.010*Math.random();

  energySources.push({
    id: nextEnergyId++,
    x: Math.random(),
    y: Math.random(),
    r,
    shapeId,
    cells: SHAPES[shapeId].cells,
    amount0: amount,
    amount: amount,
    age: 0
  });
}

function growVoid(v, dt){
  const g = parseFloat(UI.sVoidGrow.value);
  v.age += dt;
  if (Math.random() < g*dt*(0.25 + 0.8*v.rarity)){
    const sid = (Math.random()<0.7) ? v.subs[Math.floor(Math.random()*v.subs.length)].shapeId : Math.floor(Math.random()*SHAPES.length);
    const src = SHAPES[sid].cells;
    const i = Math.floor(Math.random()*SHAPE_C);
    if (src[i]) v.cells[i] = 1;
  }
}

function bestKey(agent, patternCells){
  let best = null;
  for (const k of agent.keys){
    const m = matchKeyToPattern(k.cells, patternCells);
    if (!best || m.score > best.m.score) best = {k, m};
  }
  return best;
}

function applyKeyToVoid(v, key, dt, agentSpend){
  const m = matchKeyToPattern(key.cells, v.cells);
  const areaB = shapeMass(v.cells);
  if (areaB <= 0) return {areaB, areaA: 0, m, spend:0};

  // energy cost increases with mismatch and wrong overlap
  const spend = agentSpend * dt * (0.35 + 1.2*(1-m.good) + 0.9*m.bad);
  key.uses++;

  // removal probability increases with match goodness and spend
  const p = clamp01((0.10 + 0.85*m.good) * spend * 2.8);

  const newCells = cloneCells(v.cells);
  for (let i=0;i<SHAPE_C;i++){
    if (v.cells[i] && key.cells[i]){
      if (Math.random() < p) newCells[i] = 0;
    }
  }

  // OPTIONAL ‚Äúwrong key can worsen‚Äù:
  // If the key spills a lot (hits non-void bits) and match is poor, it can add noise back in.
  // This makes the metaphor closer to ‚Äúbad tool creates new problems‚Äù.
  const worsenChance = clamp01(0.12*m.bad + 0.02*(m.spill/(m.mass+1e-6)));
  if (Math.random() < worsenChance * dt * 2.0){
    const sid = (Math.random()<0.5) ? COMMON[Math.floor(Math.random()*COMMON.length)] : Math.floor(Math.random()*SHAPES.length);
    const src = SHAPES[sid].cells;
    for (let k2=0;k2<2;k2++){
      const i = Math.floor(Math.random()*SHAPE_C);
      if (src[i]) newCells[i] = 1;
    }
  }

  v.cells = newCells;
  const areaA = shapeMass(v.cells);
  return {areaB, areaA, m, spend};
}

function harvestEnergy(e, key, dt){
  const m = matchKeyToPattern(key.cells, e.cells);
  const rate = parseFloat(UI.sHarvest.value);
  const take = Math.min(e.amount, rate * dt * (0.10 + 1.1*m.good));
  e.amount -= take;
  key.uses++;
  return {take, m};
}

function maybeCompose(agent, v){
  if (UI.selCompose.value !== "on") return false;
  if (agent.keys.length < 2) return false;

  const composeCost = parseFloat(UI.sComposeCost.value);
  if (agent.energy < composeCost) return false;

  const scored = agent.keys.map(k => ({k, m: matchKeyToPattern(k.cells, v.cells)}));
  scored.sort((a,b) => b.m.score - a.m.score);
  const a = scored[0], b = scored[1];
  if (!a || !b) return false;

  if (a.m.good > 0.70) return false;

  const combined = shapeOR(a.k.cells, b.k.cells);
  const sid = SHAPES.length;
  SHAPES.push({name:"combo("+a.k.shapeId+"|"+b.k.shapeId+")", cells: combined, mass: shapeMass(combined)});

  agent.keys.push(makeKey(sid));
  agent.energy = Math.max(0, agent.energy - composeCost);

  ensureStorage(agent);
  return true;
}

function emitSignal(agent, v, key, areaB, areaA){
  if (!UI.chkSignals.checked) return;
  const delta = areaB - areaA; // positive = improvement
  signals.push({
    x: v.x, y: v.y,
    t: 0,
    ttl: 6.5,
    payload: {
      voidId: v.id,
      areaB,
      keyId: key.keyId,
      shapeId: key.shapeId,
      areaA,
      delta
    }
  });
  agent.pulse = 0.25;
}

function absorbSignals(agent){
  const hearR = 0.18;
  const copyCost = 0.22;

  for (const s of signals){
    const tv = torusVec(agent.x, agent.y, s.x, s.y);
    if (tv.d > hearR) continue;

    const p = s.payload;
    if (!agent.memory.has(p.voidId)) agent.memory.set(p.voidId, {obs:[]});
    const rec = agent.memory.get(p.voidId);
    rec.obs.push({keyId:p.keyId, shapeId:p.shapeId, areaB:p.areaB, areaA:p.areaA, delta:p.delta});

    // Copy keys that are actually helpful more often.
    const helpful = p.delta > 0;
    const desire = helpful ? 0.85 : 0.20;
    if (!agentHasShape(agent, p.shapeId) && Math.random() < desire){
      if (agent.energy >= copyCost){
        agent.keys.push(makeKey(p.shapeId));
        agent.energy -= copyCost;
        ensureStorage(agent);
      }
    }
  }

  for (const [vid, rec] of agent.memory.entries()){
    if (rec.obs.length > 24) rec.obs.splice(0, rec.obs.length - 24);
  }
}

// --- Targeting + movement stabilization ---

function getVoidById(id){
  for (const v of voids) if (v.id === id) return v;
  return null;
}
function getEnergyById(id){
  for (const e of energySources) if (e.id === id) return e;
  return null;
}

function scoreVoid(agent, v, sight){
  const tv = torusVec(agent.x, agent.y, v.x, v.y);
  if (tv.d > sight) return null;
  const kb = bestKey(agent, v.cells);
  const area = shapeMass(v.cells);
  const good = kb ? kb.m.good : 0;
  const score = (0.3 + area/v.mass0) * (0.25 + good) * (0.6 + 0.6*v.rarity) / (0.04 + tv.d);
  return {score, tv, kb, area};
}
function scoreEnergy(agent, e, sight){
  const tv = torusVec(agent.x, agent.y, e.x, e.y);
  if (tv.d > sight) return null;
  const kb = bestKey(agent, e.cells);
  const good = kb ? kb.m.good : 0;
  const score = (0.25 + e.amount) * (0.25 + good) / (0.04 + tv.d);
  return {score, tv, kb};
}

function chooseBestTarget(agent, type, sight){
  if (type === "void"){
    let best=null;
    for (const v of voids){
      const s = scoreVoid(agent, v, sight);
      if (!s) continue;
      if (!best || s.score > best.score) best = {type:"void", id:v.id, obj:v, score:s.score};
    }
    return best;
  }
  if (type === "energy"){
    let best=null;
    for (const e of energySources){
      const s = scoreEnergy(agent, e, sight);
      if (!s) continue;
      if (!best || s.score > best.score) best = {type:"energy", id:e.id, obj:e, score:s.score};
    }
    return best;
  }
  return null;
}

function updateAgentMode(agent){
  const low = parseFloat(UI.sELow.value);
  const high = parseFloat(UI.sEHigh.value);

  // enforce ordering
  const lo = Math.min(low, high - 0.01);
  const hi = Math.max(high, low + 0.01);

  if (agent.mode === "solve" && agent.energy < lo) agent.mode = "harvest";
  else if (agent.mode === "harvest" && agent.energy > hi) agent.mode = "solve";
  else if (!agent.mode) agent.mode = (agent.energy < lo) ? "harvest" : "solve";
}

function validateTarget(agent){
  if (!agent.targetType || agent.targetId == null) return null;
  if (agent.targetType === "void") return getVoidById(agent.targetId);
  if (agent.targetType === "energy") return getEnergyById(agent.targetId);
  return null;
}

function retargetIfNeeded(agent, sight){
  updateAgentMode(agent);

  const commit = parseFloat(UI.sCommit.value);
  const margin = parseFloat(UI.sMargin.value);

  // If current target is invalid -> drop it
  const curObj = validateTarget(agent);
  if (!curObj){
    agent.targetType = null;
    agent.targetId = null;
    agent.lastScore = 0;
    agent.lockUntil = 0;
  }

  // If no target, pick one based on mode
  if (!agent.targetType){
    const desiredType = (agent.mode === "harvest") ? "energy" : "void";
    const best = chooseBestTarget(agent, desiredType, sight);
    if (best){
      agent.targetType = best.type;
      agent.targetId = best.id;
      agent.lastScore = best.score;
      agent.lockUntil = simTime + commit;
    }
    return;
  }

  // If committed, don't switch (unless energy is critical)
  const critical = agent.energy < 0.12;
  if (!critical && simTime < agent.lockUntil) return;

  // Consider switching target *within same mode type* first
  const desiredType = (agent.mode === "harvest") ? "energy" : "void";

  // If target type mismatches desired, allow switch more easily once commitment passed
  if (agent.targetType !== desiredType){
    const best = chooseBestTarget(agent, desiredType, sight);
    if (best){
      agent.targetType = best.type;
      agent.targetId = best.id;
      agent.lastScore = best.score;
      agent.lockUntil = simTime + commit;
    }
    return;
  }

  // Same type: only switch if new is meaningfully better
  const best = chooseBestTarget(agent, desiredType, sight);
  if (!best) return;
  const curScore = agent.lastScore || 0;
  if (best.id !== agent.targetId && best.score > curScore * margin){
    agent.targetType = best.type;
    agent.targetId = best.id;
    agent.lastScore = best.score;
    agent.lockUntil = simTime + commit;
  } else {
    // refresh score for current target occasionally to reduce stale values
    const cur = validateTarget(agent);
    if (cur){
      if (agent.targetType === "void"){
        const s = scoreVoid(agent, cur, sight);
        if (s) agent.lastScore = s.score;
      } else {
        const s = scoreEnergy(agent, cur, sight);
        if (s) agent.lastScore = s.score;
      }
    }
  }
}

function steerAgent(agent, target){
  // velocity-based steering on torus
  const accel = 1.6;      // how hard it turns
  const maxV  = 0.35;     // max speed in normalized coords per second
  const damp  = 0.88;     // velocity damping each second-ish

  // wander if no target
  let dirx=0, diry=0;
  if (target){
    const tv = torusVec(agent.x, agent.y, target.x, target.y);
    const d = tv.d || 1e-6;
    dirx = tv.dx/d; diry = tv.dy/d;

    // slow down when very close to target radius to avoid overshoot bounce
    const r = target.r || 0.03;
    const close = clamp01((d - 0.15*r) / (0.85*r + 1e-6)); // 0..1
    dirx *= close; diry *= close;
  } else {
    const ang = Math.random()*Math.PI*2;
    dirx = Math.cos(ang); diry = Math.sin(ang);
  }

  // mild noise so they don't get stuck in perfect cycles
  dirx += 0.12*randn();
  diry += 0.12*randn();
  const g = Math.hypot(dirx,diry) || 1e-6;
  dirx/=g; diry/=g;

  // accelerate
  agent.vx += dirx * accel * dtSim;
  agent.vy += diry * accel * dtSim;

  // damping
  const dd = Math.pow(damp, dtSim);
  agent.vx *= dd;
  agent.vy *= dd;

  // clamp speed
  const sp = Math.hypot(agent.vx, agent.vy);
  if (sp > maxV){
    const s = maxV / sp;
    agent.vx *= s; agent.vy *= s;
  }

  // move
  agent.x = wrap01(agent.x + agent.vx * dtSim);
  agent.y = wrap01(agent.y + agent.vy * dtSim);
}

// --- main sim ---

let dtSim = 0;

function updateSim(dt){
  dtSim = dt;
  simTime += dt;

  // spawns
  const vRate = parseFloat(UI.sVoidRate.value)/60;
  const eRate = parseFloat(UI.sERate.value)/60;
  if (Math.random() < vRate*dt) spawnVoid();
  if (Math.random() < eRate*dt) spawnEnergy();

  // update growth/aging
  for (const v of voids) growVoid(v, dt);
  for (const e of energySources) e.age += dt;
  energySources = energySources.filter(e => e.amount > 0.01);

  // update signals
  for (const s of signals) s.t += dt;
  signals = signals.filter(s => s.t < s.ttl);

  // agents
  const spend = parseFloat(UI.sSpend.value);
  const sight = 0.26;
  for (const a of agents){
    absorbSignals(a);

    // (1) retarget with hysteresis + commit + margin
    retargetIfNeeded(a, sight);

    // (2) steer smoothly toward target (or wander)
    const target = validateTarget(a);
    steerAgent(a, target);

    // (3) interact if inside target radius
    if (target && a.targetType === "energy"){
      const tv = torusVec(a.x, a.y, target.x, target.y);
      if (tv.d < target.r){
        const kb = bestKey(a, target.cells);
        if (kb){
          const {take} = harvestEnergy(target, kb.k, dt);
          a.energy = Math.min(a.maxEnergy, a.energy + take);
        }
      }
    }

    if (target && a.targetType === "void"){
      const v = target;
      const tv = torusVec(a.x, a.y, v.x, v.y);
      if (tv.d < v.r && a.energy > 0.02){
        const kb = bestKey(a, v.cells);
        if (kb){
          const before = shapeMass(v.cells);
          const agentSpend = Math.min(a.energy, spend);
          const res = applyKeyToVoid(v, kb.k, dt, agentSpend);
          a.energy = Math.max(0, a.energy - (res.spend ?? 0));
          emitSignal(a, v, kb.k, res.areaB, res.areaA);

          // if no progress, maybe compose
          const improved = (res.areaB - res.areaA) >= 1;
          if (!improved && a.energy > 0.2) maybeCompose(a, v);
        }
      }
    }

    // solve threshold
    const thrPct = parseFloat(UI.sSolveThr.value)/100;
    voids = voids.filter(v => (shapeMass(v.cells) / (v.mass0+1e-6)) > thrPct);

    // trails + pulse decay
    if (UI.chkTrails.checked){
      trails.noStroke();
      trails.fill(235,235,255,28);
      trails.circle(a.x*W, a.y*H, 2.2);
    }
    a.pulse = Math.max(0, a.pulse - dt);
  }

  // gentle trail fade
  if (UI.chkTrails.checked){
    trails.push();
    trails.erase(12,12);
    trails.rect(0,0,W,H);
    trails.noErase();
    trails.pop();
  }

  // keep counts in check
  const maxV = parseInt(UI.sVoidMax.value);
  if (voids.length > maxV) voids.length = maxV;
  const maxE = parseInt(UI.sEMax.value);
  if (energySources.length > maxE) energySources.length = maxE;
}

// --- Rendering ---

function drawPatternStamp(x, y, rPx, cells, rgb, alpha=140){
  const stamp = rPx*2;
  const cell = stamp / SHAPE_N;
  const ox = x - stamp/2;
  const oy = y - stamp/2;

  noStroke();
  for (let yy=0; yy<SHAPE_N; yy++){
    for (let xx=0; xx<SHAPE_N; xx++){
      const i = idxS(xx,yy);
      if (!cells[i]) continue;
      fill(rgb[0], rgb[1], rgb[2], alpha);
      rect(ox + xx*cell, oy + yy*cell, cell*0.92, cell*0.92, 2);
    }
  }
}

function draw(){
  background(12,14,18);

  const speed = parseFloat(UI.sSpeed.value);
  const dt = (deltaTime/1000) * speed;

  if (!paused) updateSim(dt);

  // trails
  if (UI.chkTrails.checked) image(trails, 0,0);

  // energy sources
  for (const e of energySources){
    const px = e.x*W, py = e.y*H;
    const rPx = e.r*Math.min(W,H);
    const a = 60 + 180*(e.amount/(e.amount0+1e-6));
    drawPatternStamp(px, py, rPx, e.cells, [120,255,140], 95);
    noFill();
    stroke(120,255,140,a);
    strokeWeight(2);
    circle(px,py, rPx*2.1);
  }

  // voids
  for (const v of voids){
    const px = v.x*W, py = v.y*H;
    const rPx = v.r*Math.min(W,H);
    const area = shapeMass(v.cells);
    const sev = clamp01(area/(v.mass0+1e-6));
    const a = 70 + 180*sev;

    drawPatternStamp(px, py, rPx, v.cells, [255,110,110], 110);
    noFill();
    stroke(255,110,110,a);
    strokeWeight(2);
    circle(px,py, rPx*(2.0 + 0.9*sev));

    noStroke();
    fill(255,255,255,200);
    textSize(11);
    textAlign(CENTER, CENTER);
    text("#"+v.id, px, py + rPx*1.35);
  }

  // signals (ripples) ‚Äî color indicates improvement vs not
  if (UI.chkSignals.checked){
    for (const s of signals){
      const px = s.x*W, py = s.y*H;
      const wave = (s.t*0.9)%1.0;
      const r = (0.02 + 0.14*wave)*Math.min(W,H);
      const a = Math.max(0, 170*(1-wave));

      const delta = s.payload.delta || 0;
      // delta > 0 means improved. Scale: max ~5 cells improvement = strong green.
      const t = clamp01(delta / 5);
      const R = Math.round(255*(1 - 0.55*t) + 80*(t));
      const G = Math.round(200*(t) + 150*(1-t));
      const B = Math.round(120*(1 - t) + 110*(t));

      noFill();
      stroke(R,G,B,a);
      strokeWeight(1.5);
      circle(px,py,r*2);
    }
  }

  // agents
  for (const a of agents){
    const px = a.x*W, py = a.y*H;

    // color by energy
    const t = clamp01(a.energy/(a.maxEnergy+1e-6));
    const rr = 80 + 175*t;
    const gg = 120 + 120*t;
    const bb = 230 - 140*t;

    noStroke();
    fill(rr,gg,bb,245);
    circle(px,py, 7.5);

    // pulse
    if (a.pulse > 0){
      noFill();
      stroke(255,230,120,220*a.pulse/0.25);
      strokeWeight(2);
      circle(px,py, 16 + 24*(1 - a.pulse/0.25));
    }

    // mode label
    noStroke();
    fill(255,255,255,190);
    textSize(10);
    textAlign(CENTER, CENTER);
    const label = (a.mode === "harvest") ? "H" : "S";
    text(label, px, py - 11);
  }

  renderMetrics();
}

function renderMetrics(){
  let avgE=0, avgK=0;
  for (const a of agents){ avgE += a.energy; avgK += a.keys.length; }
  avgE = agents.length ? avgE/agents.length : 0;
  avgK = agents.length ? avgK/agents.length : 0;

  const el = document.getElementById("metrics");
  el.innerHTML = `
    <div><b>Agents</b>: ${agents.length} | <b>Voids</b>: ${voids.length} | <b>Energy</b>: ${energySources.length} | <b>Signals</b>: ${signals.length}</div>
    <div><b>Avg energy</b>: ${avgE.toFixed(2)} / 1.50 | <b>Avg keys</b>: ${avgK.toFixed(1)} (cap ${parseInt(UI.sKCap.value)})</div>
    <div class="tiny">Library size: ${SHAPES.length} | time: ${simTime.toFixed(1)} | fps: ${Math.round(frameRate())}</div>
  `;
}

function setup(){
  W = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
  H = windowHeight;
  createCanvas(W,H);

  trails = createGraphics(W,H);
  trails.clear();

  hookUI();
  resetAll();
  frameRate(60);
}

function windowResized(){
  W = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
  H = windowHeight;
  resizeCanvas(W,H);
  trails = createGraphics(W,H);
  trails.clear();
}

function hookUI(){
  UI.btnPause = document.getElementById("btnPause");
  UI.btnReset = document.getElementById("btnReset");

  UI.sSpeed  = document.getElementById("sSpeed");
  UI.sAgents = document.getElementById("sAgents");
  UI.sKCap   = document.getElementById("sKCap");
  UI.chkTrails = document.getElementById("chkTrails");
  UI.chkSignals = document.getElementById("chkSignals");

  UI.sELow  = document.getElementById("sELow");
  UI.sEHigh = document.getElementById("sEHigh");
  UI.sCommit = document.getElementById("sCommit");
  UI.sMargin = document.getElementById("sMargin");

  UI.sVoidRate = document.getElementById("sVoidRate");
  UI.sVoidMax  = document.getElementById("sVoidMax");
  UI.sVoidGrow = document.getElementById("sVoidGrow");
  UI.sSolveThr = document.getElementById("sSolveThr");

  UI.sERate    = document.getElementById("sERate");
  UI.sEMax     = document.getElementById("sEMax");
  UI.sHarvest  = document.getElementById("sHarvest");
  UI.sSpend    = document.getElementById("sSpend");

  UI.selCompose = document.getElementById("selCompose");
  UI.sComposeCost = document.getElementById("sComposeCost");

  const refresh = ()=>{
    document.getElementById("lblSpeed").textContent = parseFloat(UI.sSpeed.value).toFixed(2);
    document.getElementById("lblAgents").textContent = parseInt(UI.sAgents.value);
    document.getElementById("lblKCap").textContent = parseInt(UI.sKCap.value);

    document.getElementById("lblELow").textContent = parseFloat(UI.sELow.value).toFixed(2);
    document.getElementById("lblEHigh").textContent = parseFloat(UI.sEHigh.value).toFixed(2);
    document.getElementById("lblCommit").textContent = parseFloat(UI.sCommit.value).toFixed(1);
    document.getElementById("lblMargin").textContent = parseFloat(UI.sMargin.value).toFixed(2);

    document.getElementById("lblVoidRate").textContent = parseInt(UI.sVoidRate.value);
    document.getElementById("lblVoidMax").textContent = parseInt(UI.sVoidMax.value);
    document.getElementById("lblVoidGrow").textContent = parseFloat(UI.sVoidGrow.value).toFixed(2);
    document.getElementById("lblSolveThr").textContent = parseInt(UI.sSolveThr.value);

    document.getElementById("lblERate").textContent = parseInt(UI.sERate.value);
    document.getElementById("lblEMax").textContent = parseInt(UI.sEMax.value);
    document.getElementById("lblHarvest").textContent = parseFloat(UI.sHarvest.value).toFixed(2);
    document.getElementById("lblSpend").textContent = parseFloat(UI.sSpend.value).toFixed(2);

    document.getElementById("lblCompose").textContent = UI.selCompose.value === "on" ? "On" : "Off";
    document.getElementById("lblComposeCost").textContent = parseFloat(UI.sComposeCost.value).toFixed(2);
  };
  refresh();

  ["input","change"].forEach(evt=>{
    [
      UI.sSpeed, UI.sAgents, UI.sKCap,
      UI.sELow, UI.sEHigh, UI.sCommit, UI.sMargin,
      UI.sVoidRate, UI.sVoidMax, UI.sVoidGrow, UI.sSolveThr,
      UI.sERate, UI.sEMax, UI.sHarvest, UI.sSpend,
      UI.selCompose, UI.sComposeCost
    ].forEach(el => el.addEventListener(evt, refresh));
  });

  UI.btnPause.addEventListener("click", ()=>{
    paused = !paused;
    UI.btnPause.textContent = paused ? "Resume" : "Pause";
  });
  UI.btnReset.addEventListener("click", ()=>{
    resetAll();
  });

  UI.sAgents.addEventListener("input", ()=>{
    const n = parseInt(UI.sAgents.value);
    agents = [];
    nextKeyId = 1;
    for (let i=0;i<n;i++) agents.push(createAgent(Math.random(), Math.random()));
  });

  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space"){ paused = !paused; UI.btnPause.textContent = paused ? "Resume" : "Pause"; e.preventDefault(); }
    if (e.key.toLowerCase() === "r"){ resetAll(); }
    if (e.key.toLowerCase() === "v"){ spawnVoid(); }
    if (e.key.toLowerCase() === "e"){ spawnEnergy(); }
  });
}

// randn
let spare = null;
function randn(){
  if (spare !== null){ const v = spare; spare = null; return v; }
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  const mag=Math.sqrt(-2*Math.log(u));
  const z0=mag*Math.cos(TWO_PI*v);
  const z1=mag*Math.sin(TWO_PI*v);
  spare=z1; return z0;
}
</script>

</body>
</html>
