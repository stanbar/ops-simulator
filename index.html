<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>BCM Simulator: Full Cognitive Roles</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
        <style>
            :root { --uiw: 340px; }
            html, body { margin: 0; height: 100%; background: #0e0f12; color: #e8eaf1; font-family: system-ui, sans-serif; overflow: hidden; }
            #ui { position: fixed; top: 0; right: 0; width: var(--uiw); height: 100%; overflow-y: auto; box-sizing: border-box; padding: 14px 14px 120px; background: #14161b; border-left: 1px solid #1e2230; z-index: 10; }
            #ui h2 { margin: 8px 0 10px; font-size: 16px; font-weight: 700; color: #fff; }
            #ui .group { border: 1px solid #1f2535; border-radius: 10px; padding: 10px; margin-bottom: 12px; background: #10131a; }
            #ui label { display: block; font-size: 12px; opacity: 0.85; margin: 6px 0 4px; }
            #ui input[type="range"] { width: 100%; }
            #ui .row { display: flex; gap: 8px; align-items: center; }
            #ui .row > * { flex: 1; }
            #ui button, #ui select { width: 100%; border-radius: 8px; border: 1px solid #2a3248; padding: 8px 10px; background: #18202d; color: #e8eaf1; cursor: pointer; transition: 0.2s; }
            #ui button:hover { background: #252f42; }
            #ui .tiny { font-size: 11px; opacity: 0.8; margin-top: 5px; line-height: 1.4; }
            #metrics { position: fixed; left: 10px; top: 10px; background: rgba(8, 10, 14, 0.85); padding: 10px; border-radius: 8px; border: 1px solid #1e2230; backdrop-filter: blur(4px); font-size: 12px; pointer-events: none; z-index: 5; }
            canvas { display: block; }
        </style>
    </head>
    <body>
        <div id="ui">
            <h2>BCM: Cognitive Roles</h2>

            <div class="group">
                <div class="row">
                    <button id="pauseBtn">Pause</button>
                    <button id="btnResetAll">Reset World</button>
                </div>
            </div>

            <div class="group" style="border-color: #5d2b2b;">
                <h3 style="margin: 6px 0 6px; font-size: 13px; color: #ff8080;">Role Mechanics</h3>
                
                <div class="tiny" style="margin-bottom:8px;">
                    <strong>Deciders (Solvers):</strong><br/>
                    • <b>De (Te/Fe) ■:</b> "Common Keys". Attacks ALL voids. Constant low damage. High battery drain.<br/>
                    • <b>Di (Ti/Fi) ●:</b> "Rare Keys". Attacks MATCHING voids only. Massive critical hits.
                </div>
                
                <div class="tiny">
                    <strong>Observers (Navigators):</strong><br/>
                    • <b>Oe (Ne/Se) ▲:</b> "The Scouts". 2.0x Attraction to Voids. They find the problems first.<br/>
                    • <b>Oi (Ni/Si) ▼:</b> "The Anchors". Extreme efficiency. Lowest battery drain. They outlast everyone.
                </div>
            </div>

            <div class="group">
                <label>Void Chaos (Spawn Rate): <span id="lblVoidRate">0.5</span></label>
                <input id="sVoidRate" type="range" min="0" max="2.0" step="0.001" value="0.5" />
                <label>Void Complexity (HP): <span id="lblVoidHp">150</span></label>
                <input id="sVoidHp" type="range" min="10" max="500" step="10" value="150" />
            </div>

            <div class="group">
                <label>Simulation Speed: <span id="lblDt">2.0</span></label>
                <input id="sDt" type="range" min="0.5" max="5.0" step="0.1" value="2.0" />
                <label>Agent Count: <span id="lblN">40</span></label>
                <input id="sN" type="range" min="0" max="150" step="1" value="40" />
                <label>Collision Radius: <span id="lblCol">16</span></label>
                <input id="sColRadius" type="range" min="5" max="30" step="1" value="16" />
                <label>Field Opacity: <span id="lblOp">0.3</span></label>
                <input id="sOpacity" type="range" min="0" max="1" step="0.05" value="0.3" />
            </div>

            <div class="group">
                <label>Add Agent Type:</label>
                <select id="agentSpawnPreset"></select>
                <div class="row" style="margin-top: 8px;">
                    <button id="btnAddCenter">Add (Center)</button>
                    <button id="btnRandomizeMix">Add 10 Random</button>
                </div>
            </div>
        </div>

        <div id="metrics">Initializing...</div>

        <script>
            // --- Configuration ---
            const UI_WIDTH = 340;
            const VOID_TYPES = ['#ff4040', '#40ff40', '#4040ff', '#ffff40']; 
            
            // --- State ---
            let canvasW, canvasH;
            let agents = [];
            let voids = []; 
            let fieldGraphics; 
            let noiseZ = 0;
            
            // --- Settings linked to UI ---
            const SETTINGS = {
                dt: 2.0,
                voidRate: 0.6,
                voidHp: 150,
                agentCount: 40,
                colRadius: 16,
                opacity: 0.3
            };

            // --- Presets ---
            const PRESETS = {
                'Te/Fe (De)': { label: "De (Common Keys) ■", De: 2.0, Di: -1.0, Oe: 0.5, Oi: 0.0, type: 'decider_ext' },
                'Ti/Fi (Di)': { label: "Di (Rare Keys) ●", De: -2.0, Di: 2.0, Oe: 0.0, Oi: 1.0, type: 'decider_int' },
                'Ne/Se (Oe)': { label: "Oe (Scouts) ▲", De: 0.0, Di: 0.0, Oe: 2.0, Oi: -1.0, type: 'observer_ext' },
                'Ni/Si (Oi)': { label: "Oi (Anchors) ▼", De: 0.0, Di: 0.0, Oe: -2.0, Oi: 2.0, type: 'observer_int' },
                'Balanced':   { label: "Balanced", De: 0.5, Di: 0.5, Oe: 0.5, Oi: 0.5, type: 'balanced' }
            };

            // --- P5.js Setup ---
            function setup() {
                canvasW = windowWidth - UI_WIDTH;
                canvasH = windowHeight;
                createCanvas(canvasW, canvasH);
                fieldGraphics = createGraphics(canvasW, canvasH);
                initUI();
                resetWorld();
            }

            function windowResized() {
                canvasW = windowWidth - UI_WIDTH;
                canvasH = windowHeight;
                resizeCanvas(canvasW, canvasH);
                fieldGraphics.resizeCanvas(canvasW, canvasH);
            }

            // --- Main Loop ---
            function draw() {
                background(14, 15, 18);
                drawField();
                manageVoids();
                updateAgents();
                resolveCollisions();

                image(fieldGraphics, 0, 0); 
                drawVoids();
                drawAgents();
                updateMetrics();
            }

            // --- Logic: Voids ---
            function manageVoids() {
                if (random() < SETTINGS.voidRate * 0.1) {
                    voids.push({
                        x: random(canvasW),
                        y: random(canvasH),
                        hp: SETTINGS.voidHp,
                        maxHp: SETTINGS.voidHp,
                        typeIdx: floor(random(VOID_TYPES.length)), 
                        radius: random(20, 50),
                        birth: millis()
                    });
                }
                for (let i = voids.length - 1; i >= 0; i--) {
                    if (voids[i].hp <= 0) voids.splice(i, 1);
                }
            }

            // --- Logic: Collisions ---
            function resolveCollisions() {
                let minD = SETTINGS.colRadius; 
                let count = agents.length;
                for (let i = 0; i < count; i++) {
                    for (let j = i + 1; j < count; j++) {
                        let a = agents[i], b = agents[j];
                        let dx = b.x - a.x, dy = b.y - a.y;
                        
                        // Wrap delta
                        if (dx > canvasW * 0.5) dx -= canvasW;
                        else if (dx < -canvasW * 0.5) dx += canvasW;
                        if (dy > canvasH * 0.5) dy -= canvasH;
                        else if (dy < -canvasH * 0.5) dy += canvasH;
                        
                        let distSq = dx*dx + dy*dy;
                        if (distSq < minD*minD && distSq > 0) {
                            let d = Math.sqrt(distSq);
                            let push = (minD - d) * 0.5;
                            let nx = dx / d, ny = dy / d;
                            a.x -= nx * push; a.y -= ny * push;
                            b.x += nx * push; b.y += ny * push;
                        }
                    }
                }
            }

            // --- Logic: Agents ---
            function updateAgents() {
                const dt = SETTINGS.dt;
                
                for (let a of agents) {
                    // 1. Field Drift
                    let nVal = noise(a.x * 0.005, a.y * 0.005, noiseZ);
                    let angle = nVal * TWO_PI * 4;
                    let vx = cos(angle) * 0.5;
                    let vy = sin(angle) * 0.5;

                    // 2. Void Attraction
                    let closestVoid = null;
                    let minDist = 10000;

                    // Only look for work if battery is decent
                    if (a.battery > 0.2) {
                        for (let v of voids) {
                            let dx = v.x - a.x, dy = v.y - a.y;
                            if (dx > canvasW * 0.5) dx -= canvasW; else if (dx < -canvasW * 0.5) dx += canvasW;
                            if (dy > canvasH * 0.5) dy -= canvasH; else if (dy < -canvasH * 0.5) dy += canvasH;
                            let d = Math.sqrt(dx*dx + dy*dy);
                            
                            if (d < minDist) { minDist = d; closestVoid = v; }
                        }
                        
                        if (closestVoid && minDist < 350) {
                            // Oe (Explorers) have 2.0x pull strength. Others have 1.0x
                            let pullFactor = (a.type === 'observer_ext' || a.Oe > 0.5) ? 2.0 : 1.0; 
                            let pullStr = 0.05 * pullFactor; 
                            
                            // Recalculate wrapped vector
                            let dx = closestVoid.x - a.x, dy = closestVoid.y - a.y;
                            if (dx > canvasW * 0.5) dx -= canvasW; else if (dx < -canvasW * 0.5) dx += canvasW;
                            if (dy > canvasH * 0.5) dy -= canvasH; else if (dy < -canvasH * 0.5) dy += canvasH;
                            
                            // Stop pulling if inside interaction ring (prevents merging)
                            if (minDist > closestVoid.radius * 0.8) {
                                vx += (dx / minDist) * pullStr * 20; 
                                vy += (dy / minDist) * pullStr * 20;
                            }
                        }
                    }

                    a.x += vx * dt;
                    a.y += vy * dt;

                    // Wrap Edges
                    if (a.x < 0) a.x += canvasW; if (a.x >= canvasW) a.x -= canvasW;
                    if (a.y < 0) a.y += canvasH; if (a.y >= canvasH) a.y -= canvasH;

                    // 3. Interaction
                    a.isBlasting = false; 
                    a.battery = min(1.0, a.battery + 0.001); // Passive recharge

                    if (closestVoid && minDist < (closestVoid.radius + 30)) {
                        interactWithVoid(a, closestVoid);
                    }
                }
                noiseZ += 0.002 * dt; 
            }

            function interactWithVoid(a, v) {
                // De (Te/Fe)
                if (a.type === 'decider_ext' || a.De > 0.5) {
                    if (a.battery > 0.05) {
                        v.hp -= 2.0; 
                        a.battery -= 0.005; // High drain
                        drawBeam(a, v, color(255, 100));
                    }
                }
                // Di (Ti/Fi)
                else if (a.type === 'decider_int' || a.Di > 0.5) {
                    if (a.keyAffinity === v.typeIdx) {
                        if (a.battery > 0.3) {
                             v.hp -= 15.0; 
                             a.battery -= 0.02; 
                             drawBeam(a, v, color(255, 255, 0, 200), 2);
                        }
                    } else {
                        a.isBlasting = true; // Signal help
                    }
                }
                // Observers (Oe/Oi)
                else {
                    if (a.battery > 0.05) {
                         v.hp -= 0.5; // Low damage
                         
                         // Oi (Ni/Si) = Extremely efficient
                         if (a.type === 'observer_int' || a.Oi > 0.5) {
                            a.battery -= 0.0005; // Almost no drain
                         } else {
                            a.battery -= 0.002; // Standard drain for Oe
                         }
                    }
                }
            }

            // --- Rendering ---
            function drawBeam(a, v, col, weight=1) {
                let dx = v.x - a.x;
                let dy = v.y - a.y;
                if(abs(dx) < 100 && abs(dy) < 100) { // Don't draw across wrap
                    stroke(col); strokeWeight(weight);
                    line(a.x, a.y, v.x, v.y);
                    strokeWeight(1);
                }
            }

            function drawField() {
                if (frameCount % 3 !== 0) return;
                fieldGraphics.clear(); fieldGraphics.noStroke();
                let op = SETTINGS.opacity, cell = 20;
                for(let x=0; x<canvasW; x+=cell) {
                    for(let y=0; y<canvasH; y+=cell) {
                        let n = noise(x*0.005, y*0.005, noiseZ);
                        if (n > 0.55) {
                            fieldGraphics.fill(255, 255, 255, (n-0.5)*100 * op);
                            fieldGraphics.circle(x, y, cell*0.8);
                        }
                    }
                }
            }

            function drawVoids() {
                for(let v of voids) {
                    push(); translate(v.x, v.y);
                    let pulse = sin(millis() * 0.005) * 5;
                    let c = color(VOID_TYPES[v.typeIdx]);
                    c.setAlpha(150 + (v.hp/v.maxHp)*105);
                    fill(c); noStroke();
                    beginShape();
                    let sides = 3 + v.typeIdx; 
                    for(let i=0; i<sides; i++) {
                        let ang = TWO_PI * i / sides + (millis()*0.001);
                        vertex(cos(ang)*(v.radius+pulse), sin(ang)*(v.radius+pulse));
                    }
                    endShape(CLOSE);
                    fill(0); rect(-15, -5, 30, 4);
                    fill(255); rect(-15, -5, 30 * (v.hp/v.maxHp), 4);
                    pop();
                }
            }

            function drawAgents() {
                for(let a of agents) {
                    push(); translate(a.x, a.y);
                    let batCol = lerpColor(color(100,0,0), color(0,255,0), a.battery);
                    stroke(batCol); fill(20, 20, 30);
                    
                    if (a.type === 'decider_ext') rect(-6,-6, 12, 12);
                    else if (a.type === 'decider_int') circle(0,0, 14); 
                    else if (a.type === 'observer_ext') triangle(0, -7, -6, 5, 6, 5); // Triangle Up
                    else if (a.type === 'observer_int') triangle(0, 7, -6, -5, 6, -5); // Triangle Down
                    else circle(0,0,10); // Balanced

                    if (a.type === 'decider_int') {
                        noStroke(); fill(VOID_TYPES[a.keyAffinity]); circle(0,0, 6);
                    }
                    if (a.isBlasting) {
                        noFill(); stroke(255, 50, 50, 150);
                        circle(0,0, 20 + (millis()%500)/10);
                        fill(255); noStroke(); textSize(9); textAlign(CENTER); text("BLAST", 0, -15);
                    }
                    pop();
                }
            }

            function updateMetrics() {
                document.getElementById('metrics').innerHTML = `
                    <div><strong>FPS:</strong> ${floor(frameRate())}</div>
                    <div><strong>Agents:</strong> ${agents.length}</div>
                    <div><strong>Voids:</strong> ${voids.length}</div>
                    <div><strong>Avg Battery:</strong> ${(agents.reduce((acc,a)=>acc+a.battery,0)/max(1,agents.length)).toFixed(2)}</div>
                `;
            }

            function createAgent(x, y, presetName) {
                let p = PRESETS[presetName] || PRESETS['Balanced'];
                return {
                    x: x, y: y, battery: 1.0, type: p.type,
                    keyAffinity: floor(random(VOID_TYPES.length)),
                    De: p.De, Di: p.Di, Oe: p.Oe, Oi: p.Oi,
                    isBlasting: false
                };
            }

            function resetWorld() {
                agents = []; voids = [];
                let n = parseInt(document.getElementById('sN').value);
                let keys = Object.keys(PRESETS);
                for(let i=0; i<n; i++) agents.push(createAgent(random(canvasW), random(canvasH), keys[floor(random(keys.length))]));
            }

            function initUI() {
                let sel = document.getElementById('agentSpawnPreset');
                for(let k in PRESETS) {
                    let opt = document.createElement('option');
                    opt.value = k; opt.innerHTML = PRESETS[k].label;
                    sel.appendChild(opt);
                }
                const linkRange = (id, obj, key) => {
                    let el = document.getElementById(id);
                    el.addEventListener('input', () => {
                        obj[key] = parseFloat(el.value);
                        let lbl = document.getElementById('lbl' + id.substring(1));
                        if(lbl) lbl.innerText = el.value;
                    });
                };
                linkRange('sDt', SETTINGS, 'dt'); linkRange('sVoidRate', SETTINGS, 'voidRate');
                linkRange('sVoidHp', SETTINGS, 'voidHp'); linkRange('sOpacity', SETTINGS, 'opacity');
                linkRange('sColRadius', SETTINGS, 'colRadius');

                document.getElementById('sN').addEventListener('input', (e) => {
                    SETTINGS.agentCount = parseInt(e.target.value);
                    document.getElementById('lblN').innerText = SETTINGS.agentCount;
                    while(agents.length < SETTINGS.agentCount) {
                         let keys = Object.keys(PRESETS);
                         agents.push(createAgent(random(canvasW), random(canvasH), keys[floor(random(keys.length))]));
                    }
                    if(agents.length > SETTINGS.agentCount) agents.splice(SETTINGS.agentCount);
                });

                document.getElementById('pauseBtn').addEventListener('click', () => { if(isLooping()) noLoop(); else loop(); });
                document.getElementById('btnResetAll').addEventListener('click', resetWorld);
                document.getElementById('btnAddCenter').addEventListener('click', () => {
                    let k = document.getElementById('agentSpawnPreset').value;
                    agents.push(createAgent(canvasW/2, canvasH/2, k));
                });
                document.getElementById('btnRandomizeMix').addEventListener('click', () => {
                    for(let i=0; i<10; i++) {
                        let keys = Object.keys(PRESETS);
                         agents.push(createAgent(random(canvasW), random(canvasH), keys[floor(random(keys.length))]));
                    }
                });
            }

            function mousePressed() {
                if (mouseX < canvasW && mouseY < canvasH) {
                    let k = document.getElementById('agentSpawnPreset').value;
                    agents.push(createAgent(mouseX, mouseY, k));
                }
            }
        </script>
    </body>
</html>