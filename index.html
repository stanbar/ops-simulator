<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>
            BCM Cognitive Landscape — Moving Clouds + Collisions + Di/De/Oi/Oe
        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
        <style>
            :root {
                --uiw: 340px;
            }
            html,
            body {
                margin: 0;
                height: 100%;
                background: #0e0f12;
                color: #e8eaf1;
                font-family:
                    system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    Ubuntu,
                    Cantarell,
                    "Helvetica Neue",
                    Arial,
                    "Noto Sans",
                    sans-serif;
            }
            #ui {
                position: fixed;
                top: 0;
                right: 0;
                width: var(--uiw);
                height: 100%;
                overflow-y: auto;
                box-sizing: border-box;
                padding: 14px 14px 120px;
                background: #14161b;
                border-left: 1px solid #1e2230;
            }
            #ui h2 {
                margin: 8px 0 10px;
                font-size: 16px;
                font-weight: 700;
                letter-spacing: 0.3px;
            }
            #ui .group {
                border: 1px solid #1f2535;
                border-radius: 10px;
                padding: 10px;
                margin-bottom: 12px;
                background: #10131a;
            }
            #ui label {
                display: block;
                font-size: 12px;
                opacity: 0.85;
                margin: 6px 0 4px;
            }
            #ui input[type="range"] {
                width: 100%;
            }
            #ui .row {
                display: flex;
                gap: 8px;
                align-items: center;
            }
            #ui .row > * {
                flex: 1;
            }
            #ui button,
            #ui select {
                width: 100%;
                border-radius: 8px;
                border: 1px solid #2a3248;
                padding: 8px 10px;
                background: #18202d;
                color: #e8eaf1;
                cursor: pointer;
            }
            #ui button:hover {
                background: #1c2737;
            }
            #ui .tiny {
                font-size: 11px;
                opacity: 0.8;
            }
            #metrics {
                position: fixed;
                left: 10px;
                top: 10px;
                background: rgba(8, 10, 14, 0.78);
                padding: 8px 10px;
                border-radius: 8px;
                border: 1px solid #1e2230;
                backdrop-filter: blur(6px);
            }
            canvas {
                display: block;
            }
        </style>
    </head>
    <body>
        <div id="ui">
            <h2>BCM Cognitive Landscape</h2>

            <!-- Simulation control -->
            <div class="group">
                <div class="row" style="gap: 6px">
                    <button id="pauseBtn">Pause</button>
                </div>
            </div>

            <!-- Simulation speed -->
            <div class="group">
                <h3 style="margin: 6px 0 6px; font-size: 13px">Simulation</h3>
                <label>Simulation speed: <span id="lblDt">3.00</span></label>
                <input
                    id="sDt"
                    type="range"
                    min="0.2"
                    max="30.0"
                    step="0.01"
                    value="3.00"
                />
                <label
                    >Stability factor:
                    <span id="lblStability">0.020</span></label
                >
                <input
                    id="sStability"
                    type="range"
                    min="0.001"
                    max="0.050"
                    step="0.001"
                    value="0.020"
                />
                <label>Mean radius (field fraction): <span id="lblMeanR">0.25</span></label>
                <input
                    id="sMeanRadius"
                    type="range"
                    min="0.05"
                    max="0.5"
                    step="0.01"
                    value="0.25"
                />
            </div>

            <!-- Field (fbm-driven “moving clouds”) -->
            <div class="group">
                <h3 style="margin: 6px 0 6px; font-size: 13px">
                    Cognitive Landscape
                </h3>
                <label
                    >Structure scale (Perlin freq):
                    <span id="lblFreq">2.50</span></label
                >
                <input
                    id="sPerlinFreq"
                    type="range"
                    min="0.5"
                    max="8.0"
                    step="0.05"
                    value="2.50"
                />

                <label>Octaves: <span id="lblOct">3</span></label>
                <input
                    id="sPerlinOct"
                    type="range"
                    min="1"
                    max="6"
                    step="1"
                    value="3"
                />

                <label
                    >Contrast (amplitude):
                    <span id="lblNoise">0.40</span></label
                >
                <input
                    id="sNoise"
                    type="range"
                    min="0"
                    max="1.00"
                    step="0.01"
                    value="0.40"
                />

                <label
                    ><input type="checkbox" id="chkEvolve" checked /> Animate
                    field over time</label
                >
                <label>Flow speed: <span id="lblEvo">0.20</span></label>
                <input
                    id="sEvo"
                    type="range"
                    min="0.0"
                    max="3.0"
                    step="0.01"
                    value="0.20"
                />
            </div>

            <!-- Gradient lookahead -->
            <div class="group">
                <h3 style="margin: 6px 0 6px; font-size: 13px">
                    Gradient Lookahead
                </h3>
                <label
                    >Gradient radius (cells):
                    <span id="lblGradR">8</span></label
                >
                <input
                    id="sGradR"
                    type="range"
                    min="1"
                    max="30"
                    step="1"
                    value="8"
                />
                <label>Coarse weight: <span id="lblGradW">0.50</span></label>
                <input
                    id="sGradW"
                    type="range"
                    min="0"
                    max="1"
                    step="0.01"
                    value="0.50"
                />
                <div class="tiny">
                    Final ∇ = (1−w)·∇<sub>fine</sub>(1 cell) +
                    w·∇<sub>coarse</sub>(R cells).
                </div>
            </div>

            <!-- Agents, trails -->
            <div class="group">
                <label>Agents: <span id="lblN">40</span></label>
                <input
                    id="sN"
                    type="range"
                    min="0"
                    max="200"
                    step="1"
                    value="40"
                />

                <label
                    >Show Trails <input id="chkTrails" type="checkbox" checked
                /></label>
                <label
                    >Show Group Mean
                    <input id="chkMean" type="checkbox" checked
                /></label>
                <div class="row" style="margin-top: 8px; gap: 6px">
                    <button id="btnResetAgents">Reset Agents</button>
                    <button id="btnRandomField">Randomize Field</button>
                    <button id="btnClearTrails">Clear Trails</button>
                </div>
            </div>

            <!-- Per-agent controls -->
            <div class="group">
                <h3 style="margin: 6px 0 6px; font-size: 13px">
                    Agent Spawner
                </h3>
                <label>Preset for new agent</label>
                <select id="agentSpawnPreset"></select>
                <label
                    ><input type="checkbox" id="chkAddByClick" checked /> Add by
                    click on canvas</label
                >
                <div class="row" style="margin-top: 8px; gap: 6px">
                    <button id="btnAddCenter">Add at center</button>
                    <button id="btnRandomizeMix">Add 10 mixed</button>
                </div>
            </div>

            <div class="group">
                <h3 style="margin: 6px 0 6px; font-size: 13px">
                    Selected Agent
                </h3>
                <div class="tiny">
                    Click an agent to select it. Shift-click to delete.
                </div>
                <div style="margin-top: 6px">
                    Selected: <span id="selInfo">None</span>
                </div>
                <label>Change preset</label>
                <select id="selAgentPreset"></select>
                <div class="row" style="margin-top: 8px; gap: 6px">
                    <button id="btnApplySelPreset">Apply to selected</button>
                    <button id="btnDeleteSel">Delete selected</button>
                </div>
            </div>

            <div class="group tiny">
                <div style="font-weight: 700; margin-bottom: 4px">Legend</div>
                <div style="margin-bottom: 4px">
                    <span style="color: #0a3ca0">●</span> Oi &gt; Oe
                    <span style="color: #f6d000; margin-left: 8px">●</span> Oe
                    &gt; Oi
                </div>
                <div style="margin-bottom: 4px">
                    <span style="color: #e8eaf1">▲</span> Di &gt; De
                    <span style="color: #e8eaf1; margin-left: 8px">▼</span>
                    De &gt;= Di
                </div>
                <div style="margin-bottom: 4px">
                    <span style="color: #2b8dff">▁</span> Oi/Oe pull (blue
                    arrow)
                    <span style="color: #ff5050; margin-left: 8px">▁</span>
                    Di/De pull (red arrow)
                </div>
                <div>
                    Repo:
                    <a
                        href="https://github.com/stanbar/ops-simulator"
                        target="_blank"
                        style="color: #6fb3ff"
                        >github.com/stanbar/ops-simulator</a
                    >
                </div>
            </div>
        </div>

        <div id="metrics"></div>

        <script>
            // ===== Moving-clouds field (fbm3), lookahead gradients, fixed-step dynamics, phase-synced mean, collisions =====

            // Canvas & grid
            let uiW = 340,
                canvasW,
                canvasH;
            let gw = 220,
                gh = 140;

            // Field
            let L, gImg;
            let minL = 0,
                maxL = 1;
            let evoTime = 0; // time parameter for noise
            let noiseSeedBase = 0; // base seed for field

            // Agents
            let agents = [],
                trailsLayer;
            let paused = false,
                selectedIdx = -1;

            // Mean phases (unwrapped, in cycles)
            let meanPhaseX = 0.5,
                meanPhaseY = 0.5;

            // Timing
            const PHYS_H = 0.01;
            const MAX_PHYS_STEPS = 8;
            let timeAcc = 0,
                lastSec = 0;

            // Collisions
            const COLLISION_PX = 18;
            const COLLISION_ITERS = 2;

            // UI
            const UI = {};

            function setup() {
                canvasW =
                    windowWidth -
                    parseInt(
                        getComputedStyle(
                            document.documentElement,
                        ).getPropertyValue("--uiw"),
                    );
                canvasH = windowHeight;
                createCanvas(canvasW, canvasH);
                trailsLayer = createGraphics(canvasW, canvasH);
                trailsLayer.clear();

                const N = gw * gh;
                L = new Float32Array(N);
                gImg = createImage(gw, gh);

                hookUI();
                randomizeField();
                resetAgents(parseInt(document.getElementById("sN").value));
                frameRate(60);
                noStroke();
                lastSec = millis() / 1000;
            }

            function windowResized() {
                canvasW =
                    windowWidth -
                    parseInt(
                        getComputedStyle(
                            document.documentElement,
                        ).getPropertyValue("--uiw"),
                    );
                canvasH = windowHeight;
                resizeCanvas(canvasW, canvasH);
                trailsLayer = createGraphics(canvasW, canvasH);
                trailsLayer.clear();
            }

            // ===== UI =====
            function hookUI() {
                function LBL(id, v) {
                    select(id).html(typeof v === "number" ? v.toFixed(3) : v);
                }

                function populateSelectOptions(selectEl, presetNames) {
                    selectEl.innerHTML = "";
                    presetNames.forEach((name) => {
                        if (!PRESETS[name]) return;
                        const opt = document.createElement("option");
                        opt.value = name;
                        opt.textContent = PRESETS[name].label ?? name;
                        selectEl.appendChild(opt);
                    });
                }

                UI.pauseBtn = document.getElementById("pauseBtn");

                UI.sDt = document.getElementById("sDt");
                UI.sStability = document.getElementById("sStability");
                UI.sMeanRadius = document.getElementById("sMeanRadius");

                UI.sN = document.getElementById("sN");
                UI.chkTrails = document.getElementById("chkTrails");
                UI.chkMean = document.getElementById("chkMean");
                UI.btnResetAgents = document.getElementById("btnResetAgents");
                UI.btnRandomField = document.getElementById("btnRandomField");
                UI.btnClearTrails = document.getElementById("btnClearTrails");

                UI.sPerlinFreq = document.getElementById("sPerlinFreq");
                UI.sPerlinOct = document.getElementById("sPerlinOct");
                UI.sNoise = document.getElementById("sNoise");
                UI.chkEvolve = document.getElementById("chkEvolve");
                UI.sEvo = document.getElementById("sEvo");

                UI.sGradR = document.getElementById("sGradR");
                UI.sGradW = document.getElementById("sGradW");

                UI.agentSpawnPreset =
                    document.getElementById("agentSpawnPreset");
                UI.chkAddByClick = document.getElementById("chkAddByClick");
                UI.btnAddCenter = document.getElementById("btnAddCenter");
                UI.btnRandomizeMix = document.getElementById("btnRandomizeMix");

                UI.selInfo = document.getElementById("selInfo");
                UI.selAgentPreset = document.getElementById("selAgentPreset");
                UI.btnApplySelPreset =
                    document.getElementById("btnApplySelPreset");
                UI.btnDeleteSel = document.getElementById("btnDeleteSel");

                populateSelectOptions(UI.agentSpawnPreset, SPAWNER_PRESETS);
                populateSelectOptions(UI.selAgentPreset, PRESET_ORDER);
                UI.agentSpawnPreset.value = SPAWNER_PRESETS[0];
                UI.selAgentPreset.value = PRESET_ORDER[0];

                const refreshLabels = () => {
                    LBL("#lblDt", parseFloat(UI.sDt.value));
                    LBL("#lblN", agents.length);
                    LBL("#lblStability", parseFloat(UI.sStability.value));
                    LBL("#lblMeanR", parseFloat(UI.sMeanRadius.value));
                    LBL("#lblNoise", parseFloat(UI.sNoise.value));
                    LBL("#lblEvo", parseFloat(UI.sEvo.value));
                    LBL("#lblFreq", parseFloat(UI.sPerlinFreq.value));
                    select("#lblOct").html(parseInt(UI.sPerlinOct.value));
                    select("#lblGradR").html(parseInt(UI.sGradR.value));
                    LBL("#lblGradW", parseFloat(UI.sGradW.value));
                };
                refreshLabels();

                ["input", "change"].forEach((evt) => {
                    [
                        UI.sDt,
                        UI.sNoise,
                        UI.sEvo,
                        UI.sPerlinFreq,
                        UI.sPerlinOct,
                        UI.sGradR,
                        UI.sGradW,
                        UI.sStability,
                        UI.sMeanRadius,
                    ].forEach((el) => {
                        el.addEventListener(evt, refreshLabels);
                    });
                });

                // Rebuild field immediately when structure params change
                [UI.sPerlinFreq, UI.sPerlinOct, UI.sNoise].forEach((el) => {
                    el.addEventListener("input", () => {
                        buildFieldAtTime(evoTime);
                    });
                });

                UI.sN.addEventListener("input", () => {
                    adjustAgentCount(parseInt(UI.sN.value));
                    refreshLabels();
                });

                UI.btnResetAgents.addEventListener("click", () => {
                    resetAgents(parseInt(UI.sN.value));
                    refreshLabels();
                });
                UI.btnRandomField.addEventListener("click", () =>
                    randomizeField(),
                );
                UI.btnClearTrails.addEventListener("click", () =>
                    trailsLayer.clear(),
                );

                UI.pauseBtn.addEventListener("click", () => togglePause());
                window.addEventListener("keydown", (e) => {
                    if (e.code === "Space") {
                        togglePause();
                        e.preventDefault();
                    }
                    if (e.key.toLowerCase() === "r") randomizeField();
                    if (e.key.toLowerCase() === "a")
                        resetAgents(parseInt(UI.sN.value));
                    if (e.key.toLowerCase() === "d") deleteSelected();
                });

                UI.btnAddCenter.addEventListener("click", () => {
                    addAgentAt(0.5, 0.5, UI.agentSpawnPreset.value);
                    UI.sN.value = agents.length;
                    refreshLabels();
                });

                UI.btnRandomizeMix.addEventListener("click", () => {
                    for (let i = 0; i < 10; i++) {
                        addAgentAt(
                            Math.random(),
                            Math.random(),
                            SPAWNER_PRESETS[
                                Math.floor(Math.random() * SPAWNER_PRESETS.length)
                            ],
                        );
                    }
                    UI.sN.value = agents.length;
                    refreshLabels();
                });

                UI.btnApplySelPreset.addEventListener("click", () => {
                    if (selectedIdx >= 0 && selectedIdx < agents.length)
                        applyAgentPreset(
                            agents[selectedIdx],
                            UI.selAgentPreset.value,
                        );
                });
                UI.btnDeleteSel.addEventListener("click", () =>
                    deleteSelected(),
                );
            }

            function togglePause() {
                paused = !paused;
                lastSec = millis() / 1000;
                timeAcc = 0;
                document.getElementById("pauseBtn").textContent = paused
                    ? "Resume"
                    : "Pause";
            }

            // ===== Field: fbm-based moving clouds =====
            function randomizeField() {
                noiseSeedBase = Math.floor(Math.random() * 1e9);
                noiseSeed(noiseSeedBase);
                evoTime = 0;
                buildFieldAtTime(evoTime);
                trailsLayer.clear();
            }

            function buildFieldAtTime(t) {
                const freq = parseFloat(UI.sPerlinFreq.value);
                const oct = parseInt(UI.sPerlinOct.value);
                const amp = parseFloat(UI.sNoise.value);

                // Gentle drift across the torus
                const windX = 0.18;
                const windY = -0.12;
                const timeScale = 0.25;

                // Use a fixed seed so the pattern is stable across frames; only t changes
                noiseSeed(noiseSeedBase);

                minL = Infinity;
                maxL = -Infinity;
                let idx = 0;
                const tx = t * windX;
                const ty = t * windY;
                const tz = t * timeScale;

                for (let j = 0; j < gh; j++) {
                    for (let i = 0; i < gw; i++, idx++) {
                        const x = i / (gw - 1);
                        const y = j / (gh - 1);
                        // 3D fbm: smooth morphing but dominated by lateral drift
                        const v = fbm3(
                            (x + tx) * freq,
                            (y + ty) * freq,
                            tz,
                            oct,
                        ); // 0..1
                        const val = amp * (v - 0.5); // centered around 0
                        L[idx] = val;
                        if (val < minL) minL = val;
                        if (val > maxL) maxL = val;
                    }
                }
            }

            // Fractional Brownian motion over 3D noise
            function fbm3(x, y, t, octaves) {
                let sum = 0,
                    amp = 1,
                    freq = 1,
                    norm = 0;
                for (let o = 0; o < octaves; o++) {
                    sum += amp * noise(x * freq, y * freq, t * freq);
                    norm += amp;
                    amp *= 0.5;
                    freq *= 2.0;
                }
                return sum / norm;
            }

            // ===== Scalar sampling & gradients (with lookahead) =====
            function idx2(x, y) {
                const xi = (x + gw) % gw,
                    yi = (y + gh) % gh;
                return yi * gw + xi;
            }
            function wrap01(u) {
                u = u % 1;
                if (u < 0) u += 1;
                return u;
            }
            function wrapDelta(d) {
                if (d > 0.5) d -= 1;
                if (d < -0.5) d += 1;
                return d;
            }
            function wrapDeltaPhase(d) {
                return d - Math.round(d);
            }
            function frac01(u) {
                return u - Math.floor(u);
            }

            function sampleScalar(u, v) {
                const gx = u * (gw - 1),
                    gy = v * (gh - 1);
                let x0 = Math.floor(gx),
                    y0 = Math.floor(gy);
                const tx = gx - x0,
                    ty = gy - y0;
                const x1 = x0 + 1,
                    y1 = y0 + 1;
                const L00 = L[idx2(x0, y0)],
                    L10 = L[idx2(x1, y0)],
                    L01 = L[idx2(x0, y1)],
                    L11 = L[idx2(x1, y1)];
                const Lx0 = lerp(L00, L10, tx),
                    Lx1 = lerp(L01, L11, tx);
                return lerp(Lx0, Lx1, ty);
            }

            function sampleGradRadius(u, v, rCells) {
                const rx = rCells / (gw - 1);
                const ry = rCells / (gh - 1);
                const Lx1 = sampleScalar(wrap01(u + rx), v);
                const Lx0 = sampleScalar(wrap01(u - rx), v);
                const Ly1 = sampleScalar(u, wrap01(v + ry));
                const Ly0 = sampleScalar(u, wrap01(v - ry));
                let dLdu = (Lx1 - Lx0) / (2 * rx);
                let dLdv = (Ly1 - Ly0) / (2 * ry);
                const denom = maxL - minL;
                const norm = denom > 1e-9 ? 1.0 / denom : 1.0;
                return createVector(dLdu * norm, dLdv * norm);
            }

            function sampleGradLookahead(u, v) {
                const w = parseFloat(UI.sGradW.value);
                const rC = parseInt(UI.sGradR.value);
                const gFine = sampleGradRadius(u, v, 1);
                const gCoarse = sampleGradRadius(u, v, Math.max(1, rC));
                return createVector(
                    (1 - w) * gFine.x + w * gCoarse.x,
                    (1 - w) * gFine.y + w * gCoarse.y,
                );
            }

            // ===== Agents (presets & visuals) =====
            const PRESETS = {
                Oi: {
                    label: "Oi (▼)",
                    Oi: 2.0,
                    Oe: -2.0,
                    De: 0.0,
                    Di: 0.0,
                    glyph: "triangleDown",
                },
                Oe: {
                    label: "Oe (✦)",
                    Oi: -2.0,
                    Oe: 2.0,
                    De: 0.0,
                    Di: 0.0,
                    glyph: "star",
                },
                De: {
                    label: "De (+)",
                    Oi: 0.0,
                    Oe: 0.0,
                    De: 2.0,
                    Di: -2.0,
                    glyph: "plus",
                },
                Di: {
                    label: "Di (×)",
                    Oi: 0.0,
                    Oe: 0.0,
                    De: -2.0,
                    Di: 2.0,
                    glyph: "cross",
                },
                DiOi: {
                    label: "DiOi",
                    Di: 1.0,
                    De: -1.0,
                    Oi: 0.3,
                    Oe: -0.2,
                    glyph: "star",
                },
                DiOe: {
                    label: "DiOe",
                    Di: 1.0,
                    De: -1.0,
                    Oe: 0.3,
                    Oi: -0.2,
                    glyph: "triangle",
                },
                DeOi: {
                    label: "DeOi",
                    Di: -1.0,
                    De: 1.0,
                    Oi: 0.3,
                    Oe: -0.2,
                    glyph: "cross",
                },
                DeOe: {
                    label: "DeOe",
                    Di: -1.0,
                    De: 1.0,
                    Oe: 0.3,
                    Oi: -0.2,
                    glyph: "diamond",
                },
                OiDi: {
                    label: "OiDi",
                    Oi: 1.0,
                    Oe: -1.0,
                    Di: 0.3,
                    De: -0.2,
                    glyph: "plus",
                },
                OiDe: {
                    label: "OiDe",
                    Oi: 1.0,
                    Oe: -1.0,
                    De: 0.3,
                    Di: -0.2,
                    glyph: "triangleDown",
                },
                OeDi: {
                    label: "OeDi",
                    Oi: -1.0,
                    Oe: 1.0,
                    De: 0.3,
                    Di: -0.2,
                    glyph: "circle",
                },
                OeDe: {
                    label: "OeDe",
                    Oi: -1.0,
                    Oe: 1.0,
                    De: 0.3,
                    Di: -0.2,
                    glyph: "square",
                },
            };

            const PRESET_ORDER = [
                "Oi",
                "Oe",
                "De",
                "Di",
                "DiOi",
                "DiOe",
                "DeOi",
                "DeOe",
                "OiDi",
                "OiDe",
                "OeDi",
                "OeDe",
            ];

            const SPAWNER_PRESETS = [...PRESET_ORDER];

            const ALL_PRESETS = PRESET_ORDER;

            function applyAgentPreset(a, name) {
                const p = PRESETS[name] ?? { Oi: 0, Oe: 0, De: 0, Di: 0 };
                a.Oi = p.Oi ?? 0;
                a.Oe = p.Oe ?? 0;
                a.De = p.De ?? 0;
                a.Di = p.Di ?? 0;
                a.glyph = p.glyph ?? "circle";
                a.preset = name ?? "balanced";
            }

function addAgentAt(u, v, presetName) {
                const resolvedPreset =
                    presetName ??
                    ALL_PRESETS[Math.floor(Math.random() * ALL_PRESETS.length)];
                const a = {
                    x: u,
                    y: v,
                    x_prev: u,
                    y_prev: v,
                    px: u,
                    py: v, // unwrapped phases
                    vx: 0,
                    vy: 0,
                    fx: 0,
                    fy: 0,
                    fxGrad: 0,
                    fyGrad: 0,
                    fxMean: 0,
                    fyMean: 0,
                    dxGrad: 0,
                    dyGrad: 0,
                    dxMean: 0,
                    dyMean: 0,
                    dispDxGrad: 0,
                    dispDyGrad: 0,
                    dispDxMean: 0,
                    dispDyMean: 0,
                    glyph: "circle",
                    preset: "balanced",
                    Oi: 1,
                    Oe: 1,
                    De: 0.5,
                    Di: 0.5,
                    id: Math.random().toString(36).slice(2),
                };
                applyAgentPreset(a, resolvedPreset);
                agents.push(a);
                selectedIdx = agents.length - 1;
                updateSelectionUI();
            }

            function resetAgents(n) {
                agents = [];
                for (let i = 0; i < n; i++) {
                    addAgentAt(
                        Math.random(),
                        Math.random()
                    );
                }
                trailsLayer.clear();
                selectedIdx = -1;
                updateSelectionUI();
            }

            function adjustAgentCount(n) {
                const cur = agents.length;
                if (n > cur) {
                    for (let i = cur; i < n; i++)
                        addAgentAt(
                            Math.random(),
                            Math.random(),
                            UI.agentSpawnPreset.value,
                        );
                } else {
                    agents.length = n;
                }
                if (selectedIdx >= agents.length) selectedIdx = -1;
                updateSelectionUI();
            }

            function updateSelectionUI() {
                const t =
                    selectedIdx >= 0 && selectedIdx < agents.length
                        ? `#${selectedIdx} (${agents[selectedIdx].preset})`
                        : "None";
                document.getElementById("selInfo").textContent = t;
                if (selectedIdx >= 0 && selectedIdx < agents.length)
                    document.getElementById("selAgentPreset").value =
                        agents[selectedIdx].preset;
                document.getElementById("lblN").textContent = agents.length;
                document.getElementById("sN").value = agents.length;
            }

            function mousePressed() {
                if (
                    mouseX >= 0 &&
                    mouseX < canvasW &&
                    mouseY >= 0 &&
                    mouseY < canvasH
                ) {
                    const { idx, d } = nearestAgent(
                        mouseX / canvasW,
                        mouseY / canvasH,
                    );
                    const pxThresh = 10;
                    if (d * Math.min(canvasW, canvasH) < pxThresh) {
                        selectedIdx = idx;
                        if (keyIsDown(SHIFT)) {
                            deleteSelected();
                            return;
                        }
                        updateSelectionUI();
                    } else if (UI.chkAddByClick.checked) {
                        addAgentAt(
                            mouseX / canvasW,
                            mouseY / canvasH,
                            UI.agentSpawnPreset.value,
                        );
                        updateSelectionUI();
                    }
                }
            }

            function deleteSelected() {
                if (selectedIdx >= 0 && selectedIdx < agents.length) {
                    agents.splice(selectedIdx, 1);
                    selectedIdx = -1;
                    updateSelectionUI();
                }
            }

            function nearestAgent(u, v) {
                let best = -1,
                    bestD = 1e9;
                for (let i = 0; i < agents.length; i++) {
                    const dx = wrapDelta(agents[i].x - u),
                        dy = wrapDelta(agents[i].y - v);
                    const d = Math.hypot(dx, dy);
                    if (d < bestD) {
                        bestD = d;
                        best = i;
                    }
                }
                return { idx: best, d: bestD };
            }

            // ===== Comfort model =====
            function sampleNorm(u, v) {
                const gx = u * (gw - 1),
                    gy = v * (gh - 1);
                const x0 = Math.floor(gx),
                    y0 = Math.floor(gy);
                const tx = gx - x0,
                    ty = gy - y0;
                function Lat(ix, iy) {
                    return L[idx2(ix, iy)];
                }
                const L00 = Lat(x0, y0),
                    L10 = Lat(x0 + 1, y0),
                    L01 = Lat(x0, y0 + 1),
                    L11 = Lat(x0 + 1, y0 + 1);
                const Lx0 = lerp(L00, L10, tx),
                    Lx1 = lerp(L01, L11, tx),
                    Lv = lerp(Lx0, Lx1, ty);
                const denom = maxL - minL;
                return denom > 1e-9 ? (Lv - minL) / denom : 0.0;
            }

            function agentDiscomfort(a, xr, yr, GM) {
                // Global multipliers removed → use per-agent weights only
                const mOe = 1.0;
                const mDe = 1.0;
                const mDi = 1.0;

                const e = sampleNorm(xr, yr);
                const targetOe = a.Oe >= 0 ? 1.0 : 0.0;
                const wOe = Math.abs(a.Oe * mOe);
                const varMismatch = Math.abs(e - targetOe);

                const dxS = wrapDeltaPhase(a.px - GM.mxPhase);
                const dyS = wrapDeltaPhase(a.py - GM.myPhase);
                const MAX_TORUS_DIST = Math.SQRT2 / 2;
                const dNorm = Math.min(
                    1,
                    Math.hypot(dxS, dyS) / MAX_TORUS_DIST,
                );

                const targetDi = a.Di >= 0 ? 0.75 : 0.0;
                const targetDe = a.De >= 0 ? 0.0 : 0.75;
                const wDi = Math.abs(a.Di * mDi);
                const wDe = Math.abs(a.De * mDe);
                const sigMismatch = Math.abs(dNorm - targetDi);
                const connMismatch = Math.abs(dNorm - targetDe);

                const num =
                    wOe * varMismatch + wDi * sigMismatch + wDe * connMismatch;
                const den = wOe + wDi + wDe + 1e-9;
                return Math.min(1, Math.max(0, num / den));
            }

            // ===== Local mean (phase-synced within radius) =====
            function computeLocalMean(a, radius) {
                if (agents.length === 0) {
                    return {
                        mx: frac01(meanPhaseX),
                        my: frac01(meanPhaseY),
                        mxPhase: meanPhaseX,
                        myPhase: meanPhaseY,
                    };
                }
                let sx = 0,
                    sy = 0,
                    n = 0;
                for (const b of agents) {
                    const dx = wrapDelta(b.x - a.x);
                    const dy = wrapDelta(b.y - a.y);
                    const d = Math.hypot(dx, dy);
                    if (d <= radius) {
                        const pxAdj = a.px + wrapDeltaPhase(b.px - a.px);
                        const pyAdj = a.py + wrapDeltaPhase(b.py - a.py);
                        sx += pxAdj;
                        sy += pyAdj;
                        n++;
                    }
                }
                if (n === 0) {
                    return {
                        mx: frac01(a.px),
                        my: frac01(a.py),
                        mxPhase: a.px,
                        myPhase: a.py,
                    };
                }
                const mxPhase = sx / n;
                const myPhase = sy / n;
                return {
                    mx: frac01(mxPhase),
                    my: frac01(myPhase),
                    mxPhase,
                    myPhase,
                };
            }

            // Global mean (kept for rendering/metrics)
            function computeGroupMean() {
                if (agents.length === 0) {
                    return { mx: 0.5, my: 0.5, mxPhase: 0.5, myPhase: 0.5 };
                }
                const ref = agents[0];
                let sx = ref.px,
                    sy = ref.py,
                    n = 1;
                for (let i = 1; i < agents.length; i++) {
                    const b = agents[i];
                    const pxAdj = ref.px + wrapDeltaPhase(b.px - ref.px);
                    const pyAdj = ref.py + wrapDeltaPhase(b.py - ref.py);
                    sx += pxAdj;
                    sy += pyAdj;
                    n++;
                }
                const mxPhase = sx / n;
                const myPhase = sy / n;
                return { mx: frac01(mxPhase), my: frac01(myPhase), mxPhase, myPhase };
            }

            // ===== Collisions =====
            function collideAgents(radiusNorm, iterations = 2) {
                if (agents.length <= 1) return;
                const cell = radiusNorm;
                const nx = Math.max(1, Math.ceil(1 / cell));
                const ny = Math.max(1, Math.ceil(1 / cell));
                const buckets = new Array(nx * ny);
                for (let i = 0; i < buckets.length; i++) buckets[i] = [];

                for (let i = 0; i < agents.length; i++) {
                    const a = agents[i];
                    let cx = Math.floor(frac01(a.x) / cell);
                    let cy = Math.floor(frac01(a.y) / cell);
                    cx = Math.min(nx - 1, Math.max(0, cx));
                    cy = Math.min(ny - 1, Math.max(0, cy));
                    buckets[cy * nx + cx].push(i);
                }

                const neigh = [-1, 0, 1];
                for (let iter = 0; iter < iterations; iter++) {
                    for (let cy = 0; cy < ny; cy++)
                        for (let cx = 0; cx < nx; cx++) {
                            for (let oy of neigh)
                                for (let ox of neigh) {
                                    const nxC = (cx + ox + nx) % nx;
                                    const nyC = (cy + oy + ny) % ny;
                                    const A = buckets[cy * nx + cx];
                                    const B = buckets[nyC * nx + nxC];
                                    if (A === B) {
                                        for (let u = 0; u < A.length; u++)
                                            for (
                                                let v = u + 1;
                                                v < A.length;
                                                v++
                                            )
                                                projectPair(
                                                    A[u],
                                                    A[v],
                                                    radiusNorm,
                                                );
                                    } else {
                                        for (let u = 0; u < A.length; u++)
                                            for (let v = 0; v < B.length; v++)
                                                projectPair(
                                                    A[u],
                                                    B[v],
                                                    radiusNorm,
                                                );
                                    }
                                }
                        }
                }
            }

            function projectPair(i, j, r) {
                const a = agents[i],
                    b = agents[j];
                let dx = wrapDelta(a.x - b.x),
                    dy = wrapDelta(a.y - b.y);
                const d2 = dx * dx + dy * dy,
                    r2 = r * r;
                if (d2 >= r2 || d2 < 1e-12) return;
                const d = Math.sqrt(d2),
                    overlap = r - d,
                    k = (overlap / (d + 1e-12)) * 0.5;
                const cx = dx * k,
                    cy = dy * k;
                a.x = wrap01(a.x + cx);
                a.y = wrap01(a.y + cy);
                b.x = wrap01(b.x - cx);
                b.y = wrap01(b.y - cy);
                a.px += cx;
                a.py += cy;
                b.px -= cx;
                b.py -= cy;
            }

            // ===== Dynamics =====
            function stepAgents(h) {
                // Global multipliers removed → all = 1
                const mOi = 1.0,
                    mOe = 1.0,
                    mDe = 1.0,
                    mDi = 1.0;

                const meanRadius = parseFloat(UI.sMeanRadius.value);
                const noiseScale = Math.sqrt(h / PHYS_H);
                const stabilityFactor = parseFloat(UI.sStability.value);
                const MEAN_FORCE_GAIN = 3.0; // amplify Di/De influence so it visibly affects motion
                const ARROW_SMOOTH = 0.85; // soften arrow jitter without changing dynamics
                const maxStep = 0.1;

                for (const a of agents) {
                    a.x_prev = a.x;
                    a.y_prev = a.y;

                    const GM = computeLocalMean(a, meanRadius);
                    const grad = sampleGradLookahead(a.x, a.y);

                    const effOi = a.Oi * mOi;
                    const effDe = a.De * mDe;
                    const effDi = a.Di * mDi;
                    const meanK = effDe - effDi;

                    let fxGrad = -effOi * grad.x;
                    let fyGrad = -effOi * grad.y;

                    const dxMean = wrapDeltaPhase(GM.mxPhase - a.px);
                    const dyMean = wrapDeltaPhase(GM.myPhase - a.py);
                    let fxMean = MEAN_FORCE_GAIN * meanK * dxMean;
                    let fyMean = MEAN_FORCE_GAIN * meanK * dyMean;

                    const noiseAmp = a.Oe * mOe * noiseScale;
                    fxGrad += noiseAmp * randn();
                    fyGrad += noiseAmp * randn();

                    const fx = fxGrad + fxMean;
                    const fy = fyGrad + fyMean;

                    // Proposed displacements per component (normalized coords)
                    let dxGrad = fxGrad * h * stabilityFactor;
                    let dyGrad = fyGrad * h * stabilityFactor;
                    let dxMeanStep = fxMean * h * stabilityFactor;
                    let dyMeanStep = fyMean * h * stabilityFactor;

                    let dx = dxGrad + dxMeanStep;
                    let dy = dyGrad + dyMeanStep;
                    const stepMag = Math.hypot(dx, dy);
                    if (stepMag > maxStep) {
                        const s = maxStep / stepMag;
                        dx *= s;
                        dy *= s;
                        dxGrad *= s;
                        dyGrad *= s;
                        dxMeanStep *= s;
                        dyMeanStep *= s;
                    }

                    a.fx = fx;
                    a.fy = fy;
                    a.fxGrad = fxGrad;
                    a.fyGrad = fyGrad;
                    a.fxMean = fxMean;
                    a.fyMean = fyMean;
                    a.dxGrad = dxGrad;
                    a.dyGrad = dyGrad;
                    a.dxMean = dxMeanStep;
                    a.dyMean = dyMeanStep;
                    a.dxStep = dx;
                    a.dyStep = dy;
                    a.localMeanX = GM.mx;
                    a.localMeanY = GM.my;

                    a.dispDxGrad =
                        ARROW_SMOOTH * a.dispDxGrad +
                        (1 - ARROW_SMOOTH) * dxGrad;
                    a.dispDyGrad =
                        ARROW_SMOOTH * a.dispDyGrad +
                        (1 - ARROW_SMOOTH) * dyGrad;
                    a.dispDxMean =
                        ARROW_SMOOTH * a.dispDxMean +
                        (1 - ARROW_SMOOTH) * dxMeanStep;
                    a.dispDyMean =
                        ARROW_SMOOTH * a.dispDyMean +
                        (1 - ARROW_SMOOTH) * dyMeanStep;

                    a.x = wrap01(a.x + dx);
                    a.y = wrap01(a.y + dy);

                    a.px += wrapDelta(a.x - a.x_prev);
                    a.py += wrapDelta(a.y - a.y_prev);
                }

                const rNorm = COLLISION_PX / Math.min(canvasW, canvasH);
                collideAgents(rNorm, COLLISION_ITERS);

                if (UI.chkTrails.checked) {
                    for (const a of agents) {
                        trailsLayer.noStroke();
                        trailsLayer.fill(240, 240, 255, 40);
                        trailsLayer.circle(a.x * canvasW, a.y * canvasH, 2.2);
                    }
                    trailsLayer.push();
                    trailsLayer.erase(12, 12);
                    trailsLayer.rect(
                        0,
                        0,
                        trailsLayer.width,
                        trailsLayer.height,
                    );
                    trailsLayer.noErase();
                    trailsLayer.pop();
                }
            }

            // ===== Visuals =====
            function lerpWrap(a, b, t) {
                let d = b - a;
                if (d > 0.5) d -= 1;
                if (d < -0.5) d += 1;
                let x = a + d * t;
                if (x < 0) x += 1;
                if (x >= 1) x -= 1;
                return x;
            }

            function colormapCool(t) {
                t = Math.min(1, Math.max(0, t));
                const h = 240 - 200 * t; // blue→teal→orange
                const s = 1.0,
                    v = 0.9;
                return hsv2rgb(h, s, v);
            }

            function hsv2rgb(h, s, v) {
                const c = v * s,
                    hh = h / 60,
                    x = c * (1 - Math.abs((hh % 2) - 1));
                let r = 0,
                    g = 0,
                    b = 0;
                if (0 <= hh && hh < 1) {
                    r = c;
                    g = x;
                    b = 0;
                } else if (1 <= hh && hh < 2) {
                    r = x;
                    g = c;
                    b = 0;
                } else if (2 <= hh && hh < 3) {
                    r = 0;
                    g = c;
                    b = x;
                } else if (3 <= hh && hh < 4) {
                    r = 0;
                    g = x;
                    b = c;
                } else if (4 <= hh && hh < 5) {
                    r = x;
                    g = 0;
                    b = c;
                } else if (5 <= hh && hh <= 6) {
                    r = c;
                    g = 0;
                    b = x;
                }
                const m = v - c;
                return [
                    Math.round(255 * (r + m)),
                    Math.round(255 * (g + m)),
                    Math.round(255 * (b + m)),
                ];
            }

            function fieldToImage() {
                const inv = maxL - minL > 1e-9 ? 1 / (maxL - minL) : 1.0;
                const COLOR_CAP = 0.88,
                    GAMMA = 0.95;
                gImg.loadPixels();
                for (let j = 0; j < gh; j++)
                    for (let i = 0; i < gw; i++) {
                        const idx = j * gw + i;
                        const tRaw = (L[idx] - minL) * inv;
                        const t = Math.min(COLOR_CAP, Math.pow(tRaw, GAMMA));
                        const c = colormapCool(t);
                        const p = 4 * idx;
                        gImg.pixels[p + 0] = c[0];
                        gImg.pixels[p + 1] = c[1];
                        gImg.pixels[p + 2] = c[2];
                        gImg.pixels[p + 3] = 255;
                    }
                gImg.updatePixels();
            }

            function drawAgent(a, i, alpha, GM) {
                const xr = lerpWrap(a.x_prev, a.x, alpha);
                const yr = lerpWrap(a.y_prev, a.y, alpha);
                const px = xr * canvasW,
                    py = yr * canvasH;

                const base =
                    a.Oi > a.Oe
                        ? [10, 55, 185]
                        : a.Oe > a.Oi
                          ? [255, 215, 0]
                          : [140, 160, 190];
                const d = agentDiscomfort(a, xr, yr, GM);
                const hue = 120 * (1 - d);
                const comfortRGB = hsv2rgb(hue, 1.0, 1.0);
                const glyphType = a.Di > a.De ? "triangle" : "triangleDown";

                noStroke();
                // fill(base[0], base[1], base[2], 255);
                // circle(px, py, 20);

                fill(comfortRGB[0], comfortRGB[1], comfortRGB[2], 235);
                drawGlyph(glyphType, px, py, 20);

                fill(base[0], base[1], base[2], 255);
                drawGlyph(glyphType, px, py, 10);


                // noFill();
                // stroke(comfortRGB[0], comfortRGB[1], comfortRGB[2], 235);
                // strokeWeight(3);
                // circle(px, py, 3);

                drawForceArrow(px, py, a.dispDxGrad, a.dispDyGrad, [30, 120, 255], 1.0);
                drawForceArrow(px, py, a.dispDxMean, a.dispDyMean, [255, 80, 80], 1.0);

                if (i === selectedIdx) {
                    noFill();
                    stroke(255, 220, 120, 230);
                    strokeWeight(2);
                    circle(px, py, 9);
                    // Show mean-radius ring and target
                    noFill();
                    stroke(120, 140, 200, 150);
                    strokeWeight(1.5);
                    const rPx =
                        parseFloat(UI.sMeanRadius.value) *
                        Math.min(canvasW, canvasH);
                    circle(px, py, 2 * rPx);
                    fill(255, 140, 80, 220);
                    noStroke();
                    circle(
                        a.localMeanX * canvasW,
                        a.localMeanY * canvasH,
                        6,
                    );
                }
                noStroke();
                fill(200);
                // circle(px, py, 2.2);
            }

            function drawGlyph(type, px, py, size) {
                push();
                translate(px, py);
                switch (type) {
                    case "triangle":
                        {
                            const r = size * 0.62,
                                h = r * Math.sqrt(3);
                            triangle(0, -h / 2, -r, h / 2, r, h / 2);
                        }
                        break;
                    case "triangleDown":
                        {
                            const r = size * 0.62,
                                h = r * Math.sqrt(3);
                            triangle(0, h / 2, -r, -h / 2, r, -h / 2);
                        }
                        break;
                    case "square":
                        rectMode(CENTER);
                        square(0, 0, size, 2);
                        break;
                    case "diamond":
                        rotate(Math.PI / 4);
                        rectMode(CENTER);
                        square(0, 0, size, 2);
                        break;
                    case "star":
                        {
                            beginShape();
                            const points = 5,
                                outerR = size * 0.6,
                                innerR = size * 0.28;
                            for (let i = 0; i < points * 2; i++) {
                                const ang = (i * Math.PI) / points;
                                const r = i % 2 === 0 ? outerR : innerR;
                                vertex(Math.cos(ang) * r, Math.sin(ang) * r);
                            }
                            endShape(CLOSE);
                        }
                        break;
                    case "plus":
                        rectMode(CENTER);
                        push();
                        rotate(0);
                        rect(0, 0, size * 1.2, size * 0.28, 2);
                        pop();
                        push();
                        rotate(Math.PI / 2);
                        rect(0, 0, size * 1.2, size * 0.28, 2);
                        pop();
                        break;
                    case "cross":
                        rectMode(CENTER);
                        push();
                        rotate(Math.PI / 4);
                        rect(0, 0, size * 1.2, size * 0.28, 2);
                        pop();
                        push();
                        rotate(-Math.PI / 4);
                        rect(0, 0, size * 1.2, size * 0.28, 2);
                        pop();
                        break;
                    default:
                        circle(0, 0, size);
                }
                pop();
            }

            function drawForceArrow(px, py, dxNorm, dyNorm, colorRGB, alphaScale = 1) {
                const mag = Math.hypot(dxNorm || 0, dyNorm || 0);
                if (mag < 1e-6) return;
                const sx = dxNorm * canvasW;
                const sy = dyNorm * canvasH;
                const len = Math.hypot(sx, sy);
                const minLen = 10;
                const scale = len > 1e-6 ? Math.max(1, minLen / len) : 1;
                const dx = sx * scale;
                const dy = sy * scale;
                stroke(
                    colorRGB[0],
                    colorRGB[1],
                    colorRGB[2],
                    Math.min(255, 220 * alphaScale),
                );
                strokeWeight(2.4);
                noFill();
                line(px, py, px + dx, py + dy);
            }

            function computeMetrics(GM) {
                const binsX = 12,
                    binsY = 8,
                    N = agents.length;
                const H = new Array(binsX * binsY).fill(0);
                let meanD = 0;
                for (const a of agents) {
                    let ix = Math.floor(frac01(a.x) * binsX);
                    ix = Math.min(binsX - 1, Math.max(0, ix));
                    let iy = Math.floor(frac01(a.y) * binsY);
                    iy = Math.min(binsY - 1, Math.max(0, iy));
                    H[iy * binsX + ix]++;
                    meanD += agentDiscomfort(a, a.x, a.y, GM);
                }
                meanD = N > 0 ? meanD / N : 0;

                let entropy = 0;
                for (let i = 0; i < H.length; i++) {
                    if (H[i] > 0) {
                        const p = H[i] / N;
                        entropy -= p * Math.log(p);
                    }
                }
                const entropyNorm =
                    H.length > 1 ? entropy / Math.log(H.length) : 0;

                let s2 = 0;
                for (const a of agents) {
                    const dx = wrapDeltaPhase(a.px - GM.mxPhase);
                    const dy = wrapDeltaPhase(a.py - GM.myPhase);
                    s2 += dx * dx + dy * dy;
                }
                const sigma = N > 0 ? Math.sqrt(s2 / N) : 0;

                const eps = 0.07,
                    eps2 = eps * eps;
                const parent = Array.from({ length: N }, (_, i) => i);
                const find = (i) =>
                    parent[i] === i ? i : (parent[i] = find(parent[i]));
                const unite = (a, b) => {
                    a = find(a);
                    b = find(b);
                    if (a !== b) parent[a] = b;
                };
                for (let i = 0; i < N; i++)
                    for (let j = i + 1; j < N; j++) {
                        const dx = wrapDelta(agents[i].x - agents[j].x),
                            dy = wrapDelta(agents[i].y - agents[j].y);
                        if (dx * dx + dy * dy < eps2) unite(i, j);
                    }
                let roots = new Set();
                for (let i = 0; i < N; i++) roots.add(find(i));
                const clusters = N === 0 ? 0 : roots.size;

                const el = document.getElementById("metrics");
                el.innerHTML = `
        <div><strong>H</strong> (spatial entropy): ${entropyNorm.toFixed(3)}</div>
        <div><strong>σ</strong> (spread): ${sigma.toFixed(3)}</div>
        <div><strong>Clusters</strong>: ${clusters}</div>
        <div><strong>Avg discomfort</strong>: ${meanD.toFixed(3)}</div>
        <div class="tiny">L range: ${minL.toFixed(2)} .. ${maxL.toFixed(2)} | fps: ${Math.round(frameRate())}</div>
      `;
            }

            function draw() {
                const simSpeed = parseFloat(UI.sDt.value);
                const evoOn = UI.chkEvolve.checked;

                const nowSec = millis() / 1000;
                let dtReal = nowSec - lastSec;
                lastSec = nowSec;

                // Field evolution: purely via fbm time parameter
                if (evoOn) {
                    const flowSpeed = parseFloat(UI.sEvo.value);
                    evoTime += dtReal * flowSpeed;
                }
                // Rebuild field regularly
                if (evoOn || frameCount % 2 === 0 || frameCount === 1) {
                    buildFieldAtTime(evoTime);
                }

                // Physics
                if (!paused) {
                    timeAcc += dtReal * simSpeed;
                    let steps = 0;
                    while (timeAcc >= PHYS_H && steps < MAX_PHYS_STEPS) {
                        stepAgents(PHYS_H);
                        timeAcc -= PHYS_H;
                        steps++;
                    }
                    if (steps >= MAX_PHYS_STEPS)
                        timeAcc = Math.min(timeAcc, PHYS_H);
                } else {
                    timeAcc = 0;
                }

                // Render field + trails
                if (frameCount % 2 === 0) fieldToImage();
                image(gImg, 0, 0, canvasW, canvasH);
                image(trailsLayer, 0, 0);

                const alpha = paused ? 0 : Math.min(1, timeAcc / PHYS_H);
                const GM = computeGroupMean();
                for (let i = 0; i < agents.length; i++)
                    drawAgent(agents[i], i, alpha, GM);

                if (UI.chkMean.checked && agents.length > 0) {
                    push();
                    stroke(255, 230);
                    strokeWeight(1);
                    const px = GM.mx * canvasW,
                        py = GM.my * canvasH;
                    line(px - 10, py, px + 10, py);
                    line(px, py - 10, px, py + 10);
                    pop();
                }

                computeMetrics(GM);
            }

            // ===== Helpers =====
            let spare = null;
            function randn() {
                if (spare !== null) {
                    const v = spare;
                    spare = null;
                    return v;
                }
                let u = 0,
                    v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                const mag = Math.sqrt(-2.0 * Math.log(u));
                const z0 = mag * Math.cos(TWO_PI * v),
                    z1 = mag * Math.sin(TWO_PI * v);
                spare = z1;
                return z0;
            }
        </script>
    </body>
</html>
