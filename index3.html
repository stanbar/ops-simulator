<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>BCM — Voids (External + Internal) + Collective Locks + Adaptive Keys</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
      :root { --uiw: 340px; }
      html, body {
        margin: 0; height: 100%;
        background: #0e0f12; color: #e8eaf1;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell,
          "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      }
      #ui{
        position: fixed; top:0; right:0;
        width: var(--uiw); height:100%;
        overflow-y:auto; box-sizing:border-box;
        padding:14px 14px 120px;
        background:#14161b; border-left:1px solid #1e2230;
      }
      #ui h2{
        margin:8px 0 10px; font-size:16px; font-weight:700;
        letter-spacing:0.3px;
      }
      #ui .group{
        border:1px solid #1f2535; border-radius:10px;
        padding:10px; margin-bottom:12px; background:#10131a;
      }
      #ui label{ display:block; font-size:12px; opacity:.85; margin:6px 0 4px; }
      #ui input[type="range"]{ width:100%; }
      #ui .row{ display:flex; gap:8px; align-items:center; }
      #ui .row>*{ flex:1; }
      #ui button, #ui select{
        width:100%; border-radius:8px; border:1px solid #2a3248;
        padding:8px 10px; background:#18202d; color:#e8eaf1; cursor:pointer;
      }
      #ui button:hover{ background:#1c2737; }
      #ui .tiny{ font-size:11px; opacity:.8; }

      #metrics{
        position: fixed; left:10px; top:10px;
        background: rgba(8,10,14,.78);
        padding:8px 10px; border-radius:8px;
        border:1px solid #1e2230; backdrop-filter: blur(6px);
      }
      canvas{ display:block; }
      a { color: #6fb3ff; }
    </style>
  </head>

  <body>
    <div id="ui">
      <h2>BCM Cognitive Landscape</h2>

      <div class="group">
        <div class="row" style="gap:6px">
          <button id="pauseBtn">Pause</button>
        </div>
      </div>

      <div class="group">
        <h3 style="margin:6px 0 6px; font-size:13px">Simulation</h3>
        <label>Simulation speed: <span id="lblDt">3.00</span></label>
        <input id="sDt" type="range" min="0.2" max="30.0" step="0.01" value="3.00" />
        <label>Stability factor: <span id="lblStability">0.020</span></label>
        <input id="sStability" type="range" min="0.001" max="0.060" step="0.001" value="0.020" />
        <label>Mean radius (field fraction): <span id="lblMeanR">0.25</span></label>
        <input id="sMeanRadius" type="range" min="0.05" max="0.6" step="0.01" value="0.25" />
      </div>

      <div class="group">
        <h3 style="margin:6px 0 6px; font-size:13px">Cognitive Landscape (visual)</h3>
        <label>Structure scale (Perlin freq): <span id="lblFreq">2.50</span></label>
        <input id="sPerlinFreq" type="range" min="0.5" max="8.0" step="0.05" value="2.50" />
        <label>Octaves: <span id="lblOct">3</span></label>
        <input id="sPerlinOct" type="range" min="1" max="6" step="1" value="3" />
        <label>Contrast (amplitude): <span id="lblNoise">0.40</span></label>
        <input id="sNoise" type="range" min="0" max="1.00" step="0.01" value="0.40" />
        <label><input type="checkbox" id="chkEvolve" checked /> Animate field over time</label>
        <label>Flow speed: <span id="lblEvo">0.20</span></label>
        <input id="sEvo" type="range" min="0.0" max="3.0" step="0.01" value="0.20" />
      </div>

      <div class="group">
        <label>Agents: <span id="lblN">40</span></label>
        <input id="sN" type="range" min="0" max="200" step="1" value="40" />
        <label>Show Trails <input id="chkTrails" type="checkbox" checked /></label>
        <label>Show Force Arrows <input id="chkForces" type="checkbox" /></label>
        <label>Show Group Mean <input id="chkMean" type="checkbox" checked /></label>
        <label>Show Needs Bars <input id="chkNeeds" type="checkbox" checked /></label>
        <div class="row" style="margin-top:8px; gap:6px">
          <button id="btnResetAgents">Reset Agents</button>
          <button id="btnRandomField">Randomize Field</button>
          <button id="btnClearTrails">Clear Trails</button>
        </div>
      </div>

      <div class="group">
        <h3 style="margin:6px 0 6px; font-size:13px">Internal Voids (Needs)</h3>
        <label><input id="chkInternal" type="checkbox" checked /> Enable internal voids</label>

        <label>Need decay: <span id="lblNeedDecay">0.060</span></label>
        <input id="sNeedDecay" type="range" min="0" max="0.20" step="0.005" value="0.060" />

        <label>Need refill: <span id="lblNeedFill">0.35</span></label>
        <input id="sNeedFill" type="range" min="0" max="1.0" step="0.01" value="0.35" />

        <div class="tiny">
          Needs: Safety (solve threats), Connection (be with people), Stimulation (novelty), Mastery (learn keys).
        </div>
      </div>

      <div class="group">
        <h3 style="margin:6px 0 6px; font-size:13px">External Voids (Tasks / Emergencies)</h3>

        <label>Spawn rate / min: <span id="lblVoidRate">18</span></label>
        <input id="sVoidRate" type="range" min="0" max="140" step="1" value="18" />

        <label>Max active voids: <span id="lblVoidMax">40</span></label>
        <input id="sVoidMax" type="range" min="0" max="160" step="1" value="40" />

        <label>Growth rate: <span id="lblVoidGrow">0.060</span></label>
        <input id="sVoidGrow" type="range" min="0" max="0.30" step="0.005" value="0.060" />

        <label>Big-disaster chance: <span id="lblVoidBig">0.020</span></label>
        <input id="sVoidBig" type="range" min="0" max="0.25" step="0.005" value="0.020" />

        <label>Work rate: <span id="lblWorkRate">0.220</span></label>
        <input id="sWorkRate" type="range" min="0" max="1.2" step="0.01" value="0.220" />

        <label>Emergency threshold: <span id="lblEmerg">0.80</span></label>
        <input id="sEmerg" type="range" min="0.3" max="1.0" step="0.01" value="0.80" />

        <label>Collective factor: <span id="lblCollect">1.00</span></label>
        <input id="sCollect" type="range" min="0.2" max="3.0" step="0.05" value="1.00" />

        <label><input id="chkShowVoids" type="checkbox" checked /> Show voids</label>
        <div class="tiny">
          Some voids need a team or a specific role (Ti-like / Te-like) to finish.
        </div>
      </div>

      <div class="group">
        <h3 style="margin:6px 0 6px; font-size:13px">Communication (Blast / Audience)</h3>

        <label>Signal range: <span id="lblSigR">0.22</span></label>
        <input id="sSigR" type="range" min="0.05" max="0.70" step="0.01" value="0.22" />

        <label>Signal TTL (sec): <span id="lblSigTTL">6.0</span></label>
        <input id="sSigTTL" type="range" min="1" max="25" step="0.5" value="6.0" />

        <label><input id="chkShowSignals" type="checkbox" checked /> Show signals</label>
      </div>

      <div class="group">
        <h3 style="margin:6px 0 6px; font-size:13px">Agent Spawner</h3>
        <label>Preset for new agent</label>
        <select id="agentSpawnPreset"></select>
        <label><input type="checkbox" id="chkAddByClick" checked /> Add by click on canvas</label>
        <div class="row" style="margin-top:8px; gap:6px">
          <button id="btnAddCenter">Add at center</button>
          <button id="btnRandomizeMix">Add 10 mixed</button>
        </div>
      </div>

      <div class="group">
        <h3 style="margin:6px 0 6px; font-size:13px">Selected Agent</h3>
        <div class="tiny">
          Click an agent to select it. Shift-click to delete. Press <b>V</b> to spawn a big void.
        </div>
        <div style="margin-top:6px">Selected: <span id="selInfo">None</span></div>
        <label>Change preset</label>
        <select id="selAgentPreset"></select>
        <div class="row" style="margin-top:8px; gap:6px">
          <button id="btnApplySelPreset">Apply to selected</button>
          <button id="btnDeleteSel">Delete selected</button>
        </div>
      </div>

      <div class="group tiny">
        <div style="font-weight:700; margin-bottom:4px">Legend</div>
        <div style="margin-bottom:4px">
          <span style="color:#0a3ca0">●</span> Oi &gt; Oe
          <span style="color:#f6d000; margin-left:8px">●</span> Oe &gt; Oi
        </div>
        <div style="margin-bottom:4px">
          <span style="color:#e8eaf1">▲</span> Di &gt; De
          <span style="color:#e8eaf1; margin-left:8px">▼</span> De &gt;= Di
        </div>
        <div style="margin-bottom:4px">
          <span style="color:#2b8dff">▁</span> task/void pull (blue arrow)
          <span style="color:#ff5050; margin-left:8px">▁</span> social pull (red arrow)
        </div>
        <div class="tiny">
          External void types (by ring color): Safety=red, Connection=orange, Stimulation=purple, Mastery=cyan.
        </div>
      </div>
    </div>

    <div id="metrics"></div>

    <script>
      // ============================================================
      // BCM SIM (single-file)
      // - External voids: "locks" (shape patterns) in real space.
      // - Internal voids: needs meters that create cognitive load.
      // - Collective locks: work + role constraints (Ti/Te).
      // - Adaptation: Mastery can evolve keys in response to unsolved locks.
      // ============================================================

      // ===== Canvas & grid =====
      let canvasW, canvasH;
      let gw = 220, gh = 140;

      // ===== Visual field (background only) =====
      let L, gImg;
      let minL = 0, maxL = 1;
      let evoTime = 0;
      let noiseSeedBase = 0;

      // ===== Agents =====
      let agents = [], trailsLayer;
      let paused = false, selectedIdx = -1;

      // ===== Timing =====
      const PHYS_H = 0.01;
      const MAX_PHYS_STEPS = 8;
      let timeAcc = 0, lastSec = 0;

      // ===== Collisions =====
      const COLLISION_PX = 18;
      const COLLISION_ITERS = 2;

      // ===== UI =====
      const UI = {};

      // ===== Needs / Internal voids =====
      const NEEDS = ["Safety","Connection","Stimulation","Mastery"];
      const N_SAFETY = 0, N_CONN = 1, N_STIM = 2, N_MAST = 3;

      // ===== Voids + Signals =====
      let voids = [];
      let signals = [];
      let nextVoidId = 1;

      // ===== Shape-based keys/locks =====
      const SHAPE_N = 7;
      const SHAPE_C = SHAPE_N * SHAPE_N;
      const SHAPES = [];              // {name, cells:Int8Array, mass}
      const COMMON_SHAPE_IDS = [];     // indices into SHAPES

      function clamp01(x){ return Math.max(0, Math.min(1, x)); }
      function sigmoid(x){ return 1/(1+Math.exp(-x)); }
      function frac01(u){ return u - Math.floor(u); }
      function wrap01(u){ u = u % 1; if (u < 0) u += 1; return u; }
      function wrapDelta(d){ if (d > 0.5) d -= 1; if (d < -0.5) d += 1; return d; }
      function wrapDeltaPhase(d){ return d - Math.round(d); }

      function torusVec(ax, ay, bx, by){
        const dx = wrapDelta(bx - ax);
        const dy = wrapDelta(by - ay);
        return { dx, dy, d: Math.hypot(dx, dy) };
      }

      // ===== Shapes =====
      function idxS(x,y){ return y*SHAPE_N + x; }
      function shapeMass(cells){
        let m = 0;
        for (let i=0;i<cells.length;i++) m += cells[i] ? 1 : 0;
        return m;
      }
      function addShape(name, cellsArray){
        const cells = new Int8Array(SHAPE_C);
        for (let i=0;i<SHAPE_C;i++) cells[i] = cellsArray[i] ? 1 : 0;
        const mass = shapeMass(cells);
        const id = SHAPES.length;
        SHAPES.push({ name, cells, mass });
        return id;
      }
      function cloneCells(c){
        const out = new Int8Array(c.length);
        out.set(c);
        return out;
      }
      function shapeOR(a,b){
        const out = new Int8Array(SHAPE_C);
        for (let i=0;i<SHAPE_C;i++) out[i] = (a[i] || b[i]) ? 1 : 0;
        return out;
      }

      function randomShape(density=0.22, smoothPasses=2){
        let c = new Int8Array(SHAPE_C);
        for (let y=0;y<SHAPE_N;y++){
          for (let x=0;x<SHAPE_N;x++){
            const cx = (x-(SHAPE_N-1)/2)/(SHAPE_N/2);
            const cy = (y-(SHAPE_N-1)/2)/(SHAPE_N/2);
            const centerBias = Math.exp(-(cx*cx+cy*cy)*1.2);
            const p = density*(0.65 + 0.7*centerBias);
            c[idxS(x,y)] = (Math.random() < p) ? 1 : 0;
          }
        }
        for (let pass=0; pass<smoothPasses; pass++){
          const n = new Int8Array(SHAPE_C);
          for (let y=0;y<SHAPE_N;y++){
            for (let x=0;x<SHAPE_N;x++){
              let sum = 0;
              for (let oy=-1; oy<=1; oy++){
                for (let ox=-1; ox<=1; ox++){
                  if (ox===0 && oy===0) continue;
                  const xx = x+ox, yy = y+oy;
                  if (xx<0||xx>=SHAPE_N||yy<0||yy>=SHAPE_N) continue;
                  sum += c[idxS(xx,yy)];
                }
              }
              const here = c[idxS(x,y)];
              const keep = (sum >= 4) ? 1 : (sum <= 1 ? 0 : here);
              n[idxS(x,y)] = keep;
            }
          }
          c = n;
        }
        if (shapeMass(c) < 6){
          for (let i=0;i<SHAPE_C;i++) c[i] = 0;
          const mid = Math.floor(SHAPE_N/2);
          for (let x=1;x<SHAPE_N-1;x++) c[idxS(x,mid)] = 1;
          for (let y=1;y<SHAPE_N-1;y++) c[idxS(mid,y)] = 1;
        }
        return c;
      }

      function growShapeCells(cells, intensity=1){
        const out = cloneCells(cells);
        for (let k=0;k<intensity;k++){
          const ones = [];
          for (let i=0;i<SHAPE_C;i++) if (out[i]) ones.push(i);
          if (!ones.length) break;
          const pick = ones[Math.floor(Math.random()*ones.length)];
          const x = pick % SHAPE_N;
          const y = Math.floor(pick / SHAPE_N);
          const dirs = [
            [1,0],[-1,0],[0,1],[0,-1],
            [1,1],[1,-1],[-1,1],[-1,-1]
          ];
          const [dx,dy] = dirs[Math.floor(Math.random()*dirs.length)];
          const xx = x+dx, yy=y+dy;
          if (xx>=0 && xx<SHAPE_N && yy>=0 && yy<SHAPE_N){
            out[idxS(xx,yy)] = 1;
          }
        }
        return out;
      }

      // Match:
      // - fill = key hits hole
      // - spill = key hits NOT-hole (side effects)
      function matchKeyVoid(keyCells, voidCells){
        let fill = 0, spill = 0, voidMass = 0;
        for (let i=0;i<SHAPE_C;i++){
          const v = voidCells[i];
          const k = keyCells[i];
          if (v) voidMass++;
          if (k){
            if (v) fill++;
            else spill++;
          }
        }
        const score = (fill - 1.25*spill) / (voidMass + 1e-6);
        const good = clamp01((score + 1) / 2);
        const bad = clamp01((-score));
        return { fill, spill, voidMass, score, good, bad };
      }

      function initShapes(){
        SHAPES.length = 0;
        COMMON_SHAPE_IDS.length = 0;

        function blank(){ return new Array(SHAPE_C).fill(0); }
        function set(c,x,y){ if (x>=0&&x<SHAPE_N&&y>=0&&y<SHAPE_N) c[idxS(x,y)] = 1; }
        const mid = Math.floor(SHAPE_N/2);

        // Common keys
        {
          const c = blank();
          for (let x=1;x<SHAPE_N-1;x++) set(c,x,mid);
          for (let y=1;y<SHAPE_N-1;y++) set(c,mid,y);
          COMMON_SHAPE_IDS.push(addShape("plus", c));
        }
        {
          const c = blank();
          for (let x=1;x<SHAPE_N-1;x++) set(c,x,mid);
          set(c,mid,mid-1); set(c,mid,mid+1);
          COMMON_SHAPE_IDS.push(addShape("bar-h", c));
        }
        {
          const c = blank();
          for (let y=1;y<SHAPE_N-1;y++) set(c,mid,y);
          set(c,mid-1,mid); set(c,mid+1,mid);
          COMMON_SHAPE_IDS.push(addShape("bar-v", c));
        }
        {
          const c = blank();
          for (let y=1;y<SHAPE_N-1;y++) set(c,1,y);
          for (let x=1;x<SHAPE_N-1;x++) set(c,x,SHAPE_N-2);
          COMMON_SHAPE_IDS.push(addShape("L", c));
        }
        {
          const c = blank();
          for (let i=1;i<SHAPE_N-1;i++) set(c,i,i);
          set(c,mid,mid-1); set(c,mid-1,mid);
          COMMON_SHAPE_IDS.push(addShape("diag", c));
        }
        {
          const c = blank();
          for (let x=1;x<SHAPE_N-1;x++){ set(c,x,1); set(c,x,SHAPE_N-2); }
          for (let y=1;y<SHAPE_N-1;y++){ set(c,1,y); set(c,SHAPE_N-2,y); }
          COMMON_SHAPE_IDS.push(addShape("ring", c));
        }
        {
          const c = blank();
          for (let y=2;y<=4;y++){
            for (let x=2;x<=4;x++) set(c,x,y);
          }
          set(c,1,3); set(c,5,3); set(c,3,1); set(c,3,5);
          COMMON_SHAPE_IDS.push(addShape("blob", c));
        }

        // some random extras (can become rare locks)
        for (let i=0;i<8;i++){
          const r = randomShape(0.22 + 0.05*Math.random(), 2);
          const id = SHAPES.length;
          SHAPES.push({ name:"rand"+id, cells: r, mass: shapeMass(r) });
        }
      }

      // ===== Presets (Oi/Oe/Di/De) =====
      const PRESETS = {
        Oi:   { label: "Oi (▼)",  Oi:  2.0, Oe: -2.0, De:  0.0, Di:  0.0, glyph:"triangleDown" },
        Oe:   { label: "Oe (✦)",  Oi: -2.0, Oe:  2.0, De:  0.0, Di:  0.0, glyph:"star" },
        De:   { label: "De (+)",  Oi:  0.0, Oe:  0.0, De:  2.0, Di: -2.0, glyph:"plus" },
        Di:   { label: "Di (×)",  Oi:  0.0, Oe:  0.0, De: -2.0, Di:  2.0, glyph:"cross" },

        DiOi: { label: "DiOi",    Di:  1.0, De: -1.0, Oi:  0.3, Oe: -0.2, glyph:"star" },
        DiOe: { label: "DiOe",    Di:  1.0, De: -1.0, Oe:  0.3, Oi: -0.2, glyph:"triangle" },
        DeOi: { label: "DeOi",    Di: -1.0, De:  1.0, Oi:  0.3, Oe: -0.2, glyph:"cross" },
        DeOe: { label: "DeOe",    Di: -1.0, De:  1.0, Oe:  0.3, Oi: -0.2, glyph:"diamond" },

        OiDi: { label: "OiDi",    Oi:  1.0, Oe: -1.0, Di:  0.3, De: -0.2, glyph:"plus" },
        OiDe: { label: "OiDe",    Oi:  1.0, Oe: -1.0, De:  0.3, Di: -0.2, glyph:"triangleDown" },
        OeDi: { label: "OeDi",    Oi: -1.0, Oe:  1.0, De:  0.3, Di: -0.2, glyph:"circle" },
        OeDe: { label: "OeDe",    Oi: -1.0, Oe:  1.0, De:  0.3, Di: -0.2, glyph:"square" },
      };
      const PRESET_ORDER = ["Oi","Oe","De","Di","DiOi","DiOe","DeOi","DeOe","OiDi","OiDe","OeDi","OeDe"];
      const SPAWNER_PRESETS = [...PRESET_ORDER];
      const ALL_PRESETS = PRESET_ORDER;

      // ===== Agent cognition: energy + keys + needs =====
      function initKeys(agent){
        agent.keys = [];

        const teLike = sigmoid((agent.De - agent.Di) * 0.9);
        const tiLike = 1 - teLike;

        const nCommon = 3 + Math.floor(4 * teLike);  // 3..7
        const nRare   = 1 + Math.floor(2 * tiLike);  // 1..3

        for (let i=0;i<nCommon;i++){
          const sid = COMMON_SHAPE_IDS[Math.floor(Math.random()*COMMON_SHAPE_IDS.length)];
          agent.keys.push({ shapeId: sid, rare: 0 });
        }
        for (let i=0;i<nRare;i++){
          const rc = randomShape(0.20 + 0.08*Math.random(), 2);
          const rid = SHAPES.length;
          SHAPES.push({ name:"rareKey"+rid, cells: rc, mass: shapeMass(rc) });
          agent.keys.push({ shapeId: rid, rare: 1 });
        }
      }

      function normalize4(a0,a1,a2,a3){
        const s = a0+a1+a2+a3 + 1e-9;
        return [a0/s, a1/s, a2/s, a3/s];
      }

      function initAgentCognition(a){
        // Energy storage (Ti-ish)
        const tiLike = sigmoid((a.Di - a.De) * 0.9);
        a.maxEnergy = 0.85 + 0.85 * tiLike;
        a.energy = a.maxEnergy * (0.55 + 0.35*Math.random());

        // Internal needs bias derived from functions:
        // - Oi ~ Safety (certainty/order)
        // - Oe ~ Stimulation (novelty)
        // - De ~ Connection (people / coordination)
        // - Di ~ Mastery (internal model / mastery)
        const bSafety = 0.35 + 0.75 * sigmoid((a.Oi - a.Oe) * 0.9);
        const bStim   = 0.35 + 0.75 * sigmoid((a.Oe - a.Oi) * 0.9);
        const bConn   = 0.35 + 0.75 * sigmoid((a.De - a.Di) * 0.9);
        const bMast   = 0.35 + 0.75 * sigmoid((a.Di - a.De) * 0.9);
        const nb = normalize4(bSafety,bConn,bStim,bMast);
        a.needBias = nb; // weights sum to 1

        // Need levels
        a.needs = new Float32Array(4);
        for (let i=0;i<4;i++){
          a.needs[i] = 0.55 + 0.35*Math.random();
        }

        // Which need is currently "the loudest internal void"
        a.activeNeed = N_SAFETY;

        // Research state (adaptive cognition)
        a.research = { voidId: -1, keyCells: null, score: -1e9, steps: 0 };

        // entropy-like cognitive load (combined external+internal)
        a.entropy = 0.5;

        a.lastBroadcastAt = -1e9;

        initKeys(a);
      }

      function applyAgentPreset(a, name){
        const p = PRESETS[name] ?? {Oi:0,Oe:0,De:0,Di:0};
        a.Oi = p.Oi ?? 0;
        a.Oe = p.Oe ?? 0;
        a.De = p.De ?? 0;
        a.Di = p.Di ?? 0;
        a.glyph = p.glyph ?? "circle";
        a.preset = name ?? "balanced";
        initAgentCognition(a);
      }

      function addAgentAt(u, v, presetName){
        const resolvedPreset = presetName ?? ALL_PRESETS[Math.floor(Math.random()*ALL_PRESETS.length)];
        const a = {
          x:u, y:v, x_prev:u, y_prev:v,
          px:u, py:v, // unwrapped

          dispDxTask:0, dispDyTask:0,
          dispDxMean:0, dispDyMean:0,

          localMeanX:u, localMeanY:v,

          glyph:"circle", preset:"balanced",
          Oi:1, Oe:1, De:0.5, Di:0.5,
          id: Math.random().toString(36).slice(2),
        };
        applyAgentPreset(a, resolvedPreset);
        agents.push(a);
        selectedIdx = agents.length - 1;
        updateSelectionUI();
      }

      function resetAgents(n){
        agents = [];
        for (let i=0;i<n;i++) addAgentAt(Math.random(), Math.random());
        trailsLayer.clear();
        selectedIdx = -1;
        updateSelectionUI();

        voids = [];
        signals = [];
        nextVoidId = 1;
      }

      function adjustAgentCount(n){
        const cur = agents.length;
        if (n > cur){
          for (let i=cur;i<n;i++) addAgentAt(Math.random(), Math.random(), UI.agentSpawnPreset.value);
        } else {
          agents.length = n;
        }
        if (selectedIdx >= agents.length) selectedIdx = -1;
        updateSelectionUI();
      }

      // ===== Social mean =====
      function computeLocalMean(a, radius){
        if (!agents.length) return {mx:0.5,my:0.5,mxPhase:0.5,myPhase:0.5};

        let sx=0, sy=0, n=0;
        for (const b of agents){
          const dx = wrapDelta(b.x - a.x);
          const dy = wrapDelta(b.y - a.y);
          const d = Math.hypot(dx,dy);
          if (d <= radius){
            const pxAdj = a.px + wrapDeltaPhase(b.px - a.px);
            const pyAdj = a.py + wrapDeltaPhase(b.py - a.py);
            sx += pxAdj; sy += pyAdj; n++;
          }
        }
        if (!n) return {mx:frac01(a.px), my:frac01(a.py), mxPhase:a.px, myPhase:a.py};
        const mxPhase = sx/n, myPhase = sy/n;
        return {mx:frac01(mxPhase), my:frac01(myPhase), mxPhase, myPhase};
      }

      function computeGroupMean(){
        if (!agents.length) return {mx:0.5,my:0.5,mxPhase:0.5,myPhase:0.5};
        const ref = agents[0];
        let sx = ref.px, sy = ref.py, n = 1;
        for (let i=1;i<agents.length;i++){
          const b = agents[i];
          const pxAdj = ref.px + wrapDeltaPhase(b.px - ref.px);
          const pyAdj = ref.py + wrapDeltaPhase(b.py - ref.py);
          sx += pxAdj; sy += pyAdj; n++;
        }
        const mxPhase = sx/n, myPhase = sy/n;
        return {mx:frac01(mxPhase), my:frac01(myPhase), mxPhase, myPhase};
      }

      // ===== External voids (collective locks) =====
      function pickVoidShape(isBig, rarity){
        if (!isBig && rarity < 0.45){
          return COMMON_SHAPE_IDS[Math.floor(Math.random()*COMMON_SHAPE_IDS.length)];
        }
        if (Math.random() < 0.55 && SHAPES.length > COMMON_SHAPE_IDS.length + 1){
          const start = COMMON_SHAPE_IDS.length;
          const id = Math.floor(start + Math.random()*(SHAPES.length - start));
          return Math.max(0, Math.min(SHAPES.length-1, id));
        } else {
          const rc = randomShape(0.20 + 0.10*Math.random(), 2);
          const rid = SHAPES.length;
          SHAPES.push({ name:"rareVoid"+rid, cells: rc, mass: shapeMass(rc) });
          return rid;
        }
      }

      function voidTypeColor(t){
        // Safety=red, Connection=orange, Stimulation=purple, Mastery=cyan
        if (t===N_SAFETY) return [255, 90, 90];
        if (t===N_CONN)   return [255, 170, 90];
        if (t===N_STIM)   return [200, 120, 255];
        return [120, 220, 255];
      }

      function spawnVoid(isBig=false){
        const maxV = parseInt(UI.sVoidMax.value);
        if (voids.length >= maxV) return;

        const x = Math.random(), y = Math.random();

        // pick type:
        // - big disasters skew Safety strongly
        // - otherwise mixed
        let vType;
        if (isBig){
          vType = N_SAFETY;
        } else {
          const r = Math.random();
          vType = (r < 0.40) ? N_SAFETY : (r < 0.62) ? N_CONN : (r < 0.82) ? N_STIM : N_MAST;
        }

        const bigBoost = isBig ? 0.35 : 0.0;
        const rarity = clamp01(Math.random()*Math.random() + bigBoost);

        const shapeIdA = pickVoidShape(isBig, rarity);
        let cells = cloneCells(SHAPES[shapeIdA].cells);

        if (isBig && Math.random() < 0.6){
          const shapeIdB = pickVoidShape(true, 0.9);
          cells = shapeOR(cells, SHAPES[shapeIdB].cells);
        }

        const baseR = isBig ? 0.090 : 0.034;
        const r0 = baseR * (0.8 + 0.9*Math.random());

        const initialMass = Math.max(6, shapeMass(cells));
        const sev0 = isBig ? (0.60 + 0.35*Math.random()) : (0.10 + 0.30*Math.random());

        // complexity increases "work required" and role constraints
        const complexity = isBig ? (2 + (Math.random()<0.5 ? 1 : 0)) : (1 + (Math.random()<0.25 ? 1 : 0));
        const requiresTi = (rarity > 0.65 && complexity >= 2);        // rare locks want a Ti-like "rare key holder"
        const requiresTe = (isBig || (complexity >= 2 && vType === N_CONN)); // coordination-heavy locks want a Te-like

        // some voids start "effectively unsolved": no one has a good key yet
        // (not truly impossible — Mastery can evolve keys)
        const initiallyHard = (rarity > 0.70 && Math.random() < 0.45);

        const collective = parseFloat(UI.sCollect.value);
        const workRequired = collective * (0.65 + 0.55*complexity) * (0.8 + 0.8*initialMass/14);

        voids.push({
          id: nextVoidId++,
          x, y,
          r: r0,
          type: vType,
          rarity,
          complexity,
          requiresTi,
          requiresTe,
          initiallyHard,

          cells,
          initialMass,
          mass: initialMass,
          sev: clamp01(sev0),

          workDone: 0,
          age: 0,
        });
      }

      function growVoid(v, dt){
        const g = parseFloat(UI.sVoidGrow.value);
        const p = g * dt * (0.6 + 0.8*v.rarity) * (0.35 + 0.65*v.sev);
        if (Math.random() < p){
          const intensity = 1 + (v.sev > 0.7 ? 1 : 0);
          v.cells = growShapeCells(v.cells, intensity);
          v.mass = shapeMass(v.cells);
          v.sev = clamp01(0.2 + 0.8*(v.mass / (v.initialMass+1e-6)));
        }
      }

      // ===== Signals =====
      function broadcastNeed(agent, v, nowSec){
        const teLike = sigmoid((agent.De - agent.Di) * 0.9);
        const cooldown = 0.8 + 2.0*(1 - teLike);
        if (nowSec - agent.lastBroadcastAt < cooldown) return;

        const sigR = parseFloat(UI.sSigR.value);
        signals.push({
          x: v.x, y: v.y,
          cells: v.cells,
          type: v.type,
          rarity: v.rarity,
          sev: v.sev,
          t: 0,
          range: sigR,
          from: agent.id,
        });
        agent.lastBroadcastAt = nowSec;
      }

      function updateWorld(dt){
        const ratePerMin = parseFloat(UI.sVoidRate.value);
        const ratePerSec = ratePerMin / 60.0;
        const bigChance = parseFloat(UI.sVoidBig.value);

        if (Math.random() < ratePerSec * dt) spawnVoid(false);
        if (Math.random() < bigChance * dt) spawnVoid(true);

        for (const v of voids){
          v.age += dt;
          growVoid(v, dt);
        }

        const maxV = parseInt(UI.sVoidMax.value);
        if (voids.length > maxV) voids.length = maxV;

        const ttl = parseFloat(UI.sSigTTL.value);
        for (const s of signals) s.t += dt;
        signals = signals.filter(s => s.t < ttl);
      }

      // ===== Key selection =====
      function bestKeyForVoid(agent, v){
        let best = null;
        for (const k of agent.keys){
          const keyCells = SHAPES[k.shapeId]?.cells;
          if (!keyCells) continue;
          const m = matchKeyVoid(keyCells, v.cells);
          if (!best || m.score > best.m.score) best = { key:k, m, keyCells };
        }
        if (!best){
          const sid = COMMON_SHAPE_IDS[0] ?? 0;
          const keyCells = SHAPES[sid].cells;
          best = { key:{shapeId:sid, rare:0}, m: matchKeyVoid(keyCells, v.cells), keyCells };
        }
        return best;
      }

      function bestKeyForSignal(agent, s){
        let best = null;
        for (const k of agent.keys){
          const keyCells = SHAPES[k.shapeId]?.cells;
          if (!keyCells) continue;
          const m = matchKeyVoid(keyCells, s.cells);
          if (!best || m.score > best.m.score) best = { key:k, m, keyCells };
        }
        return best;
      }

      // ===== Adaptive cognition (Mastery research: evolve a key) =====
      function mutateKeyCells(cells, flips=2){
        const out = cloneCells(cells);
        for (let i=0;i<flips;i++){
          const idx = Math.floor(Math.random()*SHAPE_C);
          out[idx] = out[idx] ? 0 : 1;
        }
        return out;
      }

      function researchStep(agent, v, baseKeyCells){
        // Keep a per-void research track; if void changes, reset.
        if (agent.research.voidId !== v.id){
          agent.research.voidId = v.id;
          agent.research.keyCells = cloneCells(baseKeyCells);
          agent.research.score = matchKeyVoid(agent.research.keyCells, v.cells).score;
          agent.research.steps = 0;
        }

        // propose a mutation and accept if improved (simple hill-climb)
        const flips = (v.complexity >= 2) ? 2 : 1;
        const cand = mutateKeyCells(agent.research.keyCells, flips);
        const s0 = agent.research.score;
        const s1 = matchKeyVoid(cand, v.cells).score;

        agent.research.steps++;

        // accept improvements, or rarely accept a worse step (to escape local minima)
        const accept = (s1 > s0) || (Math.random() < 0.02);
        if (accept){
          agent.research.keyCells = cand;
          agent.research.score = s1;
        }

        // if very good, store as learned key
        if (agent.research.score > 0.85 && agent.research.steps > 18){
          const sid = SHAPES.length;
          SHAPES.push({ name:"learnedKey"+sid, cells: cloneCells(agent.research.keyCells), mass: shapeMass(agent.research.keyCells) });
          agent.keys.push({ shapeId: sid, rare: 1 });

          // mark this void as no longer "initiallyHard"
          v.initiallyHard = false;

          // reset research so agent can focus next
          agent.research.voidId = -1;
          agent.research.keyCells = null;
          agent.research.score = -1e9;
          agent.research.steps = 0;

          return true;
        }
        return false;
      }

      // ===== Needs dynamics =====
      function updateNeeds(agent, h){
        if (!UI.chkInternal.checked) return;

        const decay = parseFloat(UI.sNeedDecay.value);
        const fill = parseFloat(UI.sNeedFill.value);

        // decay: demon needs drain faster (low bias -> faster drain)
        for (let i=0;i<4;i++){
          const b = agent.needBias[i];
          const drain = decay * (0.65 + 0.9*(1-b)); // bias reduces drain
          agent.needs[i] = clamp01(agent.needs[i] - drain*h);
        }

        // choose active need based on deficit * bias (the internal void that feels loudest)
        // target is ~0.70: below that, the need starts pulling behavior.
        const target = 0.70;
        let bestI = 0;
        let bestScore = -1;
        for (let i=0;i<4;i++){
          const deficit = Math.max(0, target - agent.needs[i]);
          const score = deficit * (0.55 + 1.1*agent.needBias[i]);
          if (score > bestScore){
            bestScore = score;
            bestI = i;
          }
        }
        agent.activeNeed = bestI;

        // small passive refill to avoid total collapse (like "baseline life")
        for (let i=0;i<4;i++){
          agent.needs[i] = clamp01(agent.needs[i] + 0.015*fill*h);
        }
      }

      function refillNeed(agent, needIdx, amount){
        agent.needs[needIdx] = clamp01(agent.needs[needIdx] + amount);
      }

      // ===== Discomfort / cognitive load =====
      function agentDiscomfort(a){
        // internal mismatch: how far needs are from ~0.70, weighted by bias
        let internal = 0;
        const target = 0.70;
        for (let i=0;i<4;i++){
          const d = Math.max(0, target - a.needs[i]);
          internal += d * (0.5 + a.needBias[i]);
        }
        internal = clamp01(internal / 2.2);

        const lowEnergy = clamp01(1 - a.energy/(a.maxEnergy+1e-6));
        const external = clamp01(a.entropy); // already 0..1ish

        return clamp01(0.45*external + 0.35*internal + 0.20*lowEnergy);
      }

      // ===== Dynamics =====
      function stepAgents(h){
        const stabilityFactor = parseFloat(UI.sStability.value);
        const meanRadius = parseFloat(UI.sMeanRadius.value);
        const nowSec = millis()/1000;

        const workRate = parseFloat(UI.sWorkRate.value);
        const emergThr  = parseFloat(UI.sEmerg.value);

        const MOVE_GAIN   = 2.7;
        const AVOID_GAIN  = 2.1;
        const SOCIAL_GAIN = 1.25;
        const maxStep = 0.1;

        const ARROW_SMOOTH = 0.86;

        // Track "who is near which void" for role checks
        // We'll recompute per void, per step (N is small enough).
        function rolePresence(v){
          let hasTi = false, hasTe = false, contributors = 0;
          for (const a of agents){
            const tv = torusVec(a.x, a.y, v.x, v.y);
            if (tv.d < v.r * 1.08){
              contributors++;
              const teLike = sigmoid((a.De - a.Di) * 0.9);
              const tiLike = 1 - teLike;
              if (tiLike > 0.60) hasTi = true;
              if (teLike > 0.60) hasTe = true;
            }
          }
          return { hasTi, hasTe, contributors };
        }

        for (const a of agents){
          a.x_prev = a.x; a.y_prev = a.y;

          // Needs and energy
          updateNeeds(a, h);

          const tiLike = sigmoid((a.Di - a.De) * 0.9);
          const regen = (0.05 + 0.11*tiLike) * h;
          a.energy = Math.min(a.maxEnergy, a.energy + regen);

          // perception range
          const sight = 0.10 + 0.28 * sigmoid((a.Oe - a.Oi) * 0.9);

          // local mean
          const GM = computeLocalMean(a, meanRadius);
          a.localMeanX = GM.mx;
          a.localMeanY = GM.my;

          // external load from nearby voids
          let extLoad = 0;

          // best options
          let emergencyV = null;
          let bestV = null;
          let bestSolveScore = -1e9;

          for (const v of voids){
            const tv = torusVec(a.x, a.y, v.x, v.y);
            if (tv.d > sight) continue;

            const bm = bestKeyForVoid(a, v);
            const solv = bm.m.good;

            // if "initiallyHard", act like solvability is suppressed until learned
            const effSolv = v.initiallyHard ? Math.min(0.35, solv) : solv;

            const perceived = v.sev * (1 - tv.d/sight) * (0.65 + 0.7*v.complexity/3);
            extLoad += perceived;

            if (v.sev >= emergThr){
              if (!emergencyV || v.sev > emergencyV.sev) emergencyV = v;
            }

            // prefer voids aligned with current need
            const aligned = (v.type === a.activeNeed) ? 1.0 : 0.55;

            // also value solvability, proximity, and severity
            const energyOk = clamp01(a.energy/(a.maxEnergy+1e-6));
            const score = aligned * perceived * effSolv * energyOk / (0.05 + tv.d);

            if (score > bestSolveScore){
              bestSolveScore = score;
              bestV = v;
            }

            // De-ish: broadcast if it's notable and agent can't solve it well
            if (a.De > a.Di && perceived > 0.12 && effSolv < 0.40){
              broadcastNeed(a, v, nowSec);
            }
          }

          extLoad = clamp01(extLoad);

          // internal load from needs deficits
          let intLoad = 0;
          if (UI.chkInternal.checked){
            const target = 0.70;
            for (let i=0;i<4;i++){
              intLoad += Math.max(0, target - a.needs[i]) * (0.6 + a.needBias[i]);
            }
            intLoad = clamp01(intLoad / 2.0);
          }

          // cognitive load / entropy blends internal + external
          const load = clamp01(0.60*extLoad + 0.40*intLoad);
          a.entropy = 0.86*a.entropy + 0.14*load;

          // Movement decision
          let gx = 0, gy = 0;
          let mode = "wander";

          if (emergencyV){
            const tv = torusVec(a.x, a.y, emergencyV.x, emergencyV.y);
            const d = tv.d || 1e-6;
            gx = tv.dx/d; gy = tv.dy/d;
            mode = "emergency";
          } else {
            // If overloaded, avoid void-dense area
            if (a.entropy > 0.78){
              let cx=0, cy=0, wsum=0;
              for (const v of voids){
                const tv = torusVec(a.x, a.y, v.x, v.y);
                if (tv.d > sight) continue;
                const w = v.sev * (1 - tv.d/sight);
                cx += tv.dx * w;
                cy += tv.dy * w;
                wsum += w;
              }
              if (wsum > 1e-6){
                const d = Math.hypot(cx,cy) || 1e-6;
                gx = -cx/d; gy = -cy/d;
                mode = "avoid";
              }
            }

            if (mode === "wander" && bestV){
              // Need-driven selection:
              // - Connection: move to people
              // - Stimulation: chase rare/novel signals if any; otherwise wander more
              // - Mastery: go to hard/complex locks
              // - Safety: go to best threat
              if (a.activeNeed === N_CONN){
                const dxm = wrapDeltaPhase(GM.mxPhase - a.px);
                const dym = wrapDeltaPhase(GM.myPhase - a.py);
                const d = Math.hypot(dxm, dym) || 1e-6;
                gx = dxm/d; gy = dym/d;
                mode = "connection";
              } else if (a.activeNeed === N_STIM){
                // seek "interesting" voids (rarer) to raise stimulation
                let bestR = null;
                let bestRScore = -1e9;
                for (const v of voids){
                  const tv = torusVec(a.x, a.y, v.x, v.y);
                  if (tv.d > sight) continue;
                  const sc = v.rarity * (0.7 + 0.6*v.sev) / (0.06 + tv.d);
                  if (sc > bestRScore){ bestRScore=sc; bestR=v; }
                }
                if (bestR){
                  const tv = torusVec(a.x, a.y, bestR.x, bestR.y);
                  const d = tv.d || 1e-6;
                  gx = tv.dx/d; gy = tv.dy/d;
                  mode = "stim";
                } else {
                  const ang = Math.random()*Math.PI*2;
                  gx = Math.cos(ang); gy = Math.sin(ang);
                  mode = "stim-wander";
                }
              } else if (a.activeNeed === N_MAST){
                // seek the hardest/most complex lock nearby
                let hard = null;
                let hardScore = -1e9;
                for (const v of voids){
                  const tv = torusVec(a.x, a.y, v.x, v.y);
                  if (tv.d > sight) continue;
                  const sc = (0.6*v.rarity + 0.4*v.complexity/3) * (0.7 + 0.5*v.sev) / (0.06 + tv.d);
                  if (sc > hardScore){ hardScore=sc; hard=v; }
                }
                if (hard){
                  const tv = torusVec(a.x, a.y, hard.x, hard.y);
                  const d = tv.d || 1e-6;
                  gx = tv.dx/d; gy = tv.dy/d;
                  mode = "mastery";
                } else {
                  const tv = torusVec(a.x, a.y, bestV.x, bestV.y);
                  const d = tv.d || 1e-6;
                  gx = tv.dx/d; gy = tv.dy/d;
                  mode = "solve";
                }
              } else {
                // Safety default: go solve best void
                const tv = torusVec(a.x, a.y, bestV.x, bestV.y);
                const d = tv.d || 1e-6;
                gx = tv.dx/d; gy = tv.dy/d;
                mode = "solve";
              }
            }
          }

          // Social pull: De clusters, Di separates
          const dxMean = wrapDeltaPhase(GM.mxPhase - a.px);
          const dyMean = wrapDeltaPhase(GM.myPhase - a.py);
          const socialK = (a.De - a.Di);

          // Noise exploration: Oe likes it
          const noiseAmp = 0.11 * sigmoid((a.Oe - a.Oi) * 0.9);
          const fxNoise = noiseAmp*randn();
          const fyNoise = noiseAmp*randn();

          const fxTask = ((mode==="avoid") ? AVOID_GAIN : MOVE_GAIN) * gx + fxNoise;
          const fyTask = ((mode==="avoid") ? AVOID_GAIN : MOVE_GAIN) * gy + fyNoise;

          const fxMean = SOCIAL_GAIN * socialK * dxMean;
          const fyMean = SOCIAL_GAIN * socialK * dyMean;

          let dx = (fxTask + fxMean) * h * stabilityFactor;
          let dy = (fyTask + fyMean) * h * stabilityFactor;

          const stepMag = Math.hypot(dx,dy);
          if (stepMag > maxStep){
            const s = maxStep/stepMag;
            dx *= s; dy *= s;
          }

          a.dispDxTask = ARROW_SMOOTH*a.dispDxTask + (1-ARROW_SMOOTH)*(fxTask*h*stabilityFactor);
          a.dispDyTask = ARROW_SMOOTH*a.dispDyTask + (1-ARROW_SMOOTH)*(fyTask*h*stabilityFactor);
          a.dispDxMean = ARROW_SMOOTH*a.dispDxMean + (1-ARROW_SMOOTH)*(fxMean*h*stabilityFactor);
          a.dispDyMean = ARROW_SMOOTH*a.dispDyMean + (1-ARROW_SMOOTH)*(fyMean*h*stabilityFactor);

          a.x = wrap01(a.x + dx);
          a.y = wrap01(a.y + dy);
          a.px += wrapDelta(a.x - a.x_prev);
          a.py += wrapDelta(a.y - a.y_prev);

          // ===== Interactions: void work + learning + needs refill =====
          // Connection refill: if close to mean and not alone
          if (UI.chkInternal.checked){
            const fill = parseFloat(UI.sNeedFill.value);
            const nearMean = Math.hypot(dxMean, dyMean) < 0.06;
            if (nearMean){
              // count local neighbors roughly
              let neigh = 0;
              for (const b of agents){
                if (b === a) continue;
                const tv = torusVec(a.x, a.y, b.x, b.y);
                if (tv.d < meanRadius*0.55) neigh++;
              }
              if (neigh >= 2) refillNeed(a, N_CONN, fill * 0.11 * h);
            }
            // Stimulation refill: moving + randomness
            const moveMag = Math.hypot(dx,dy);
            refillNeed(a, N_STIM, fill * 0.04 * h * (0.5 + 2.0*moveMag));
          }

          // Work on nearby voids (collective)
          if (bestV && a.energy > 0.02){
            const tv = torusVec(a.x, a.y, bestV.x, bestV.y);
            if (tv.d < bestV.r * 1.02){
              const bm = bestKeyForVoid(a, bestV);
              const m = bm.m;

              // if initiallyHard, suppress effective goodness until learned
              const effGood = bestV.initiallyHard ? Math.min(0.32, m.good) : m.good;

              // role factor: you can do it off-need, but slower
              let roleFactor = (bestV.type === a.activeNeed) ? 1.0 : 0.45;
              if (bestV.sev >= emergThr) roleFactor = 1.0; // emergencies force everyone

              const energyOk = clamp01(a.energy/(a.maxEnergy+1e-6));

              // contribution to work pool
              let contrib = workRate * h * roleFactor * (0.18 + 0.95*effGood) * (0.25 + 0.75*energyOk);

              // penalize mismatch / spill
              contrib *= (0.75 + 0.25*(1 - m.bad));

              // collective role constraints: cap progress if required roles absent
              const pres = rolePresence(bestV);
              if (bestV.requiresTi && !pres.hasTi) bestV.workDone = Math.min(bestV.workDone, 0.92*bestV.workRequired);
              if (bestV.requiresTe && !pres.hasTe) bestV.workDone = Math.min(bestV.workDone, 0.92*bestV.workRequired);

              // grow work
              bestV.workDone += contrib;

              // visually shrink lock pattern a bit, proportional to contribution
              if (m.fill > 0){
                const pRemove = clamp01(contrib * 14.0);
                const newCells = cloneCells(bestV.cells);
                let removed = 0;
                for (let i=0;i<SHAPE_C;i++){
                  if (bestV.cells[i] && bm.keyCells[i]){
                    if (Math.random() < pRemove){
                      newCells[i] = 0;
                      removed++;
                    }
                  }
                }
                bestV.cells = newCells;
                bestV.mass = shapeMass(bestV.cells);
                bestV.sev = clamp01(0.2 + 0.8*(bestV.mass/(bestV.initialMass+1e-6)));
              }

              // energy cost: doing demon work drains more
              // - Te-ish drains more on rare locks
              // - Ti-ish drains more on common locks
              const teLike = sigmoid((a.De - a.Di) * 0.9);
              const demonMult = (bestV.rarity < 0.45) ? (1.0 + 0.8*(1-teLike)) : (1.0 + 0.8*teLike);
              const offNeed = (bestV.type === a.activeNeed) ? 1.0 : 1.35;
              const cost = (0.06 + 0.32*(1-effGood) + 0.18*m.bad) * demonMult * offNeed * (contrib*30.0);
              a.energy = Math.max(0, a.energy - cost);

              // Needs refill from action
              if (UI.chkInternal.checked){
                const fill = parseFloat(UI.sNeedFill.value);
                if (bestV.type === N_SAFETY) refillNeed(a, N_SAFETY, fill * 0.18 * contrib * 14.0);
                if (bestV.type === N_CONN)   refillNeed(a, N_CONN,   fill * 0.12 * contrib * 14.0);
                if (bestV.type === N_STIM)   refillNeed(a, N_STIM,   fill * 0.08 * contrib * 14.0);
                if (bestV.type === N_MAST)   refillNeed(a, N_MAST,   fill * 0.10 * contrib * 14.0);
              }

              // Mastery learning trigger: if can't solve well, try research
              if (UI.chkInternal.checked && a.activeNeed === N_MAST){
                if ((bestV.initiallyHard || effGood < 0.55) && bestV.complexity >= 2){
                  // spend a bit of energy to research
                  if (a.energy > 0.08){
                    const learned = researchStep(a, bestV, bm.keyCells);
                    a.energy = Math.max(0, a.energy - 0.012); // thinking cost
                    if (learned && UI.chkInternal.checked){
                      const fill = parseFloat(UI.sNeedFill.value);
                      refillNeed(a, N_MAST, fill * 0.18);
                    }
                  }
                }
              }

              // Finish check (work pool + shape mass)
              // - Either work pool is done OR shape is basically gone.
              // - But role constraints can block the last step.
              const pres2 = rolePresence(bestV);
              const rolesOk = (!bestV.requiresTi || pres2.hasTi) && (!bestV.requiresTe || pres2.hasTe);

              const solvedByWork = bestV.workDone >= bestV.workRequired;
              const solvedByShape = bestV.mass <= 1;

              if (rolesOk && (solvedByWork || solvedByShape)){
                // De-ish broadcasts "solution exists"
                if (a.De > a.Di) broadcastNeed(a, bestV, nowSec);

                // If Ti-ish and rare lock, store learned key sometimes (memory)
                if (bestV.rarity > 0.60 && (1-teLike) > 0.55){
                  const sid = SHAPES.length;
                  SHAPES.push({ name:"postSolveKey"+sid, cells: cloneCells(bm.keyCells), mass: shapeMass(bm.keyCells) });
                  a.keys.push({ shapeId: sid, rare: 1 });
                }

                voids = voids.filter(vv => vv.id !== bestV.id);
              } else if (!rolesOk) {
                // if blocked by roles, nudges Connection need: "need help"
                if (UI.chkInternal.checked){
                  const fill = parseFloat(UI.sNeedFill.value);
                  refillNeed(a, N_CONN, -fill * 0.02 * h); // tiny frustration
                }
              }
            }
          }

          // ===== Trails =====
          if (UI.chkTrails.checked){
            trailsLayer.noStroke();
            trailsLayer.fill(240,240,255,40);
            trailsLayer.circle(a.x*canvasW, a.y*canvasH, 2.2);
          }
        }

        // collisions + trail fade
        const rNorm = COLLISION_PX / Math.min(canvasW, canvasH);
        collideAgents(rNorm, COLLISION_ITERS);

        if (UI.chkTrails.checked){
          trailsLayer.push();
          trailsLayer.erase(12,12);
          trailsLayer.rect(0,0,trailsLayer.width,trailsLayer.height);
          trailsLayer.noErase();
          trailsLayer.pop();
        }
      }

      // ===== Collisions =====
      function collideAgents(radiusNorm, iterations=2){
        if (agents.length <= 1) return;
        const cell = radiusNorm;
        const nx = Math.max(1, Math.ceil(1/cell));
        const ny = Math.max(1, Math.ceil(1/cell));
        const buckets = new Array(nx*ny);
        for (let i=0;i<buckets.length;i++) buckets[i] = [];

        for (let i=0;i<agents.length;i++){
          const a = agents[i];
          let cx = Math.floor(frac01(a.x)/cell);
          let cy = Math.floor(frac01(a.y)/cell);
          cx = Math.min(nx-1, Math.max(0,cx));
          cy = Math.min(ny-1, Math.max(0,cy));
          buckets[cy*nx + cx].push(i);
        }

        const neigh = [-1,0,1];
        for (let iter=0; iter<iterations; iter++){
          for (let cy=0; cy<ny; cy++){
            for (let cx=0; cx<nx; cx++){
              for (let oy of neigh){
                for (let ox of neigh){
                  const nxC = (cx+ox+nx)%nx;
                  const nyC = (cy+oy+ny)%ny;
                  const A = buckets[cy*nx+cx];
                  const B = buckets[nyC*nx+nxC];
                  if (A===B){
                    for (let u=0; u<A.length; u++){
                      for (let v=u+1; v<A.length; v++){
                        projectPair(A[u], A[v], radiusNorm);
                      }
                    }
                  } else {
                    for (let u=0; u<A.length; u++){
                      for (let v=0; v<B.length; v++){
                        projectPair(A[u], B[v], radiusNorm);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      function projectPair(i,j,r){
        const a = agents[i], b = agents[j];
        let dx = wrapDelta(a.x - b.x);
        let dy = wrapDelta(a.y - b.y);
        const d2 = dx*dx + dy*dy;
        const r2 = r*r;
        if (d2 >= r2 || d2 < 1e-12) return;
        const d = Math.sqrt(d2);
        const overlap = r - d;
        const k = (overlap/(d+1e-12))*0.5;
        const cx = dx*k, cy = dy*k;
        a.x = wrap01(a.x + cx);
        a.y = wrap01(a.y + cy);
        b.x = wrap01(b.x - cx);
        b.y = wrap01(b.y - cy);
        a.px += cx; a.py += cy;
        b.px -= cx; b.py -= cy;
      }

      // ===== Background field (visual only) =====
      function fbm3(x,y,t,octaves){
        let sum=0, amp=1, freq=1, norm=0;
        for (let o=0;o<octaves;o++){
          sum += amp * noise(x*freq, y*freq, t*freq);
          norm += amp;
          amp *= 0.5; freq *= 2.0;
        }
        return sum/norm;
      }

      function buildFieldAtTime(t){
        const freq = parseFloat(UI.sPerlinFreq.value);
        const oct  = parseInt(UI.sPerlinOct.value);
        const amp  = parseFloat(UI.sNoise.value);

        const windX = 0.18, windY = -0.12, timeScale = 0.25;

        noiseSeed(noiseSeedBase);
        minL = Infinity; maxL = -Infinity;

        let idx = 0;
        const tx = t*windX, ty = t*windY, tz = t*timeScale;

        for (let j=0;j<gh;j++){
          for (let i=0;i<gw;i++,idx++){
            const x = i/(gw-1);
            const y = j/(gh-1);
            const v = fbm3((x+tx)*freq, (y+ty)*freq, tz, oct);
            const val = amp*(v-0.5);
            L[idx] = val;
            if (val<minL) minL = val;
            if (val>maxL) maxL = val;
          }
        }
      }

      function hsv2rgb(h,s,v){
        const c=v*s, hh=h/60, x=c*(1-Math.abs((hh%2)-1));
        let r=0,g=0,b=0;
        if (0<=hh && hh<1){ r=c; g=x; b=0; }
        else if (1<=hh && hh<2){ r=x; g=c; b=0; }
        else if (2<=hh && hh<3){ r=0; g=c; b=x; }
        else if (3<=hh && hh<4){ r=0; g=x; b=c; }
        else if (4<=hh && hh<5){ r=x; g=0; b=c; }
        else { r=c; g=0; b=x; }
        const m=v-c;
        return [Math.round(255*(r+m)), Math.round(255*(g+m)), Math.round(255*(b+m))];
      }
      function colormapCool(t){
        t = Math.min(1, Math.max(0,t));
        const h = 240 - 200*t;
        return hsv2rgb(h, 1.0, 0.9);
      }

      function fieldToImage(){
        const inv = (maxL-minL)>1e-9 ? 1/(maxL-minL) : 1.0;
        const COLOR_CAP = 0.88, GAMMA = 0.95;
        gImg.loadPixels();
        for (let j=0;j<gh;j++){
          for (let i=0;i<gw;i++){
            const idx = j*gw + i;
            const tRaw = (L[idx]-minL)*inv;
            const t = Math.min(COLOR_CAP, Math.pow(tRaw, GAMMA));
            const c = colormapCool(t);
            const p = 4*idx;
            gImg.pixels[p+0]=c[0];
            gImg.pixels[p+1]=c[1];
            gImg.pixels[p+2]=c[2];
            gImg.pixels[p+3]=255;
          }
        }
        gImg.updatePixels();
      }

      // ===== Rendering =====
      function lerpWrap(a,b,t){
        let d = b-a;
        if (d>0.5) d-=1;
        if (d<-0.5) d+=1;
        let x = a + d*t;
        if (x<0) x+=1;
        if (x>=1) x-=1;
        return x;
      }

      function drawGlyph(type, px, py, size){
        push();
        translate(px,py);
        switch(type){
          case "triangle":{
            const r=size*0.62, h=r*Math.sqrt(3);
            triangle(0,-h/2,-r,h/2,r,h/2);
            break;
          }
          case "triangleDown":{
            const r=size*0.62, h=r*Math.sqrt(3);
            triangle(0,h/2,-r,-h/2,r,-h/2);
            break;
          }
          case "square":
            rectMode(CENTER); square(0,0,size,2); break;
          case "diamond":
            rotate(Math.PI/4); rectMode(CENTER); square(0,0,size,2); break;
          case "star":{
            beginShape();
            const points=5, outerR=size*0.6, innerR=size*0.28;
            for (let i=0;i<points*2;i++){
              const ang=(i*Math.PI)/points;
              const rr=(i%2===0)?outerR:innerR;
              vertex(Math.cos(ang)*rr, Math.sin(ang)*rr);
            }
            endShape(CLOSE);
            break;
          }
          case "plus":
            rectMode(CENTER);
            push(); rotate(0); rect(0,0,size*1.2,size*0.28,2); pop();
            push(); rotate(Math.PI/2); rect(0,0,size*1.2,size*0.28,2); pop();
            break;
          case "cross":
            rectMode(CENTER);
            push(); rotate(Math.PI/4); rect(0,0,size*1.2,size*0.28,2); pop();
            push(); rotate(-Math.PI/4); rect(0,0,size*1.2,size*0.28,2); pop();
            break;
          default:
            circle(0,0,size);
        }
        pop();
      }

      function drawForceArrow(px,py, dxNorm, dyNorm, colorRGB, alphaScale=1){
        const mag = Math.hypot(dxNorm||0, dyNorm||0);
        if (mag < 1e-6) return;
        const sx = dxNorm*canvasW;
        const sy = dyNorm*canvasH;
        const len = Math.hypot(sx,sy);
        const minLen = 10;
        const scale = len>1e-6 ? Math.max(1, minLen/len) : 1;
        const dx = sx*scale, dy = sy*scale;
        stroke(colorRGB[0],colorRGB[1],colorRGB[2], Math.min(255,220*alphaScale));
        strokeWeight(2.4);
        noFill();
        line(px,py, px+dx, py+dy);
      }

      function drawNeedsBars(a, px, py){
        if (!UI.chkNeeds.checked || !UI.chkInternal.checked) return;

        const w = 34, h = 4;
        const gap = 3;
        const ox = px - w/2;
        const oy = py - 28;

        const colors = [
          [255,90,90],
          [255,170,90],
          [200,120,255],
          [120,220,255],
        ];

        for (let i=0;i<4;i++){
          const v = clamp01(a.needs[i]);
          noStroke();
          fill(20,24,34,180);
          rect(ox, oy + i*(h+gap), w, h, 2);
          fill(colors[i][0], colors[i][1], colors[i][2], 220);
          rect(ox, oy + i*(h+gap), w*v, h, 2);
        }

        // active need marker
        noFill();
        stroke(255,255,255,150);
        strokeWeight(1);
        rect(ox-2, oy + a.activeNeed*(h+gap)-2, w+4, h+4, 3);
      }

      function drawVoidStamp(v){
        const px = v.x*canvasW;
        const py = v.y*canvasH;
        const stamp = v.r * 2 * Math.min(canvasW, canvasH);
        const cell = stamp / SHAPE_N;
        const ox = px - stamp/2;
        const oy = py - stamp/2;

        // stamp fill tinted by rarity + severity
        const base = (v.rarity < 0.45) ? [120,210,255] : [210,140,255];
        const alpha = 55 + 170*v.sev;

        noStroke();
        for (let y=0;y<SHAPE_N;y++){
          for (let x=0;x<SHAPE_N;x++){
            const i = idxS(x,y);
            if (!v.cells[i]) continue;
            fill(base[0], base[1], base[2], alpha);
            rect(ox + x*cell, oy + y*cell, cell*0.92, cell*0.92, 1.5);
          }
        }

        // outline ring by type
        const c = voidTypeColor(v.type);
        noFill();
        stroke(c[0],c[1],c[2], (v.sev >= parseFloat(UI.sEmerg.value)) ? 240 : 170);
        strokeWeight(1.8);
        circle(px,py, stamp*(0.85 + 0.55*v.sev));

        // role indicators (tiny text-like glyphs)
        if (v.requiresTi || v.requiresTe || v.initiallyHard){
          noStroke();
          fill(255,255,255,220);
          textSize(11);
          textAlign(CENTER, CENTER);
          const tags = [
            v.initiallyHard ? "?" : "",
            v.requiresTi ? "Ti" : "",
            v.requiresTe ? "Te" : "",
          ].filter(Boolean).join(" ");
          text(tags, px, py + stamp*0.55);
        }
      }

      function drawSignals(){
        if (!UI.chkShowSignals.checked) return;
        noFill();
        for (const s of signals){
          const px = s.x*canvasW;
          const py = s.y*canvasH;
          const wave = (s.t*0.9)%1.0;
          const r = (0.02 + 0.12*wave) * Math.min(canvasW,canvasH);
          const a = Math.max(0, 170*(1-wave));
          stroke(255,230,120,a);
          strokeWeight(1.5);
          circle(px,py, r*2);
        }
      }

      function drawAgent(a, i, alpha){
        const xr = lerpWrap(a.x_prev, a.x, alpha);
        const yr = lerpWrap(a.y_prev, a.y, alpha);
        const px = xr*canvasW, py = yr*canvasH;

        const base = (a.Oi>a.Oe) ? [10,55,185] : (a.Oe>a.Oi) ? [255,215,0] : [140,160,190];
        const d = agentDiscomfort(a);
        const hue = 120*(1-d);
        const comfortRGB = hsv2rgb(hue, 1.0, 1.0);
        const glyphType = (a.Di > a.De) ? "triangle" : "triangleDown";

        noStroke();
        fill(comfortRGB[0],comfortRGB[1],comfortRGB[2],235);
        drawGlyph(glyphType, px, py, 20);

        fill(base[0],base[1],base[2],255);
        drawGlyph(glyphType, px, py, 10);

        drawNeedsBars(a, px, py);

        if (UI.chkForces.checked){
          drawForceArrow(px,py, a.dispDxTask, a.dispDyTask, [30,120,255], 1.0);
          drawForceArrow(px,py, a.dispDxMean, a.dispDyMean, [255,80,80], 1.0);
        }

        if (i === selectedIdx){
          noFill();
          stroke(255,220,120,230);
          strokeWeight(2);
          circle(px,py,9);

          noFill();
          stroke(120,140,200,150);
          strokeWeight(1.5);
          const rPx = parseFloat(UI.sMeanRadius.value) * Math.min(canvasW,canvasH);
          circle(px,py, 2*rPx);

          fill(255,140,80,220);
          noStroke();
          circle(a.localMeanX*canvasW, a.localMeanY*canvasH, 6);
        }
      }

      // ===== Metrics =====
      function computeMetrics(GM){
        const binsX=12, binsY=8, N=agents.length;
        const H = new Array(binsX*binsY).fill(0);
        let meanD=0, meanEnergy=0, meanEnt=0;
        let mSafety=0, mConn=0, mStim=0, mMast=0;

        for (const a of agents){
          let ix = Math.floor(frac01(a.x)*binsX);
          ix = Math.min(binsX-1, Math.max(0,ix));
          let iy = Math.floor(frac01(a.y)*binsY);
          iy = Math.min(binsY-1, Math.max(0,iy));
          H[iy*binsX + ix]++;

          meanD += agentDiscomfort(a);
          meanEnergy += a.energy/(a.maxEnergy+1e-6);
          meanEnt += a.entropy;

          if (UI.chkInternal.checked){
            mSafety += a.needs[N_SAFETY];
            mConn += a.needs[N_CONN];
            mStim += a.needs[N_STIM];
            mMast += a.needs[N_MAST];
          }
        }

        meanD = N ? meanD/N : 0;
        meanEnergy = N ? meanEnergy/N : 0;
        meanEnt = N ? meanEnt/N : 0;
        if (N && UI.chkInternal.checked){
          mSafety/=N; mConn/=N; mStim/=N; mMast/=N;
        }

        let entropy=0;
        for (let i=0;i<H.length;i++){
          if (H[i]>0){
            const p = H[i]/N;
            entropy -= p*Math.log(p);
          }
        }
        const entropyNorm = (H.length>1) ? entropy/Math.log(H.length) : 0;

        let s2=0;
        for (const a of agents){
          const dx = wrapDeltaPhase(a.px - GM.mxPhase);
          const dy = wrapDeltaPhase(a.py - GM.myPhase);
          s2 += dx*dx + dy*dy;
        }
        const sigma = N ? Math.sqrt(s2/N) : 0;

        const eps=0.07, eps2=eps*eps;
        const parent = Array.from({length:N}, (_,i)=>i);
        const find = (i)=> parent[i]===i ? i : (parent[i]=find(parent[i]));
        const unite = (a,b)=>{ a=find(a); b=find(b); if (a!==b) parent[a]=b; };
        for (let i=0;i<N;i++){
          for (let j=i+1;j<N;j++){
            const dx = wrapDelta(agents[i].x - agents[j].x);
            const dy = wrapDelta(agents[i].y - agents[j].y);
            if (dx*dx + dy*dy < eps2) unite(i,j);
          }
        }
        const roots = new Set();
        for (let i=0;i<N;i++) roots.add(find(i));
        const clusters = N ? roots.size : 0;

        const el = document.getElementById("metrics");
        el.innerHTML = `
          <div><strong>H</strong> (spatial entropy): ${entropyNorm.toFixed(3)}</div>
          <div><strong>σ</strong> (spread): ${sigma.toFixed(3)}</div>
          <div><strong>Clusters</strong>: ${clusters}</div>
          <div><strong>Avg discomfort</strong>: ${meanD.toFixed(3)}</div>
          <div><strong>Avg energy</strong>: ${meanEnergy.toFixed(3)}</div>
          <div><strong>Avg ext-load</strong>: ${meanEnt.toFixed(3)}</div>
          <div><strong>Voids</strong>: ${voids.length} | <strong>Signals</strong>: ${signals.length}</div>
          ${
            UI.chkInternal.checked
              ? `<div><strong>Needs</strong> S:${mSafety.toFixed(2)} C:${mConn.toFixed(2)} N:${mStim.toFixed(2)} M:${mMast.toFixed(2)}</div>`
              : ``
          }
          <div class="tiny">Shape lib: ${SHAPES.length} | fps: ${Math.round(frameRate())}</div>
        `;
      }

      // ===== UI =====
      function hookUI(){
        function LBL(id, v, digits=3){
          select(id).html(typeof v==="number" ? v.toFixed(digits) : v);
        }
        function populateSelectOptions(selectEl, presetNames){
          selectEl.innerHTML="";
          presetNames.forEach((name)=>{
            if (!PRESETS[name]) return;
            const opt = document.createElement("option");
            opt.value = name;
            opt.textContent = PRESETS[name].label ?? name;
            selectEl.appendChild(opt);
          });
        }

        UI.pauseBtn = document.getElementById("pauseBtn");

        UI.sDt = document.getElementById("sDt");
        UI.sStability = document.getElementById("sStability");
        UI.sMeanRadius = document.getElementById("sMeanRadius");

        UI.sN = document.getElementById("sN");
        UI.chkTrails = document.getElementById("chkTrails");
        UI.chkForces = document.getElementById("chkForces");
        UI.chkMean = document.getElementById("chkMean");
        UI.chkNeeds = document.getElementById("chkNeeds");
        UI.btnResetAgents = document.getElementById("btnResetAgents");
        UI.btnRandomField = document.getElementById("btnRandomField");
        UI.btnClearTrails = document.getElementById("btnClearTrails");

        UI.sPerlinFreq = document.getElementById("sPerlinFreq");
        UI.sPerlinOct  = document.getElementById("sPerlinOct");
        UI.sNoise      = document.getElementById("sNoise");
        UI.chkEvolve   = document.getElementById("chkEvolve");
        UI.sEvo        = document.getElementById("sEvo");

        UI.chkInternal = document.getElementById("chkInternal");
        UI.sNeedDecay  = document.getElementById("sNeedDecay");
        UI.sNeedFill   = document.getElementById("sNeedFill");

        UI.sVoidRate   = document.getElementById("sVoidRate");
        UI.sVoidMax    = document.getElementById("sVoidMax");
        UI.sVoidGrow   = document.getElementById("sVoidGrow");
        UI.sVoidBig    = document.getElementById("sVoidBig");
        UI.sWorkRate   = document.getElementById("sWorkRate");
        UI.sEmerg      = document.getElementById("sEmerg");
        UI.sCollect    = document.getElementById("sCollect");
        UI.chkShowVoids= document.getElementById("chkShowVoids");

        UI.sSigR       = document.getElementById("sSigR");
        UI.sSigTTL     = document.getElementById("sSigTTL");
        UI.chkShowSignals = document.getElementById("chkShowSignals");

        UI.agentSpawnPreset = document.getElementById("agentSpawnPreset");
        UI.chkAddByClick = document.getElementById("chkAddByClick");
        UI.btnAddCenter = document.getElementById("btnAddCenter");
        UI.btnRandomizeMix = document.getElementById("btnRandomizeMix");

        UI.selInfo = document.getElementById("selInfo");
        UI.selAgentPreset = document.getElementById("selAgentPreset");
        UI.btnApplySelPreset = document.getElementById("btnApplySelPreset");
        UI.btnDeleteSel = document.getElementById("btnDeleteSel");

        populateSelectOptions(UI.agentSpawnPreset, SPAWNER_PRESETS);
        populateSelectOptions(UI.selAgentPreset, PRESET_ORDER);
        UI.agentSpawnPreset.value = SPAWNER_PRESETS[0];
        UI.selAgentPreset.value = PRESET_ORDER[0];

        const refreshLabels = ()=>{
          LBL("#lblDt", parseFloat(UI.sDt.value), 2);
          LBL("#lblStability", parseFloat(UI.sStability.value), 3);
          LBL("#lblMeanR", parseFloat(UI.sMeanRadius.value), 2);

          LBL("#lblNoise", parseFloat(UI.sNoise.value), 2);
          LBL("#lblEvo", parseFloat(UI.sEvo.value), 2);
          LBL("#lblFreq", parseFloat(UI.sPerlinFreq.value), 2);
          select("#lblOct").html(parseInt(UI.sPerlinOct.value));

          LBL("#lblNeedDecay", parseFloat(UI.sNeedDecay.value), 3);
          LBL("#lblNeedFill", parseFloat(UI.sNeedFill.value), 2);

          select("#lblVoidRate").html(parseInt(UI.sVoidRate.value));
          select("#lblVoidMax").html(parseInt(UI.sVoidMax.value));
          LBL("#lblVoidGrow", parseFloat(UI.sVoidGrow.value), 3);
          LBL("#lblVoidBig", parseFloat(UI.sVoidBig.value), 3);
          LBL("#lblWorkRate", parseFloat(UI.sWorkRate.value), 3);
          LBL("#lblEmerg", parseFloat(UI.sEmerg.value), 2);
          LBL("#lblCollect", parseFloat(UI.sCollect.value), 2);

          LBL("#lblSigR", parseFloat(UI.sSigR.value), 2);
          LBL("#lblSigTTL", parseFloat(UI.sSigTTL.value), 1);

          document.getElementById("lblN").textContent = agents.length;
        };
        refreshLabels();

        ["input","change"].forEach((evt)=>{
          [
            UI.sDt, UI.sStability, UI.sMeanRadius,
            UI.sN, UI.sNoise, UI.sEvo, UI.sPerlinFreq, UI.sPerlinOct,

            UI.sNeedDecay, UI.sNeedFill,

            UI.sVoidRate, UI.sVoidMax, UI.sVoidGrow, UI.sVoidBig, UI.sWorkRate, UI.sEmerg, UI.sCollect,
            UI.sSigR, UI.sSigTTL
          ].forEach(el=>el.addEventListener(evt, refreshLabels));
        });

        [UI.sPerlinFreq, UI.sPerlinOct, UI.sNoise].forEach((el)=>{
          el.addEventListener("input", ()=>buildFieldAtTime(evoTime));
        });

        UI.sN.addEventListener("input", ()=>{
          adjustAgentCount(parseInt(UI.sN.value));
          refreshLabels();
        });

        UI.btnResetAgents.addEventListener("click", ()=>{
          resetAgents(parseInt(UI.sN.value));
          refreshLabels();
        });

        UI.btnRandomField.addEventListener("click", ()=>randomizeField());
        UI.btnClearTrails.addEventListener("click", ()=>trailsLayer.clear());

        UI.pauseBtn.addEventListener("click", ()=>togglePause());

        window.addEventListener("keydown", (e)=>{
          if (e.code==="Space"){ togglePause(); e.preventDefault(); }
          if (e.key.toLowerCase()==="r") randomizeField();
          if (e.key.toLowerCase()==="a") resetAgents(parseInt(UI.sN.value));
          if (e.key.toLowerCase()==="d") deleteSelected();
          if (e.key.toLowerCase()==="v") spawnVoid(true);
        });

        UI.btnAddCenter.addEventListener("click", ()=>{
          addAgentAt(0.5,0.5, UI.agentSpawnPreset.value);
          UI.sN.value = agents.length;
          refreshLabels();
        });

        UI.btnRandomizeMix.addEventListener("click", ()=>{
          for (let i=0;i<10;i++){
            addAgentAt(Math.random(), Math.random(),
              SPAWNER_PRESETS[Math.floor(Math.random()*SPAWNER_PRESETS.length)]);
          }
          UI.sN.value = agents.length;
          refreshLabels();
        });

        UI.btnApplySelPreset.addEventListener("click", ()=>{
          if (selectedIdx>=0 && selectedIdx<agents.length){
            applyAgentPreset(agents[selectedIdx], UI.selAgentPreset.value);
          }
        });
        UI.btnDeleteSel.addEventListener("click", ()=>deleteSelected());
      }

      function togglePause(){
        paused = !paused;
        lastSec = millis()/1000;
        timeAcc = 0;
        document.getElementById("pauseBtn").textContent = paused ? "Resume" : "Pause";
      }

      function updateSelectionUI(){
        const t = (selectedIdx>=0 && selectedIdx<agents.length)
          ? `#${selectedIdx} (${agents[selectedIdx].preset})`
          : "None";
        document.getElementById("selInfo").textContent = t;
        if (selectedIdx>=0 && selectedIdx<agents.length){
          document.getElementById("selAgentPreset").value = agents[selectedIdx].preset;
        }
        document.getElementById("lblN").textContent = agents.length;
        document.getElementById("sN").value = agents.length;
      }

      function nearestAgent(u,v){
        let best=-1, bestD=1e9;
        for (let i=0;i<agents.length;i++){
          const dx = wrapDelta(agents[i].x - u);
          const dy = wrapDelta(agents[i].y - v);
          const d = Math.hypot(dx,dy);
          if (d < bestD){ bestD=d; best=i; }
        }
        return { idx: best, d: bestD };
      }

      function deleteSelected(){
        if (selectedIdx>=0 && selectedIdx<agents.length){
          agents.splice(selectedIdx,1);
          selectedIdx = -1;
          updateSelectionUI();
        }
      }

      function mousePressed(){
        if (mouseX>=0 && mouseX<canvasW && mouseY>=0 && mouseY<canvasH){
          const { idx, d } = nearestAgent(mouseX/canvasW, mouseY/canvasH);
          const pxThresh = 10;
          if (d*Math.min(canvasW,canvasH) < pxThresh){
            selectedIdx = idx;
            if (keyIsDown(SHIFT)){ deleteSelected(); return; }
            updateSelectionUI();
          } else if (UI.chkAddByClick.checked){
            addAgentAt(mouseX/canvasW, mouseY/canvasH, UI.agentSpawnPreset.value);
            updateSelectionUI();
          }
        }
      }

      function randomizeField(){
        noiseSeedBase = Math.floor(Math.random()*1e9);
        noiseSeed(noiseSeedBase);
        evoTime = 0;
        buildFieldAtTime(evoTime);
        trailsLayer.clear();

        voids = [];
        signals = [];
        nextVoidId = 1;

        initShapes();
        for (const a of agents) initAgentCognition(a);
      }

      // ===== Setup / draw =====
      function setup(){
        canvasW = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
        canvasH = windowHeight;
        createCanvas(canvasW, canvasH);

        trailsLayer = createGraphics(canvasW, canvasH);
        trailsLayer.clear();

        const N = gw*gh;
        L = new Float32Array(N);
        gImg = createImage(gw, gh);

        initShapes();
        hookUI();

        randomizeField();
        resetAgents(parseInt(document.getElementById("sN").value));

        frameRate(60);
        noStroke();
        lastSec = millis()/1000;
      }

      function windowResized(){
        canvasW = windowWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--uiw"));
        canvasH = windowHeight;
        resizeCanvas(canvasW, canvasH);
        trailsLayer = createGraphics(canvasW, canvasH);
        trailsLayer.clear();
      }

      function draw(){
        const simSpeed = parseFloat(UI.sDt.value);
        const evoOn = UI.chkEvolve.checked;

        const nowSec = millis()/1000;
        let dtReal = nowSec - lastSec;
        lastSec = nowSec;

        if (evoOn){
          const flowSpeed = parseFloat(UI.sEvo.value);
          evoTime += dtReal*flowSpeed;
        }
        if (evoOn || frameCount%2===0 || frameCount===1){
          buildFieldAtTime(evoTime);
        }

        updateWorld(dtReal*simSpeed);

        if (!paused){
          timeAcc += dtReal*simSpeed;
          let steps=0;
          while (timeAcc >= PHYS_H && steps < MAX_PHYS_STEPS){
            stepAgents(PHYS_H);
            timeAcc -= PHYS_H;
            steps++;
          }
          if (steps >= MAX_PHYS_STEPS) timeAcc = Math.min(timeAcc, PHYS_H);
        } else {
          timeAcc = 0;
        }

        if (frameCount%2===0) fieldToImage();
        image(gImg, 0,0, canvasW, canvasH);
        image(trailsLayer, 0,0);

        if (UI.chkShowVoids.checked){
          for (const v of voids) drawVoidStamp(v);
        }
        drawSignals();

        const alpha = paused ? 0 : Math.min(1, timeAcc/PHYS_H);
        const GM = computeGroupMean();
        for (let i=0;i<agents.length;i++) drawAgent(agents[i], i, alpha);

        if (UI.chkMean.checked && agents.length){
          push();
          stroke(255,230);
          strokeWeight(1);
          const px = GM.mx*canvasW, py = GM.my*canvasH;
          line(px-10,py, px+10,py);
          line(px,py-10, px,py+10);
          pop();
        }

        computeMetrics(GM);
      }

      // ===== Randn =====
      let spare = null;
      function randn(){
        if (spare !== null){
          const v = spare; spare = null; return v;
        }
        let u=0,v=0;
        while (u===0) u = Math.random();
        while (v===0) v = Math.random();
        const mag = Math.sqrt(-2.0*Math.log(u));
        const z0 = mag*Math.cos(TWO_PI*v);
        const z1 = mag*Math.sin(TWO_PI*v);
        spare = z1;
        return z0;
      }
    </script>
  </body>
</html>
